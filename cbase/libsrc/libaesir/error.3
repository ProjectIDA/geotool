.ig
% ptroff -man error.3
..
.ig
@(#)error.3	109.1	07/08/97
..
.TH ERROR 3 "1 December 1988"
.UC 4
.SH NAME
error \- IAS error handling facility
.SH SYNOPSIS
.B init_error
(program_name, user_handler)
.br
char		*program_name;
.br
void		(*user_handler)();
.sp
.B error
(error_no, severity, routine_name, error_message)
.br
int	error_no;
.br
int	severity;
.br
char	*routine_name;
.br
char	*error_message;
.sp
integer function initerror(prognam, user_handler)
.br
integer function error(errornum, severity, name, message)
.LP
.SH DESCRIPTION
.LP
.I error()
provides a uniform error reporting facility for IAS programs.
The intent is for all IAS programs to respond to and report errors
in the same manner.
.LP
.I init_error()
should be called during program initiation.
It sets up signal catching procedures for the most pernicious signals,
and (eventually) sends an initialization message to a central monitoring
process or log.
.LP
.I init_error() 
can be called up to 20 times (a parameter) to set additional error handlers.
.I error() 
provides the capability to make an attempt at cleanly shutting down
processing in the event that a signal is intercepted.  It is particularly
important to try to close out database connections in the event that a 
signal is caught.
.LP
The following signals are caught:
.sp
.in +0.5i
.nf
#define	SIGHUP		1	/* hangup */
#define	SIGQUIT	3	/* quit */
#define	SIGILL		4	/* illegal instruction */
#define	SIGTRAP	5	/* trace trap */
#define	SIGABRT	6	/* abort (generated by abort(3) routine) */
#define	SIGEMT	7	/* EMT instruction */
#define	SIGFPE		8	/* floating point exception */
#define	SIGBUS		10	/* bus error */
#define	SIGSEGV	11	/* segmentation violation */
#define	SIGSYS		12	/* bad argument to system call */
#define	SIGPIPE	13	/* write on a pipe with no one to read it */
#define	SIGXCPU	24	/* exceeded CPU time limit */
#define	SIGXFSZ	25	/* exceeded file size limit */
#define	SIGLOST	29	/* resource lost */
.fi
.in
.sp
Upon catching one of these signals, the bail-out routine will call
.I error()
with a FATAL severity, and abort the program.
If
.I user_handler
is not NULL, then the function it dereferences
will be called.
.I (*user_handler)()
is called with four arguments, as in signal(3):
.sp
.in +0.5i
.nf
void
user_handler(signo, code, scp, addr)
int	signo, code;
struct	sigcontext	*scp;
char	*addr;
.fi
.in
.sp
If no user handling routine is to be specified then (void\|(*)())\|NULL should
be passed instead.
Finally, if
.I signo
is one of SIGQUIT, SIGILL, SIGTRAP, SIGEMT, SIGKILL, SIGBUS, SIGSEGV,
SIGSYS, or SIGLOST,
then
.I abort()
is called before termination.
Note that
.I abort()
will cause the program to dump core.
.LP
The user handling routine should contain minimal code to perform
any necessary cleanup before the program is aborted.
An example of such a cleanup process would be the closing of an open database.
Note that
.I init_error()
may be called multiple times (up to 20) to specify multiple user handlers if
necessary.
In this case, the user handlers are called in reverse order in the same
manner as the \fIon_exit(3)\fP call in the Sun library.
.LP
.I program_name
should point to a character string containing the name of the
main program.
This string is used for identifying the source of error messages.
.I init_error()
must be called before first call to
.I error().
.LP
.I error()
should be called whenever errors need to be reported to a higher
authority.
.I error_no
should be the Unix errno (for C) if relevant, otherwise it should be 0:
.sp
.in +0.5i
.nf
	ierr = error(errno, severity, "open_wfdisc", "opening wfdisc file");
.fi
.in
.sp
In Fortran,
the equivalent of the C errno can be obtained with the
.I ierrno()
library routine (see perror(3f)):
.sp
.in +0.5i
.nf
	ierr = error(ierrno(), isevere, 'openwfd', 'opening wfdisc file')
.fi
.in
.sp
.I severity
reports the severity of the error.
Three levels are recognized:
.sp
.in +0.5i
.nf
#define	INFO	5	/* Informative message only. */
#define	WARNING	10	/* Warning, but with good chance of success. */
#define	SEVERE	50	/* Non-fatal, but little chance of success. */
#define	FATAL	90	/* Fatal, program must exit immediately. */
.fi
.in
.sp
All errors will print a message to standard error.
.I routine_name
should point to a string containing
the name of the subroutine in which the error occurred.
.LP
The entry points
.I error_()
and
.I initerror_()
are provided as Fortran entry points.
.SH DIAGNOSTICS
.LP
.I error(), init_error(), error_(), initerror_ 
return ERR_NOERROR if successful, ERR_ERROR if unsuccessful.
.LP
.I error()
returns ERR_ERROR if it was called before
.I init_error().
.sp
Both routines return 0 is everything went well.
.SH "NOTES"
.LP
Character string parameters are silently truncated when copied to messages
to avoid overflow.
The limit for
.I name
and
.I routine
is 30 characters, while the limit for
.I mess
is 230 characters.
.SH BUGS
.LP
Little can be done about real error recovery; these routines merely attempt
to report them.
.SH AUTHOR
Jim Wang
.SH "FILES"
.LP
libaesir.a
.br
libipc.a
.SH "SEE ALSO"
.LP
perror(3f), perror(3), signal(3), setsigmask(3)
.br
Software Policies and Procedures, Appendix I.
.sp 0.5i
.ps -1
error.3 109.1 07/08/97
.ps
