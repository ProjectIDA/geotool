<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--NewPage-->
<html>
<head>
<!-- Generated by cdoc on Wed Jan 26 05:45:09 2005 -->
<title>
file libsrc/libgODBC/ODBCGeneralQuery.c
</title>
</head>
<body>
<a name="_top_"></a><pre>
<a href="directories.html">All directories</a>  <a href="libsrc_libgODBC.html">This Directory</a>  <a href="libsrc_libgODBC_ODBCError.c.html#_top_">Previous</a>  <a href="libsrc_libgODBC_ODBCGetResultCols.c.html#_top_">Next</a>  <a href="AllNames.html">Index</a></pre>
<hr>
<h1>
File libsrc/libgODBC/ODBCGeneralQuery.c
</h1>
<hr>
<!End-Header> The routines ODBCQuery and ODBCGeneralQuery are used to retrieve the results
  of a general SQL query for which the number of columns in the result and
  their data types do not need to be specified beforehand. Unlike
  ODBCQueryTable and ODBCQueryTableResult, which return complete CSS table
  rows in CssTable structures, ODBCQuery and ODBCGeneralQuery can return any
  combination of table members or table joins.
  <p>
  ODBCQuery returns the query results as "dynamic" CssTable structures. One
  of five CssTable subclasses will be returned: CssDynamic5, CssDynamic10,
  CssDynamic20, CssDynamic40 and CssDynamic that hold up to 5, 10, 20, 40 and
  60 columns (members), respectively. (Columns greater that 60 are ignored.)
  These are "dynamic" CssTable structures, since the description of their
  members is created dynamically instead of being statically defined like
  the standard CSS tables (wfdisc, arrival, etc).  ODBCQuery creates the
  dynamic structures as needed.
  <p>
  ODBCGeneralQuery returns the query results in an ODBC_Result structure,
  which is defined as:
  <pre>
   typedef struct
   {
       SQLCHAR         columnName[ODBC_STRLEN];
       SQLSMALLINT     nameLength;
       SQLSMALLINT     dataType;
       SQLUINTEGER     columnSize;
       SQLSMALLINT     decimalDigits;
       SQLSMALLINT     nullable;
       SQLPOINTER      value;
       union {
           char                 sql_String[ODBC_STRLEN];
           SQLDOUBLE            sql_Double;
           SQLINTEGER           sql_Long;
           SQLSMALLINT          sql_Int;
           SQL_TIMESTAMP_STRUCT sql_DateTime;
       } bindTarget;
       SQLINTEGER      indicator;
       SQLINTEGER      numRows;
   } ODBC_ColumnResult;
   
   typedef struct
   {
       int               numColumns;
       int               numRows;
       ODBC_ColumnResult *column;
   } ODBC_Result;
  </pre>
  <p>
 
  The following example code demonstrates the use of ODBCGeneralQuery and
  the ODBC_Result structure.
 <pre>
 
  #include "libgODBC.h"
  
  int
  main(int argc, char **argv)
  {
      int i, autoCommit=0;
      char *dataSource="ORACLE", *user="sel3", *passwd="sel3";
      char **sta, **iphase, **phase;
      double *azimuth, *seaz, *delta;
      long *orid;
      SQLRETURN ret;
      SQLHDBC hdbc;
      ODBC_Result result;
  
      /* Connect to the data source
       */
      if((hdbc = ODBCConnect(dataSource, user, passwd, autoCommit)) == NULL) {
          logErrorMsg(LOG_WARNING, ODBCErrMsg());
          exit(1);
      }
  
      /* Submit the query and disconnect
       */
      ret = ODBCGeneralQuery(hdbc,
              "select r.sta,r.iphase,a.phase,r.azimuth,a.seaz,a.delta,a.orid\
              from arrival r, assoc a where a.orid < 100 and a.arid=r.arid",
              &result);
  
      ODBCDisconnect(hdbc);
  
      if(ret < 0) {
          logErrorMsg(LOG_WARNING, ODBCErrMsg());
          exit(1);
      }
  
      if(result.numRows == 0) {
          logErrorMsg(LOG_WARNING, "No rows returned.");
          ODBCFreeResult(&result);
          exit(0);
      }
  
      /* Set pointers to the result columns
       */
      sta     = (char **) result.column[0].value;
      iphase  = (char **) result.column[1].value;
      phase   = (char **) result.column[2].value;
      azimuth = (double *)result.column[3].value;
      seaz    = (double *)result.column[4].value;
      delta   = (double *)result.column[5].value;
      orid    = (long *)  result.column[6].value;
  
      /* Print the results
       */
      for(i = 0; i < result.numRows; i++) {
          printf("%6s %8s %8s %8.2lf %8.2lf %8.2lf %ld\n", sta[i], iphase[i],
              phase[i], azimuth[i], seaz[i], delta[i], orid[i]);
      }
  
      /* Free the result
       */
      ODBCFreeResult(&result);
  
      return(0);
  }
  </pre>
  <p>
  In the code above, we knew the number and types of columns that would
  be returned, and could directly use the result.column[].value pointer.
  Alternatively, since the ODBC_Result describes each column type, so we
  could handle the results in a more general manner. For example, instead of
  using pointers to the result.column[].value to print, we could make a
  generic print routine. The printing part of the code would them look like:
 <pre>
      ...
      if(result.numRows == 0) {
          logErrorMsg(LOG_WARNING, "No rows returned.");
          ODBCFreeResult(&result);
          exit(0);
      }
 
      /* Print the results
       */
      printResults(&result);
 
      /* Free the result
       */
      ODBCFreeResult(&result);
 
      return(0);
  }
 
  /* This generic print routine can print the results of any query.
   */
  static void
  printResults(ODBC_Result *result)
  {
      int i, j, yr;
      char buf[18];
      SQL_TIMESTAMP_STRUCT *time, *ts;
  
  
      for(j = 0; j < result->numColumns; j++) {
          printf("%8s ", result->column[j].columnName);
      }
      printf("\n");
  
      for(i = 0; i < result->numRows; i++)
      {
          for(j = 0; j < result->numColumns; j++)
          {
              ODBC_ColumnResult *c = &result->column[j];
  
              switch(c->dataType)
              {
              case SQL_CHAR:
              case SQL_VARCHAR:
                  printf("%8s ", ((char **)c->value)[i]);
                  break;
              case SQL_NUMERIC:
              case SQL_FLOAT:
              case SQL_REAL:
              case SQL_DOUBLE:
                  printf("%8.2lf ", ((double *)c->value)[i]);
                  break;
              case SQL_INTEGER:
                  printf("%8ld ", ((long *)c->value)[i]);
                  break;
              case SQL_SMALLINT:
                  printf("%8d ", ((int *)c->value)[i]);
                  break;
              case SQL_TYPE_TIMESTAMP:
                  ts = &((SQL_TIMESTAMP_STRUCT *)c->value)[i];
                  yr = (ts->year >= 100)
                          ? ts->year - (ts->year/100)*100 : ts->year;
                  printf("%02d/%02d/%02d %02d:%02d:%02d", yr, ts->month,
                      ts->day, ts->hour, ts->minute, ts->second);
                  break;
              }
          }
          printf("\n");
      }
  }
  </pre>
  The following code demonstrates the use of ODBCQuery and CssTable objects
  to accomplish the same task.
 <pre>
  #include "libgODBC.h"
  
  int
  main(int argc, char **argv)
  {
      int i, autoCommit=0, numColumns;
      char *dataSource="ORACLE", *user="sel3", *passwd="sel3";
      SQLRETURN ret;
      SQLHDBC hdbc;
      CssDescription *des;
      Vector v;
  
      /* Connect to the data source
       */
      if((hdbc = ODBCConnect(dataSource, user, passwd, autoCommit)) == NULL) {
          logErrorMsg(LOG_WARNING, ODBCErrMsg());
          exit(1);
      }
  
      /* Allocate a vector to hold the results
       */
      v = new_Vector();
  
      /* Submit the query and disconnect
       */
      ret = ODBCQuery(hdbc,
              "select r.sta,r.iphase,a.phase,r.azimuth,a.seaz,a.delta,a.orid\
              from arrival r, assoc a where a.orid < 100 and a.arid=r.arid",
              v);
  
      ODBCDisconnect(hdbc);
  
      if(ret < 0) {
          logErrorMsg(LOG_WARNING, ODBCErrMsg());
          exit(1);
      }
  
      /* Check if any rows were returned.
       */
      if(v->elementCount == 0) {
          logErrorMsg(LOG_WARNING, "No rows returned.");
          GObject_free((GObject)v);
          exit(0);
      }
  
      /* Get the number of columns (members)
       */
      numColumns = CSSTABLE_numMembers((CssTable)v->elementData[0]);
  
      /* Get the member description structures
       */
      des = CssTable_des((CssTable)v->elementData[0]);
  
      /* Print the column (member) names
       */
      for(i = 0; i < numColumns; i++) {
          printf("%8s ", des[i].name);
      }
      printf("\n");
  
      /* Print the results (rows)
       */
      for(i = 0; i < v->elementCount; i++) {
          printf("%s\n", CssTable_toString(v->elementData[i]));
      }
  
      /* Free the results
       */
      GObject_free((GObject)v);
  
      return(0);
  }
  </pre>
<hr>
<h2>
Public Function Index
</h2>
<dl>
 <dt> <img src="red_ball_small.gif" width=6 height=6 alt=" o ">
      <a href="#ODBCFreeResult"><b>ODBCFreeResult</b></a> (ODBC_Result *)
<dd> Free space allocated for a ODBC_Result structure.
 <dt> <img src="red_ball_small.gif" width=6 height=6 alt=" o ">
      <a href="#ODBCGeneralQuery"><b>ODBCGeneralQuery</b></a> (SQLHDBC, const char *, ODBC_Result *)
<dd> Retrieve the results of an arbitrary sql query.
 <dt> <img src="red_ball_small.gif" width=6 height=6 alt=" o ">
      <a href="#ODBCQuery"><b>ODBCQuery</b></a> (SQLHDBC, const char *, Vector)
<dd> Retrieve the results of an arbitrary sql query.
</dl>
<h2>
Public Functions
</h2>
<img src="red_ball.gif" width=12 height=12 alt= " o ">
<a name="ODBCFreeResult"><b>ODBCFreeResult</b></a>
<pre>
 void ODBCFreeResult(<a href="include_libgODBC.h.html#ODBC_Result">ODBC_Result</a> *result)
</pre>
<dl>
<dd>  Free space allocated for a ODBC_Result structure.

</dl>
<img src="red_ball.gif" width=12 height=12 alt= " o ">
<a name="ODBCGeneralQuery"><b>ODBCGeneralQuery</b></a>
<pre>
 int ODBCGeneralQuery(SQLHDBC hdbc,
                      const char *query,
                      <a href="include_libgODBC.h.html#ODBC_Result">ODBC_Result</a> *result)
</pre>
<dl>
<dd>  Retrieve the results of an arbitrary sql query. The query can request
  individual columns and table joins.  The ODBC_Result structure is filled
  with the number of columns, the column descriptions, the number of rows
  and the values in each column.

<p>
<dd><dl>
<dt> <b>Parameters:</b>
<dd> hdbc - A connection handle obtained from ODBCConnect().

<dd> query - An arbitrary SQL query that does not have to return complete  CSS table rows, but can return combinations of columns and joins.

<dd> result - An ODBC_Result structure to receive the results.

<dt> <b>Returns:</b>
<dd> the number of columns in the result or -1 to indicate an error.  Retrieve the error number and error message with ODBCErrno() and  ODBCErrMsg().

</dl></dd>
</dl>
<img src="red_ball.gif" width=12 height=12 alt= " o ">
<a name="ODBCQuery"><b>ODBCQuery</b></a>
<pre>
 int ODBCQuery(SQLHDBC hdbc,
               const char *query,
               Vector table)
</pre>
<dl>
<dd>  Retrieve the results of an arbitrary sql query. The query can request
  individual columns and table joins.  The ODBC_Result structure is filled
  with the number of columns, the column descriptions, the number of rows
  and the values in each column.
 

<p>
<dd><dl>
<dt> <b>Parameters:</b>
<dd> hdbc - A connection handle obtained from ODBCConnect().

<dd> query - An arbitrary SQL query that does not have to return complete  CSS table rows, but can return combinations of columns and joins.

<dt> <b>Returns:</b>
<dd> the number of columns in the result or -1 to indicate an error.  Retrieve the error number and error message with ODBCErrno() and  ODBCErrMsg().

</dl></dd>
</dl>
<!Begin-Footer><hr>
<pre>
<a href="directories.html">All directories</a>  <a href="libsrc_libgODBC.html">This Directory</a>  <a href="libsrc_libgODBC_ODBCError.c.html#_top_">Previous</a>  <a href="libsrc_libgODBC_ODBCGetResultCols.c.html#_top_">Next</a>  <a href="AllNames.html">Index</a></pre>
</body>
</html>
