<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE>The Geotool Scripting Language</TITLE>
	<META NAME="AUTHOR" CONTENT="Ivan Henson">
	<STYLE TYPE="text/css">
		TD P.western { font-family: "Nimbus Sans L", sans-serif }
		H1.western { font-family: "Nimbus Sans L", sans-serif; font-size: 14pt; font-weight: normal }
		P.western { font-family: "Nimbus Sans L", sans-serif }
		PRE.western { }
		H2.western { font-family: "Nimbus Sans L", sans-serif; font-size: 14pt; font-weight: normal }
		DD.western { font-family: "Nimbus Sans L", sans-serif }
	</STYLE>
</HEAD>
<BODY LANG="en-US" DIR="LTR">
<H1 CLASS="western" ALIGN=CENTER>The Geotool Scripting Language</H1>
    <DD CLASS="western"><b>Table of Contents</b></DD>
<DL>
    <DD><A HREF="#Introduction">1.0 Introduction</A></DD>
    <DD><A HREF="#Command and Variable Context">2.0 Command and Variable Context</A></DD>
    <DL>
	<DD CLASS="western"><A HREF="#Commands to Windows of the Same Type">Commands to Windows of the Same Type</A></DD>
	<DD CLASS="western"><A HREF="#Variable Context">Variable Context</A></DD>
    </DL>
	<DD><A HREF="#General Commands">3.0 General Commands</A></DD>
    <DL><DL>
	<P CLASS="western">
	<A HREF="#alias">alias</A>, 
	<A HREF="#defined">defined</A>, 
	<A HREF="#export">export</A>, 
	<A HREF="#help">help</A>, 
	<A HREF="#parse">parse</A>, 
	<A HREF="#parse_string">parse_string</A>, 
	<A HREF="#print">print</A>, 
	<A HREF="#printf">printf</A>, 
	<A HREF="#printClose">printClose</A>, 
	<A HREF="#printOpen">printOpen</A>, 
	<A HREF="#set">set</A>, 
	<A HREF="#setb">setb</A>, 
	<A HREF="#sprint">sprint</A>, 
	<A HREF="#sprintf">sprintf</A>, 
	<A HREF="#system">system</A>, 
	<A HREF="#unalias">unalias</A>, 
	<A HREF="#unset">unset</A>, 
	<A HREF="#wait">wait</A>, 
	<A HREF="#writeArray">writeArray</A>, 
	<A HREF="#writeClose">writeClose</A>, 
	<A HREF="#writeDouble">writeDouble</A>, 
	<A HREF="#writeInt">writeInt</A>, 
	<A HREF="#writeFloat">writeFloat</A>, 
	<A HREF="#writeLong">writeLong</A>, 
	<A HREF="#writeOpen">writeOpen</A>, 
	<A HREF="#writeString">writeString</A>
	</P>
    </DL></DL>
    <DD><A HREF="#Special Characters">4.0 Special Characters</A></DD>
    <DL>
	<DD CLASS="western"><A HREF="#Logical operators">Logical operators</A></DD>
	<DD CLASS="western"><A HREF="#Parsing control">Parsing control</A></DD>
	<DD CLASS="western"><A HREF="#Arithmetic operators">Arithmetic operators</A></DD>
    </DL>
    <DD><A HREF="#Control Flow">5.0 Control Flow</A></DD>
    <DL>
	<DD CLASS="western"><A HREF="#Conditional Blocks">Conditional Blocks (if, elseif, else, endif)</A></DD>
	<DD CLASS="western"><A HREF="#Loops">Loops (foreach, endfor, break)</A></DD>
	<DL>
		<DD CLASS="western"><A HREF="#foreach(a)">foreach(a)</A></DD>
		<DD CLASS="western"><A HREF="#foreach(wave, w)">foreach(wave, w)</A></DD>
		<DD CLASS="western"><A HREF="#foreach(beg, end, index)">foreach(beg, end, index)</A></DD>
		<DD CLASS="western"><A HREF="#break">break</A></DD>
		<DD CLASS="western"><A HREF="#for_index">for_index</A></DD>
		<DD CLASS="western"><A HREF="#wave.find_indices">wave.find_indices</A></DD>
		<DD CLASS="western"><A HREF="#table.find_indices">table.find_indices</A></DD>
	</DL>
	<DD CLASS="western"><A HREF="#Parsing Files">Parsing Files</A></DD>
    </DL>
    <DD><A HREF="#Variables">6.0 Variables</A></DD>
	<DL>
		<DD CLASS="western"><A HREF="#Variable Assignment">Variable Assignment</A></DD>
		<DD CLASS="western"><A HREF="#Local and Global Scope">Local and Global Scope</A></DD>
		<DD CLASS="western"><A HREF="#Arrays">Arrays</A></DD>
	</DL>
    <DD><A HREF="#Constants">7.0 Constants and Reserved Names</A></DD>
    <DD><A HREF="#Functions">8.0 Functions</A></DD>
	<DL>
		<DD CLASS="western"><A HREF="#libm functions">libm functions</A></DD>
		<DD CLASS="western"><A HREF="#geographic and time functions">geographic and time functions</A></DD>
	</DL>
    <DD><A HREF="#Waveforms">9.0 Waveforms</A></DD>
	<DL>
		<DD CLASS="western"><A HREF="#waveform object names">waveform object names</A></DD>
		<DD CLASS="western"><A HREF="#selected waveform object names">selected waveform object names</A></DD>
		<DD CLASS="western"><A HREF="#waveform object syntax">waveform object syntax</A></DD>
		<DL><DL>
			<P CLASS="western">
			<A HREF="#convolve">convolve</A>, 
			<A HREF="#copy">copy</A>, 
			<A HREF="#cut">cut</A>, 
			<A HREF="#deconvolve">deconvolve</A>, 
			<A HREF="#delete">delete</A>, 
			<A HREF="#deselect">deselect</A>, 
			<A HREF="#display_calib">display_calib</A>, 
			<A HREF="#display_counts">display_counts</A>, 
			<A HREF="#display_waveform">display_waveform</A>, 
			<A HREF="#filter">filter</A>, 
			<A HREF="#output">output</A>, 
			<A HREF="#print_wave">print</A>, 
			<A HREF="#normal_polarity">normal_polarity</A>, 
			<A HREF="#remove_all_methods">remove_all_methods</A>, 
			<A HREF="#remove_con_decon">remove_con_decon</A>, 
			<A HREF="#remove_mean">remove_mean</A>, 
			<A HREF="#restore_mean">restore_mean</A>, 
			<A HREF="#reverse_polarity">reverse_polarity</A>, 
			<A HREF="#select">select</A>, 
			<A HREF="#unfilter">unfilter</A>, 
			<A HREF="#update_tag">update_tag</A>, 
			<A HREF="#zoom_on_waveform">zoom_on_waveform</A>
			</P>
		</DL></DL>
		<DD CLASS="western"><A HREF="#waveform members">waveform members</A></DD>
		<DD CLASS="western"><A HREF="#waveform segment members">waveform segment members</A></DD>
		<DD CLASS="western"><A HREF="#waveform object methods">waveform object methods</A></DD>
	</DL>
    <DD><A HREF="#Database Tables">10.0 Database Tables</A></DD>
	<DL>
		<DD CLASS="western"><A HREF="#deselect_table">deselect</A></DD>
		<DD CLASS="western"><A HREF="#edit_table">edit</A></DD>
		<DD CLASS="western"><A HREF="#print_table">print</A></DD>
		<DD CLASS="western"><A HREF="#select_table">select</A></DD>
		<DD CLASS="western"><A HREF="#remove_from_db">remove_from_db</A></DD>
		<DD CLASS="western"><A HREF="#add_table_cb">add_table_cb</A></DD>
		<DD CLASS="western"><A HREF="#modified_table_cb">modified_table_cb</A></DD>
		<DD CLASS="western"><A HREF="#deleted_table_cb">deleted_table_cb</A></DD>
	</DL>
    <DD><A HREF="#Data I/O">11.0 Data I/O</A></DD>
	<DL>
		<DD CLASS="western"><A HREF="#read">read</A></DD>
		<DD CLASS="western"><A HREF="#recent_input">recent_input</A></DD>
		<DD CLASS="western"><A HREF="#connect">connect</A></DD>
		<DD CLASS="western"><A HREF="#disconnect">disconnect</A></DD>
		<DD CLASS="western"><A HREF="#get_aao">get_aao</A></DD>
		<DD CLASS="western"><A HREF="#get_aaow">get_aaow</A></DD>
		<DD CLASS="western"><A HREF="#get_all_tables">get_all_tables</A></DD>
		<DD CLASS="western"><A HREF="#get_wfdiscs">get_wfdiscs</A></DD>
		<DD CLASS="western"><A HREF="#mapping">mapping</A></DD>
		<DD CLASS="western"><A HREF="#query">query</A></DD>
		<DD CLASS="western"><A HREF="#read_waveforms">read_waveforms</A></DD>
		<DD CLASS="western"><A HREF="#The edit command">The edit and remove_from_db commands</A></DD>
		<DD CLASS="western"><A HREF="#Other data formats">Other data formats</A></DD>
		<DD CLASS="western"><A HREF="#import">import</A></DD>
		<DD CLASS="western"><A HREF="#Output">Output</A></DD>
	</DL>
    <DD><A HREF="#Creating Graphical Components">12.0 Creating Graphical Components</A></DD>
	<DL>
		<DD CLASS="western"><A HREF="#geotool_scripts">~/.geotool++/scripts/init</A></DD>
		<DD CLASS="western"><A HREF="#General window commands">General window commands</A></DD>
		<DL>
		    <DD CLASS="western"><A HREF="#addToToobar">addToToobar</A></DD>
		    <DD CLASS="western"><A HREF="#choiceQuestion">choiceQuestion</A></DD>
		    <DD CLASS="western"><A HREF="#close">close</A></DD>
		    <DD CLASS="western"><A HREF="#create">create</A></DD>
		    <DD CLASS="western"><A HREF="#hide">hide</A></DD>
		    <DD CLASS="western"><A HREF="#listQuestion">listQuestion</A></DD>
		    <DD CLASS="western"><A HREF="#open">open</A></DD>
		    <DD CLASS="western"><A HREF="#listCallbacks">listCallbacks</A></DD>
		    <DD CLASS="western"><A HREF="#listChildren">listChildren</A></DD>
		    <DD CLASS="western"><A HREF="#setSensitive">setSensitive</A></DD>
		    <DD CLASS="western"><A HREF="#setInsensitive">setInsensitive</A></DD>
		    <DD CLASS="western"><A HREF="#show">show</A></DD>
		    <DD CLASS="western"><A HREF="#textQuestion">textQuestion</A></DD>
		    <DD CLASS="western"><A HREF="#showMessage">showMessage</A></DD>
		    <DD CLASS="western"><A HREF="#showWarning">showWarning</A></DD>
		</DL>
		<DD CLASS="western"><A HREF="#popup_window">Creating a popup window</A></DD>
		<DD CLASS="western"><A HREF="#exchange_responses">Exchange instrument responses</A></DD>
		<DD CLASS="western"><A HREF="#A Table Example">A Table Example</A></DD>
		<DD CLASS="western"><A HREF="#popup_menus">The arrival and waveform popup menus</A></DD>
		<DD CLASS="western"><A HREF="#fk detector">A Simple Arrival Detector</A></DD>
	</DL>
    <DD><A HREF="#Waveform Window Commands">13.0 Waveform Window Commands</A></DD>
	<DL><DL>
	<P CLASS="western">
	<A HREF="#ww_add_arrival">add_arrival</A>, 
	<A HREF="#ww_align_on_phase">align_on_phase</A>, 
	<A HREF="#ww_align_on_predicted_phase">align_on_predicted_phase</A>, 
	<A HREF="#ww_align_first_point">align_first_point</A>, 
	<A HREF="#ww_align_true_time">align_true_time</A>, 
	<A HREF="#ww_align_predicted_firstP">align_predicted_firstP</A>, 
	<A HREF="#ww_align_observed_firstP">align_observed_firstP</A>, 
	<A HREF="#ww_arrivals_off">arrivals_off</A>, 
	<A HREF="#ww_arrivals_on_one_channel">arrivals_on_one_channel</A>, 
	<A HREF="#ww_arrivals_on_all_channels">arrivals_on_all_channels</A>, 
	<A HREF="#ww_auto_scale_on">auto_scale_on</A>, 
	<A HREF="#ww_auto_scale_off">auto_scale_off</A>, 
	<A HREF="#ww_beam">beam</A>, 
	<A HREF="#ww_clear">clear</A>, 
	<A HREF="#ww_components_all">components_all</A>, 
	<A HREF="#ww_components_z_only">components_z_only</A>, 
	<A HREF="#ww_components_n_and_e">components_n_and_e</A>, 
	<A HREF="#ww_components_n_only">components_n_only</A>, 
	<A HREF="#ww_components_e_only">components_e_only</A>, 
	<A HREF="#ww_components_e_only">components_e_only</A>, 
	<A HREF="#ww_convolve">convolve</A>, 
	<A HREF="#ww_copy">copy</A>, 
	<A HREF="#ww_copy">copy</A>, 
	<A HREF="#ww_deconvolve">deconvolve</A>, 
	<A HREF="#ww_delete">delete</A>, 
	<A HREF="#ww_delete_all_cursors">delete_all_cursors</A>, 
	<A HREF="#ww_delete_crosshair">delete_crosshair</A>, 
	<A HREF="#ww_delete_data">delete_data</A>, 
	<A HREF="#ww_delete_line">delete_line</A>, 
	<A HREF="#ww_delete_phase_line">delete_phase_line</A>, 
	<A HREF="#ww_delete_time_window">delete_time_window</A>, 
	<A HREF="#ww_deselect">deselect</A>, 
	<A HREF="#ww_deselect_all">deselect_all</A>, 
	<A HREF="#ww_deselect_all_arrivals">deselect_all_arrivals</A>, 
	<A HREF="#ww_display_all_data">display_all_data</A>, 
	<A HREF="#ww_display_amplitude_scale">display_amplitude_scale</A>, 
	<A HREF="#ww_display_calib">display_calib</A>, 
	<A HREF="#ww_display_counts">display_counts</A>, 
	<A HREF="#ww_display_selected_only">display_selected_only</A>, 
	<A HREF="#ww_display_tags">display_tags</A>, 
	<A HREF="#ww_display_waveform">display_waveform</A>, 
	<A HREF="#ww_filter">filter</A>, 
	<A HREF="#ww_hide_amplitude_scale">hide_amplitude_scale</A>, 
	<A HREF="#ww_hide_tags">hide_tags</A>, 
	<A HREF="#ww_independent_scale">independent_scale</A>, 
	<A HREF="#ww_movement_none">movement_none</A>, 
	<A HREF="#ww_movement_x">movement_x</A>, 
	<A HREF="#ww_movement_y">movement_y</A>, 
	<A HREF="#ww_movement_xy">movement_xy</A>, 
	<A HREF="#ww_output">output</A>, 
	<A HREF="#ww_page_up">page_up</A>, 
	<A HREF="#ww_page_left">page_left</A>, 
	<A HREF="#ww_page_right">page_right</A>, 
	<A HREF="#ww_page_up">page_up</A>, 
	<A HREF="#ww_partial_select">partial_select</A>, 
	<A HREF="#ww_paste">paste</A>, 
	<A HREF="#ww_position">position</A>, 
	<A HREF="#ww_position_crosshair">position_crosshair</A>, 
	<A HREF="#ww_position_time_window">position_time_window</A>, 
	<A HREF="#ww_position_line_cursor">position_line_cursor</A>, 
	<A HREF="#ww_position_phase_line">position_phase_line</A>, 
	<A HREF="#ww_print">print</A>, 
	<A HREF="#ww_print_window.print">print_window.print</A>, 
	<A HREF="#ww_print_window.set">print_window.set</A>, 
	<A HREF="#ww_promote_selected_waveforms">promote_selected_waveforms</A>, 
	<A HREF="#ww_normal_polarity">normal_polarity</A>, 
	<A HREF="#ww_remove_all_cursors">remove_all_cursors</A>, 
	<A HREF="#ww_remove_all_methods">remove_all_methods</A>, 
	<A HREF="#ww_remove_con_decon">remove_con_decon</A>, 
	<A HREF="#ww_remove_mean">remove_mean</A>, 
	<A HREF="#ww_restore_mean">restore_mean</A>, 
	<A HREF="#ww_reverse_polarity">reverse_polarity</A>, 
	<A HREF="#ww_rotate">rotate</A>, 
	<A HREF="#ww_scale_down">scale_down</A>, 
	<A HREF="#ww_scale_up">scale_up</A>, 
	<A HREF="#ww_scroll_down">scroll_down</A>, 
	<A HREF="#ww_scroll_left">scroll_left</A>, 
	<A HREF="#ww_scroll_right">scroll_right</A>, 
	<A HREF="#ww_scroll_up">scroll_up</A>, 
	<A HREF="#ww_select">select</A>, 
	<A HREF="#ww_select_all">select_all</A>, 
	<A HREF="#ww_select_all_arrivals">select_all_arrivals</A>, 
	<A HREF="#ww_select_visible">select_visible</A>, 
	<A HREF="#ww_select_visible_z">select_visible_z</A>, 
	<A HREF="#ww_select_visible_horz">select_visible_horz</A>, 
	<A HREF="#ww_set_axes_labels">set_axes_labels</A>, 
	<A HREF="#ww_set_current_scale">set_current_scale</A>, 
	<A HREF="#ww_set_default_order">set_default_order</A>, 
	<A HREF="#ww_set_layout">set_layout</A>, 
	<A HREF="#ww_set_working_orid">set_working_orid</A>, 
	<A HREF="#ww_sort_waveforms">sort_waveforms</A>, 
	<A HREF="#ww_space_more">space_more</A>, 
	<A HREF="#ww_space_less">space_less</A>, 
	<A HREF="#ww_tag_contents">tag_contents.set</A>, 
	<A HREF="#ww_time_scale_epoch">time_scale_epoch</A>, 
	<A HREF="#ww_time_scale_hms">time_scale_hms</A>, 
	<A HREF="#ww_time_scale_seconds">time_scale_seconds</A>, 
	<A HREF="#ww_time_scale_variable">time_scale_variable</A>, 
	<A HREF="#ww_time_window">time_window</A>, 
	<A HREF="#ww_time_zoom">time_zoom</A>, 
	<A HREF="#ww_total_select">total_select</A>, 
	<A HREF="#ww_unfilter">unfilter</A>, 
	<A HREF="#ww_unfilter_all">unfilter_all</A>, 
	<A HREF="#ww_uniform_scale">uniform_scale</A>, 
	<A HREF="#ww_unrotate">unrotate</A>, 
	<A HREF="#ww_unzoom">unzoom</A>, 
	<A HREF="#ww_unzoom_all">unzoom_all</A>, 
	<A HREF="#ww_unzoom_horizontal_all">unzoom_horizontal_all</A>, 
	<A HREF="#ww_unzoom_vertical_all">unzoom_vertical_all</A>, 
	<A HREF="#ww_update_tag">update_tag</A>, 
	<A HREF="#ww_waveform_color">waveform_color</A>, 
	<A HREF="#ww_zoom">zoom</A>, 
	<A HREF="#ww_zoom_on_waveform">zoom_on_waveform</A>
	</P>
	</DL></DL>
    <DD><A HREF="#Waveform Window Variables">14.0 Waveform Window Variables</A></DD>
	<DL>
	<DD CLASS="western"><A HREF="#crosshair[i]">crosshair[i]</A></DD>
	<DD CLASS="western"><A HREF="#line_cursor[i]">line_cursor[i]</A></DD>
	<DD CLASS="western"><A HREF="#num_crosshairs">num_crosshairs</A></DD>
	<DD CLASS="western"><A HREF="#num_line_cursors">num_line_cursors</A></DD>
	<DD CLASS="western"><A HREF="#num_phase_lines">num_phase_lines</A></DD>
	<DD CLASS="western"><A HREF="#num_time_windows">num_time_windows</A></DD>
	<DD CLASS="western"><A HREF="#phase_line[i]">phase_line[i]</A></DD>
	<DD CLASS="western"><A HREF="#plot_xmax">plot_xmax</A></DD>
	<DD CLASS="western"><A HREF="#plot_xmin">plot_xmin</A></DD>
	<DD CLASS="western"><A HREF="#plot_ymax">plot_ymax</A></DD>
	<DD CLASS="western"><A HREF="#plot_ymin">plot_ymin</A></DD>
	<DD CLASS="western"><A HREF="#sel_TABLE[i]">sel_TABLE[i]</A></DD>
	<DD CLASS="western"><A HREF="#sel_TABLE.size">sel_TABLE.size()</A></DD>
	<DD CLASS="western"><A HREF="#sel_wave[i]">sel_wave[i]</A></DD>
	<DD CLASS="western"><A HREF="#sel_wave.size">sel_wave.size()</A></DD>
	<DD CLASS="western"><A HREF="#TABLE[i]">TABLE[i]</A></DD>
	<DD CLASS="western"><A HREF="#TABLE.size">TABLE.size()</A></DD>
	<DD CLASS="western"><A HREF="#time_window[i]">time_window[i]</A></DD>
	<DD CLASS="western"><A HREF="#wave[i]">wave[i]</A></DD>
	<DD CLASS="western"><A HREF="#wave.size">wave.size()</A></DD>
  	</DL>
    <DD><A HREF="#Windows that Display Tables">15.0 Windows that Display Tables</A></DD>
	<DL>
	<DD CLASS="western"><A HREF="#Table Commands">Table Commands</A></DD>
	<DD CLASS="western"><A HREF="#CSSTable Commands">CSSTable Commands</A></DD>
  	</DL>
    <DD><A HREF="#Command Line Arguments">16.0 Command Line Arguments</A></DD>
	<DL>
	<DD CLASS="western"><A HREF="#geotool -i">geotool -i</A></DD>
	<DD CLASS="western"><A HREF="#geotool parse=">geotool parse=</A></DD>
	<DD CLASS="western"><A HREF="#geotool window=">geotool window=</A></DD>
	<DD CLASS="western"><A HREF="#scripts/init/cmdline">scripts/init/cmdline</A></DD>
  	</DL>
    <DD><A HREF="#Interprocess Messages">17.0 Interprocess Messages</A></DD>
    <DD><A HREF="#Shared Library Interface">18.0 Adding Commands Using a Shared Library Interface</A></DD>
    <DD><A HREF="#Testing and Validation">19.0 Testing and Validation</A></DD>
    <DD><A HREF="#Example Scripts">20.0 Example Scripts</A></DD>
	<DL>
	<DD CLASS="western"><A HREF="#Creating a Waveform Beam">Creating a Waveform Beam</A></DD>
	<DD CLASS="western"><A HREF="#Cepstral Analysis">Cepstral Analysis</A></DD>
	<DD CLASS="western"><A HREF="#Correlation Analysis">Correlation Analysis</A></DD>
	<DD CLASS="western"><A HREF="#Filtering">Filtering</A></DD>
	<DD CLASS="western"><A HREF="#Fourier Transform">Fourier Transform</A></DD>
	<DD CLASS="western"><A HREF="#FK Analysis">FK Analysis</A></DD>
	<DD CLASS="western"><A HREF="#Event Location">Event Location</A></DD>
	<DD CLASS="western"><A HREF="#Polarization Filter">Polarization Filter</A></DD>
	<DD CLASS="western"><A HREF="#Polarization Analysis">Polarization Analysis</A></DD>
	<DD CLASS="western"><A HREF="#Component Rotation">Component Rotation</A></DD>
	<DD CLASS="western"><A HREF="#Spectrogram Analysis">Spectrogram Analysis</A></DD>
	<DD CLASS="western"><A HREF="#Amplitudes and Magnitudes">Amplitudes and Magnitudes</A></DD>
  	</DL>
    <DD><A HREF="script_appendices.html#Appendix A">Appendix A: Graphical Components</A></DD>
    <DD><A HREF="script_appendices.html#Appendix B">Appendix B: Graphical Callbacks</A></DD>
    <DD><A HREF="script_appendices.html#Appendix C">Appendix C: Time Formats Recognized by the epoch Function</A></DD>

<H1 CLASS="western"><A NAME="Introduction"></A>1.0 Introduction</H1>

<DL>
<P CLASS="western">
The geotool scripting language provides an interface to most of the functionality that is available
through geotool's graphical interface. It enhances the usefulness of the program by enabling
three types of operations:</P>
<UL>
	<LI><P CLASS="western">Non-interactive data processing</P>
	<LI><P CLASS="western">The addition of components to geotool's graphical interface</P>
	<LI><P CLASS="western">Automatic testing and validation of geotool's operations</P>
</UL>
<H2 CLASS="western"><A NAME="Non-interactive"></A>Non-interactive data processing</H2>
<P CLASS="western">
The Geotool command line argument &quot;-i&quot; instructs the program to run without displaying its
graphical interface. In this mode, the program reads commands that are typed into the shell window at
the prompt:</P>
<P CLASS="western">geotool&gt;</P>
<P CLASS="western">
A script file can be input to the program by redirecting the standard input:</P>
<P CLASS="western">geotool -i &lt; scriptfile</P>
<P CLASS="western">
Or, the "parse" argument can be used:</P>
<P CLASS="western">geotool -i parse=scriptfile</P>
<P CLASS="western">
<H2 CLASS="western"><A NAME="Adding Graphical Components"></A>Adding Graphical Components</H2>
<P CLASS="western">
The scripting language has commands that add Buttons, Toggles and popup windows that contain
graphical components. Script callbacks that process data can be attached to buttons. For example,
the following script adds a button to the Toolbar that applies a 2-4Hz filter to all selected waveforms.</P>
<DL>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
Option.create name=&quot;F24&quot; type=&quot;button&quot;         # Create a button in the Option menu.
addToToolbar name=&quot;F24&quot; toolbar_name=&quot;F24&quot;     # Display the button in the toolbar.

# Specify the commands that will be executed when the button is selected
Option.F24.activateCallback={
    foreach(sel_wave, w)                            # Loop over all selected waveforms
        filter w low=2. high=4. order=3 type=&quot;BP&quot;   # Filter each selected waveform
    endfor
}</PRE>
		</TD>
	</TR>
	</TABLE>
</DL>
<H2 CLASS="western"><A NAME="Testing"></A>Testing</H2>
<P CLASS="western">
The geotool scripting language can be used to verify that data processing methods are still working
correctly, since the language has access to all processing results. For example, the waveform
values can be accessed after data processing has been applied. The following script is part of a
test script that verifies that the filter operation is producing the same results.</P>
<DL>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
read file=data_file query=&quot;select * from wfdisc where sta='DAVOX'&quot;

filter wave[1] low=2.0 high=4.0 type=&quot;BP&quot; order=3 zp=false

# check 10 &quot;random&quot; samples of the waveform
set i=5,357,983,2869,9487,12583,15209,24000,2849,36000
set d=3.927271e-05,0.02832408,-0.02036302,0.1189945,0.1116825,-0.248249,\
	-0.2940798,-0.1627481,-0.0677654,0.05900792

setb ok=true
foreach(i)
    if(wave[1].seg[1].data[i] != d[for_index])
	setb ok=false
    endif
endfor
if( ok )
    print &quot;filter test 1 OK&quot;
else
   print &quot;filter test 1 failed&quot;
endif
</PRE>
		</TD>
	</TR>
	</TABLE>
</DL>
<P CLASS="western">
Similarly, the results from other data processing methods such as the FK matrix can be tested:</P>
<DL>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
read file=data_file query=&quot;select * from wfdisc where sta like 'AS' and chan='SHZ'&quot;
time_window phase=&quot;P&quot; lead=5 lag=10
select_all

fk_multi_band.compute

set i=35,629,925,1592,2597,3052
set d=4.491562,7.425816,2.750253,2.00795,-0.4443082,0.1626
setb ok=true
foreach(i)
    if(fk_multi_band.fk[1].matrix[i] != d[for_index])
	setb ok=false
    endif
endfor
if( ok )
    print &quot;fk_multi_band test 1 OK&quot;
else
    print &quot;fk_multi_band test 1 failed&quot;
endif
</PRE>
		</TD>
	</TR>
	</TABLE>
</DL>
<H2 CLASS="western"><A NAME="Scripting"></A>Scripting</H2>
<P CLASS="western">
The geotool scripting language is similar to a Unix shell language, but with fewer language constructs. It
has the standard conditional execution controls (if, else if, else, endif) and loop execution controls
(foreach, break, endfor). It has variables, string manipulation, arithmetic operations, and function calls.</P>
<P CLASS="western">
The geotool scripting language has many predefined variables that refer
to the data objects. For example, the following command applies a
filter to the first waveform, referred to as wave[1].</P>
<DL>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">filter wave[1] low=2.0 high=4.0</PRE>
		</TD>
	</TR>
	</TABLE>
</DL>
<P CLASS="western">
There are predefined variables for all table objects. The following script
uses the origin, assoc and arrival variables to select all Pn and P
arrivals for all origins that have mb &gt; 3.0.</P>
<DL>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
foreach(origin, o)                     # loop over all origin objects
    if( o.mb &gt; 3.0 )
        foreach(assoc, s)              # loop over all assoc objects
            if( s.orid == o.orid &amp;&amp; (s.phase == 'Pn' || s.phase == 'P') )
                foreach(arrival, a)            # loop over all arrival objects
                    if(a.arid == s.arid)
                        select a               # select the arrival
                    endif
                endfor
            endif
        endfor
    endif
endfor</PRE>
		</TD>
	</TR>
	</TABLE>
</DL>
<P CLASS="western">The scripting language allows variable assignment with basic arithmetic and function interpretation.
The following script computes the signal-to-noise ratio and the deltim attribute from a data window at arrival[1] on wave[4].
It illustrates the usage of variable assignment, conditional if-endif blocks, foreach-endfor loops, object functions such as
wave.nearestSegment(), waveform data access (wave[4].seg[j].data[i]) and math functions (fabs, double, log10).</P>
<DL>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
#define parameters
ltav_len = 60.0
stav_len = 1.0
min_snr = 4.0
max_snr = 18.0
min_deltim = 0.685
max_deltim = 1.720

tmin = arrival[1].time - ltav_len
tmax = arrival[1].time + stav_len

# check that there is no gap in the waveform during the time interval of interest
if( wave[4].nearestSegment(tmin) != wave[4].nearestSegment(tmax) )
    print "Multiple segments in the time interval"
    return
endif

# compute the long-term average over an interval of 60 seconds before the arrival
tmin = arrival[1].time - ltav_len
tmax = arrival[1].time

j = wave[4].nearestSegment(tmin)
beg = wave[4].nearestIndex(tmin)
end = wave[4].nearestIndex(tmax)
ltav = 0.
foreach(beg, end, i)            # This is equivalent to the C for(i = beg; i &lt;= end; i++)
    ltav = ltav + fabs(wave[4].seg[j].data[i])
endfor

n = end - beg + 1
if( n &gt; 0 )
    ltav = ltav/double(n)       # Unlike the C (double) cast, double has a function syntax here
endif

# compute the short-term average over an interval of 1 second starting at the arrival
tmin = arrival[1].time
tmax = arrival[1].time + stav_len

beg = wave[4].nearestIndex(tmin)
end = wave[4].nearestIndex(tmax)
stav = 0.
foreach(beg, end, i)            # This is equivalent to the C for(i = beg; i &lt;= end; i++)
    stav = stav + fabs(wave[4].seg[j].data[i])
endfor

n = end - beg + 1
if( n &gt; 0 )
    stav = stav/double(n)
endif

if( ltav != 0. )
    snr = stav/ltav
    deltim_diff = max_deltim - min_deltim
    deltim = max_deltim - deltim_diff * log10(snr/min_snr) / log10(max_snr/min_snr)
    print &quot;snr=&quot; snr(%.4g) &quot; deltim= &quot; deltim(%.4g)
endif</PRE>
		</TD>
	</TR>
	</TABLE>
</DL>
<P CLASS="western">
The scripting language also includes commands to retrieve and set the contents of all components in the graphical interface,
such as the tables, text fields, toggle buttons, and option menus.</P>
</DL>
<H1 CLASS="western"><A NAME="Command and Variable Context"></A>2.0 Command and Variable Context</H1>
<DL>
<P CLASS="western">The general syntax for commands has one of the three forms:</P>
<UL>
	<LI><P CLASS="western">windowName.childWindowName.menuName.commandName</P></LI>
	<LI><P CLASS="western">windowName.childWindowName.menuName.commandName=VALUE</P></LI>
	<LI><P CLASS="western" ALIGN=LEFT>windowName.childWindowName.menuName.commandName arg1=VALUE [arg2=VALUE] ...</P></LI>
</UL>
<P CLASS="western" ALIGN=LEFT">
Commands are directed at a specific window or child-window (popup window).  There can be more than one child-window in the specification,
that is there can be a child-window of a child-window, etc. Also, the child-window can actually be a widget child of a window instead of a
separate popup window. Most commands do not have the menu_name part, but a few do. 
Commands that are directed to the first waveform window do not have a window_name part. Command names are
case insensitive. Some example commands are:</P>
<DL>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
# some commands for the first waveform window
clear                             # clear data from the waveform window
align.time_minus_origin           # align the waveforms
components.z_only                 # display only z-components
select sta=&quot;MLR&quot; chan=&quot;SHZ&quot;       # select a waveform

# set a font in the &quot;Print Options&quot; child-window of the &quot;Print Waveforms&quot; window
print_window.options.axes_labels=&quot;Times&quot;
fk.units = &quot;sec per km&quot;           # set the units in the FK window
fk.parameters.num_slowness = 41   # set a value in the FK Parameters child-window

# set a font in the &quot;Print Options&quot; window of the &quot;Print FK&quot; window
fk.print_window.options.axes_labels=&quot;Times&quot;

# set a font in the &quot;Print Options&quot; window of the &quot;Print FK Signal&quot; window
fk.signal.print_window.options.axes_labels=&quot;Times&quot;

# set the time limits for the waveform plot (plot2) that is at the bottom of the Spectrogram window.
spectrogram.plot2.time_zoom tbeg=1160357793 tend=1160357793+60</PRE>
		</TD>
	</TR>
	</TABLE>
</DL>
<P CLASS="western" ALIGN=LEFT">
Long window names are frequently shortened, for example &quot;print&quot; for &quot;Print Waveforms&quot; and &quot;signal&quot;
for &quot;FK Signal Measurements&quot;. In the example above, note the three different commands to set the axes_label font
in the Print Options window depending on the window that will be printed, the first waveform window, the FK Window, or the
FK Signal Measurements window.</P>
<H2 CLASS="western"><A NAME="Commands to Windows of the Same Type"></A>Commands to Windows of the Same Type</H2>
<P CLASS="western">
Many of geotool's windows have the &quot;New Window&quot; option under the File menu that creates a second window of the same type.
The FK, FK Multi-Band, FT, Spectrogram, etc. windows have this option. The second FK (or FT, etc.) window that is created behaves
the same as the first. It also processes data from the waveform window. The first waveform window itself has a New Window option that
creates a second waveform window, which in term has all of the processing child-windows. The command syntax for these multiple windows
is to append the window or child-window name with a period followed by an integer, as in fk.2.command or ft.2.command. Commands to a
second waveform window start with the window number, 2.clear, 2.open, etc.</P>
<DL>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
fk.2.units = &quot;sec per km&quot;          # set the units in the second FK window
2.select_all_arrivals              # select all arrivals in the second waveform window
3.fk.2.parameters.num_slowness=41  # set the num_slowness for the second FK of the third waveform window</PRE>
		</TD>
	</TR>
	</TABLE>
</DL>
<P CLASS="western">
The script below illustrates the use of a second waveform window to display copies of a waveform filtered with different filter bands.
The script copies a single waveform to the paste buffer. It then pastes the waveform into the second waveform window seven times and
filters each copy with a different filter band.</P>
<DL>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% HEIGHT=282 VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
if( sel_wave.size() == 0 )                  # make sure that there is only one waveform selected
    showWarning &quot;No waveforms selected.&quot;
    return
elseif( sel_wave.size() &gt; 1)
    showWarning &quot;More than one waveform selected.&quot;
    return
endif

copy            # copy the selected waveform in the first waveform window to the paste buffer

set lo = 1.0,1.5,2.0,2.5,3.0,2.0,2.0      # create arrays of low and high frequencies values.
set hi = 3.0,3.5,4.0,4.5,6.0,4.5,6.0

2.clear                                   # clear the second waveform window
2.tag_contents.set tag=&quot;station,channel,filter(low high)&quot;   # display the filter band in the waveform tags

foreach(1, lo.size(), i)                  # loop over all frequency bands
    2.paste                               # paste the waveform that was copied from the first window
    filter 2.wave[i] low=lo[i] high=hi[i] # filter the waveform that was just copied to the second window
endfor

2.open                              # display the second waveform window

foreach(2.arrival, a)               # loop over the second window arrivals and zoom-in to the first 'P' found
    if(a.phase ^= 'P')              # the ^= operator tests if the phase starts with a 'P'
        2.time_zoom tbeg=2.a.time-10. tend=2.a.time+15.  # set the time limits of the second waveform window
        break                       # exit the foreach loop
    endif
endfor</PRE>
		</TD>
	</TR>
	</TABLE>
</DL>
<H2 CLASS="western"><A NAME="Variable Context"></A>Variable Context</H2>
<P CLASS="western">
The syntax for the predefined variables is similar to the syntax for the commands.</P>
<UL>
	<LI><P CLASS="western">windowName.childWindowName.stuctureName.variableName</P>
</UL>
<P CLASS="western">
Most predefined variables belong to a specific window. For example each waveform plot has the predefined variables wave, arrival,
origin, plot_tmin, plot_tmax, etc. (see WaveformView Variables). For the first waveform window, these variable names are not prefixed
with a window name. For example, wave[1], arrival[1], origin[1], etc. A prefix is used to access these variables in other waveform
plots. For a second waveform window the predefined variables are prefixed by “2. , for example, 2.wave[1], 2.arrival[1]. Some variable
names also include structure names in the style of C language structure members, as illustrated in the script below which finds local
maximums greater than 3.0 in the signal-to-noise arrays for four frequency bands. The snr variable array in the FK Multi-band Signal
window has the name fk_multi_band.sig[k].snr[i], where k is the frequency band index and i is the time window index.</P>
<DL>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
alias fkm=fk_multi_band
fkm.2.flo1=3.0;  fkm.2.fhi1=4.0      # Set the frequency bands for the second FK Multi-Band window
fkm.2.flo2=3.5;  fkm.2.fhi2=4.5
fkm.2.flo3=4.0;  fkm.2.fhi3=5.0      # the semi-colon ';' can be used to separate multiple commands
fkm.2.flo4=5.0;  fkm.2.fhi4=6.0      # on the same line
fkm.2.auto_compute                   # Compute FK for a sliding time window
n = fkm.2.sig[1].snr.size() - 2      # This is the number of FK's that were computed minus 2.

print &quot;       time                flo  fhi     snr    az    slow&quot;    # print column labels

foreach(3, n, i)      # loop over the time windows of the signal-to-noise array fk_multi_band.sig[k].snr[i]
    kmax = 0
    snr_max = 0
    foreach(1, 4, k)         # loop of each of the four frequency bands
        alias s=fkm.2.sig     # alias for convenience
        m = s[k].snr[i]
               # compare each snr value to the two values before and after to find a local maximum &gt; 3
        if(m &gt; 3.0 &amp;&amp; m &gt; s[k].snr[i-2] &amp;&amp; m &gt; s[k].snr[i-1] &amp;&amp; m &gt; s[k].snr[i+1] &amp;&amp; m &gt; s[k].snr[i+2])
            if(m &gt; snr_max)            # find the maximum snr of the four frequency bands
                snr_max = m
                kmax = k
                azimuth = s[k].azimuth[i]
                slowness = s[k].slowness[i]
                time = s[k].fk[i].tend - fkm.2.stav_length
                fmin = fkm.2.flo[kmax]
                fmax = fkm.2.fhi[kmax]
            endif
        endif
    endfor
    if(snr_max &gt; 0)
        print time(%t) &quot;  &quot; fmin(%4.1f) fmax(%4.1f) snr_max(%6.2f) azimuth(%7.1f) slowness(%6.2f)
    endif
endfor</PRE>
		</TD>
	</TR>
	</TABLE>
</DL>
<P CLASS="western">
This script generates output like the following lines:</P>
<DL>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
       time                flo  fhi     snr    az    slow
2004Feb12 09:13:05.963     3.5  4.5    8.57   292.7  17.78
2004Feb12 09:13:07.988     3.0  4.0    6.75   289.8  16.19
2004Feb12 09:13:16.088     3.0  4.0    3.26   307.7  14.15
2004Feb12 09:13:24.188     3.0  4.0   15.29   296.5  27.97
2004Feb12 09:13:30.263     3.5  4.5    3.41   330.5  27.77
2004Feb12 09:14:37.088     4.0  5.0    7.63   188.8  13.80
2004Feb12 09:14:39.113     3.0  4.0   14.35   191.6  13.60
2004Feb12 09:14:47.213     3.0  4.0   10.93   188.3  13.19
2004Feb12 09:14:51.263     3.5  4.5   12.17   184.5  14.77
2004Feb12 09:14:53.288     4.0  5.0    6.54   195.8  15.55
2004Feb12 09:14:57.338     5.0  6.0    3.03   173.5  13.99
2004Feb12 09:14:59.363     3.5  4.5    9.19   191.8  15.48
2004Feb12 09:15:07.463     3.0  4.0    3.20   188.0  16.99</PRE>
		</TD>
	</TR>
	</TABLE>
</DL>
</DL>
<H1 CLASS="western"><A NAME="General Commands"></A>3.0 General Commands</H1>
<DL>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0 FRAME=VOID RULES=ROWS>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="alias"></A><B>alias</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>alias</B> [NAME=STRING].</P>
			<P CLASS="western">
			Description: This command is similar to the shell alias command, except that
			it is possible to alias one or more parts of the command string as well
			as all or part of a variable name. The“parts of a string are separated by the
			period '.' character. The aliased string can contain only alphanumeric
			(a-z,A-Z,0-9) characters, the period '.', and the underscore
			'_'. A few examples are:</P>
			<PRE CLASS="western">
alias fk = fk_multi_band
fk.auto_compute                        # equivalent to fk_multi_band.auto_compute
alias ir = instrument_response
ir.open                                # equivalent to instrument_response.open
alias s = tablequery.select_row
s 10                                   # equivalent to tablequery.select_row 10</PRE>
			<P CLASS="western">
			Aliases are applied to the string that is being aliases before the new
			alias is created. For example:</P>
			<PRE CLASS="western">
alias fk = fk_multi_band.2      # the second FK Multi-Band window
alias s = fk.sig                # equivalent to alias s=fk_multi_band.2
azimuth = s[k].azimuth[i]       # equivalent to azimuth=fk_multi_band.2.sig[k].azimuth[i]</PRE>
			<P CLASS="western">
			An alias is local to the foreach block in which it is defined. If it is defined
			outside of all foreach blocks, it is local to the file in which it is defined.</P>
			<P CLASS="western">
			The alias command with no arguments lists all current aliases. For example, the
			following script</P>
			<PRE CLASS="western">
alias a = first_alias
alias b = second_alias
foreach(1, 1, i)
    alias c = third_alias
endfor
alias</PRE>
			<P CLASS="western">produces the output:</P>
			<PRE CLASS="western">
a=first_alias
b=second_alias</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="defined"></A><B>defined</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>defined</B>(VARIABLE_NAME)</P>
			<P CLASS="western">
			Description: This is actually not a command, but a function that returns true if VARIABLE_NAME
			has been defined locally or globally with the set or setb command, or by assignment (a = 1.0).
			It also returns true if VARIABLE_NAME is a predefined variable or a constant. Use the listReserved
			command to list all predefined variables and constants. An example is:</P>
			<PRE CLASS="western">
if( !defined(dir) )
    print &quot;dir is not defined&quot;
    return
endif</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="export"></A><B>export</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>export</B> VARIABLE_NAME</P>
			<P CLASS="western">
			Description: Give a local variable global scope. Variables are initially
			defined only within the file in which they are first assigned a value. The
			export command makes the variable accessible from any file.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="help"></A><B>help</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: [WindowName.]<B>help</B></P>
			<P CLASS="western">
			Description: This command lists (prints to the terminal) all available commands for the waveform window
			or for the window name that is the prefix. Examples:</P>
			<PRE CLASS="western">
help
tableviewer.help
fk_multi_band.help</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="parse"></A><B>parse</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>parse</B> FILE [ {line1; line2; ...} ]</P>
			<P CLASS="western">
			Description: Read and interpret the script in the specified file. If FILE does not begin with
			'/', then it is a relative file-path from the directory in which the program was executed.
			The parse command can be used within a script file to parse another script file. In this case, if the
			FILE does not begin with '/', then it is a relative file-path from the location of the current
			script file (the file that contains the parse command). This default behavior can be changed by
			setting the predefined local variable relative_file_paths to false inside the script file. If
			relative_file_paths is set to false, then all file paths within the current script file that do
			not begin with '/' will be relative to the directory of program execution.</P>
			<P CLASS="western">
			Optional script commands can be included on the parse line inside the braces { }. These commands usually
			set parameters that are referenced in the script file.
			<PRE CLASS="western">
parse &quot;scripts/file1&quot; {a=4.3; set net=&quot;GERES&quot;}</PRE>
			<P CLASS="western">
			Parse can also be used as a command line argument to instruct the program to parse a script file or
			a script string. It can be specified multiple times on the command line. Examples:</P>
			<PRE CLASS="western">
geotool parse=/home/geotool/files/script1
geotool parse=&quot;read file='data/tutorial/DPRK.wfdisc' query=\&quot;select * from wfdisc where sta='FITZ'\&quot;&quot; \
 parse=scripts/filter1</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="parse_string"></A><B>parse_string</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>parse_string</B> string</P>
			<P CLASS="western">
			Description: Evaluate the string and parse it as a command. For example:</P>
			<PRE CLASS="western">
if( defined(window) )
    set cmd = window &quot;.compute&quot;
    parse_string cmd
endif</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="print"></A><B>print</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>print</B> VARIABLE[(FORMAT)] ...</P>
			<P CLASS="western">
			Description: Print VARIABLE(s) according to the FORMAT(s). The VARIABLE can be
			an assigned variable, a constant, or a string. The FORMAT is an optional C
			language printf style format specifier, supplemented by six formats for
			printing epoch time. The optional format specifier is enclosed in parentheses
			immediately following the variable name. Examples:</P>
			<PRE CLASS="western">
print a.sta(%-8s) a.chan(%-8s) a.phase(%-8s) o.orid s.arid
print &quot;azimuth =&quot; fk_multi_band.table.cell[1][5]  &quot; slowness =&quot; fk_multi_band.table.cell[1][4]
print wave[3].tbeg(%t)
print wave[2].seg[1].data[100]
print &quot;number of waveforms = &quot; wave.size()
print sin(37.*degrees_to_radians)(%.2f)</PRE>
			<P CLASS="western">
			Date/Time Formats:</P>
			<UL>
			<LI><P CLASS="western">%t = YYYYMONDD HH:MM:SS.SSS</P>
			<LI><P CLASS="western">%2t = YYYYMONDD HH:MM:SS</P>
			<LI><P CLASS="western">%3t = YYYY/MM/DD HH:MM:SS.S</P>
			<LI><P CLASS="western">%4t = YYYY/MM/DD HH:MM:SS.SSS</P>
			<LI><P CLASS="western">%5t = YYYYMONDD</P>
			</UL>
			<P CLASS="western">
			When VARIABLE is an object, such as wave[1], wave[1].seg[1], arrival[3], etc., all of the object's members
			will be printed in the form 'member_name=value' on separate lines.</P>
			<PRE CLASS="western">
print wave[2]</PRE>
<P CLASS="western">produces</P>
			<PRE CLASS="western">
sta=FITZ
chan=BHZ
net=FITZ
lat=-18.0983
lon=125.6403
elev=0.129
deast=0
dnorth=0
hang=-1
vang=0
tbeg=1160358270.012
tend=1160358570.012
duration=300
nsegs=1
length=12001
samprate=40
begSelect=0
endSelect=0
calib=0.017000000923872
calper=1
chanid=-1
clip=
station_alpha=0
station_beta=0
station_gamma=0
current_alpha=0
current_beta=0
current_gamma=0
dataMax=72.998
dataMaxIndex=7510
dataMaxSegment=1
dataMin=-77.96201
dataMinIndex=7623
dataMinSegment=1
datatype=
index=2
instype=CMG-3T
jdate=2006282
mean=-0.00596225066561369
num_dp=0
num_dw=0
refsta=FITZ
segtype=
xchan=BHE
ychan=BHN
zchan=BHZ
xpos=1160358270.012
ypos=2
</PRE>
<P CLASS="western">Printing a waveform segment with the command</P>
			<PRE CLASS="western">
print wave[2].seg[1]</PRE>
<P CLASS="western">produces</P>
			<PRE CLASS="western">
calib=0.261000007390976
calper=1
initial_calib=0.261000007390976
initial_calper=1
length=42002
samprate=120
tbeg=1076577138.71667
tend=1076577488.725</PRE>
			<P CLASS="western">
			Mathematical expressions as print arguments must be enclosed
			within parentheses. For example:</P>
			<PRE CLASS="western">
print &quot;value = &quot; (2. + sin(arrival[1].azimuth*degrees_to_radians)/4.)</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="printf"></A><B>printf</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>printf</B> VARIABLE[(FORMAT)] ...</P>
			<P CLASS="western">
			Description: The same as the print command, except that no spaces are
automatically inserted between arguments. For example:</P>
			<PRE CLASS="western">
printf wave[2].sta "/" wave[2].chan "1234"</PRE>
<P CLASS="western">produces</P>
			<PRE CLASS="western">
FITZ/BHZ1234
</PRE>
<P CLASS="western">while</P>
			<PRE CLASS="western">
print wave[2].sta "/" wave[2].chan "1234"</PRE>
<P CLASS="western">produces</P>
			<PRE CLASS="western">
FITZ / BHZ 1234
</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="printClose"></A><B>printClose</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>printClose</B></P>
			<P CLASS="western">
			Description: Discontinue writing output from the print command to the file opened
			with the printOpen command. Subsequent print output will go to the terminal.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="printOpen"></A><B>printOpen</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>printOpen</B> file=FILE [append=(true,false)]</P>
			<P CLASS="western">
			Description: Redirect all output from the print command to FILE. If the optional
			append argument is not specified, the FILE will be overwritten. All output form
			the print command will be written to FILE until the printClose command is used.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="set"></A><B>set</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>set</B> NAME=STRING</P>
			<P CLASS="western">
			Description: Set a string variable. The character set for NAME is all
			alphanumeric characters plus the underscore character (a-z,A-Z,0-9,'_'). The
			STRING can be one or more quoted strings using any of the three types of quote
			characters (“,',`). For example:</P>
			<PRE CLASS="western">
set sta = &quot;VRAC&quot;
set chan= 'BHZ'</PRE>
			<P CLASS="western">
			The STRING can also be a variable or a constant. If the variable is not a string,
			it will be enclosed in quotes. The following script</P>
			<PRE CLASS="western">
set a = 5.72
set b = wave[1].sta
set c = pi
print a b c</PRE>
			<P CLASS="western">
			produces the output:</P>
			<PRE CLASS="western">
&quot;5.72&quot; &quot;GERES&quot; &quot;3.141592653589793&quot;</PRE>
			<P CLASS="western">
			The STRING can also be a concatenation of two or more strings or
			variables. The following script</P>
			<PRE CLASS="western">
set dir = &quot;/data/tutorial&quot;
set file = dir  &quot;/TURKEY.wfdisc&quot;
print &quot;file=&quot; file
set sta = &quot;GEA0&quot;
set chan = &quot;SHZ&quot;
set label = sta  '/'  chan
print label
set beam_label = wave[1].net  &quot;/beam&quot; 2.wave.size()
print beam_label</PRE>
			<P CLASS="western">produces the output:</P>
			<PRE CLASS="western">
file= &quot;/data/tutorial/TURKEY.wfdisc&quot;
&quot;GEA0/SHZ&quot;
&quot;GERES/beam5&quot;</PRE>
			<P CLASS="western">
			If commas are found in the STRING, they will also be concatenated
			into the result. The following script</P>
			<PRE CLASS="western">
set flo = 1.0,1.5,2.0,2.5,3.0,4.0
set phases = 'P','Pn','Pg'
print &quot;flo=&quot; flo
print &quot;phases=&quot; phases</PRE>
			<P CLASS="western">
			produces the output:</P>
			<PRE CLASS="western">
flo= &quot;1.0,1.5,2.0,2.5,3.0,4.0&quot;
phases= &quot;P,Pn,Pg&quot;</PRE>
			<P CLASS="western">
			Strings with commas can be used as arrays. Any string name can be followed by a
			bracketed index and the “.size()” element count syntax. Assuming flo and phases
			are defined as shown above, the following script</P>
			<PRE CLASS="western">
print flo[3] flo[5] phases[3]
n = flo.size()
print &quot;n=&quot; n</PRE>
			<P CLASS="western">
			produces the output:</P>
			<PRE CLASS="western">
2.0 3.0 Pg
n= 6</PRE>
			<P CLASS="western">
			See the section on arrays for more examples of using strings as arrays.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="setb"></A><B>setb</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>setb</B> NAME=BOOLEAN_EXPRESSION</P>
			<P CLASS="western">
			Description: Set a boolean variable. The character set for NAME is the same
			as for string variables (a-z,A-Z,0-9,'_'). The BOOLEAN_EXPRESSION is an expression
			that evaluates to boolean or to a numerical value. A numerical value is evaluated as true
			if it is non-zero and false if it is zero. The C language logical operators
			(&gt;, &gt;=, &lt;, &lt;=, ==, !=, &amp;&amp;, ||, !) are recognized. These operators
			work with strings as well as numerical values (string1 == string2, string2 != string2). Two
			additional operators for comparing strings are ~= and ^=. The operator ~= does a
			case-insensitive comparison (a ~= b : !strcasecmp(a,b)). The operator ^= does
			case-insensitive and length-insensitive comparison (a ^= b : !strncasecmp(a, b,
			strlen(a) &lt; strlen(b) ? strlen(a) : strlen(b)) ).</P>
			<PRE CLASS="western">
setb a = (snr &gt; 3.0 &amp;&amp; a.phase == 'P')
setb b = (10. &lt; distance &amp;&amp; distance &lt; 30. &amp;&amp; (phase == 'P' || phase == 'S'))
setb have_waveforms = wave.size()</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="sprint"></A><B>sprint</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>sprint</B> NAME VARIABLE[(FORMAT)]</P>
			<P CLASS="western">
			Description: Print to a string. The functionality is the same as the print
			command, but the output is stored as the string NAME. For example,</P>
			<PRE CLASS="western">
sprint label azimuth(%.1f) slowness(%.1f)
tag_contents.set tag=&quot;station,channel,text input&quot;, text=label</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="sprintf"></A><B>sprintf</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>sprintf</B> NAME VARIABLE[(FORMAT)]</P>
			<P CLASS="western">
			Description: The same as sprint, except that no spaces are automatically
inserted between arguments.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="system"></A><B>system</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>system</B> STRING</P>
			<P CLASS="western">
			Description: Execute a unix shell command. For example:</P>
			<PRE CLASS="western">
set cmd = "cp ASAR.arrival tmp.arrival"
system cmd</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="unalias"></A><B>unalias</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>unalias</B> NAME</P>
			<P CLASS="western">
			Description: Unset or remove the alias NAME.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="unset"></A><B>unset</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>unset</B> NAME</P>
			<P CLASS="western">
			Description: Remove the variable NAME. This makes NAME undefined. NAME can
			be a string variable created with the set command or a boolean
			variable created with the setb command or a numerical variable
			created by assignment (a = 3.4, etc).</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="wait"></A><B>wait</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>wait</B> MSECS</P>
			<P CLASS="western">
			Description: Pause the parsing for MSECS milliseconds.
The following script prints the name of each unique instrument response and
displays the amplitude response for 2 seconds.</P>
			<PRE CLASS="western">
alias ir=instrument_response
ir.open
set last = ""
num = ir.all_instruments.num_rows
foreach(1,num,i)
    set s = ir.all_instruments.cell[i][2]
    if(last != s)
        ir.all_instruments.deselect_all
        ir.all_instruments.select_row i
        set last = s
        print i last
        wait 2000
    endif
endfor</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="writeArray"></A><B>writeArray</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>writeArray(</B> ARRAY <B>)</B> or <B>writeArray(</B> ARRAY, START, NUM <B>)</B></P>
			<P CLASS="western">Returns: the number of elements written.</P>
			<P CLASS="western">
			Description: Write an array as a binary byte stream to a file. All arrays are predefined variables. The predefined
			variable type can be double, float, or int. The single-argument version writes all elements of the array. The three-argument
			version writes a subset of the array from index START to index START+NUM-1. The index of the first element is 1.  For example:</P>
<PRE CLASS="western">
writeInt(100)      # write an integer
writeArray( wave[2].seg[1].data, 200, 100 )  # write samples 200 to 299 as binary floats

writeInt(fkm.sig[i].snr.size())

# all of the write commands return the number of elements written
n = writeArray(fkm.sig[1].snr)   # write the snr array

writeFloat(34.67)  # write a single float
</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="writeClose"></A><B>writeClose</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>writeClose</B></P>
			<P CLASS="western">
			Description: Close a file that was opened by the writeOpen command.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="writeDouble"></A><B>writeDouble</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>writeDouble(</B> NAME <B>)</B></P>
			<P CLASS="western">Returns: 1 for success, 0 if an error occurs.</P>
			<P CLASS="western">
			Description: Write a binary double value to the file opened with writeOpen.
			NAME can be a variable name or a constant.</P>
<PRE CLASS="western">
writeDouble(wave[1].tbeg)
writeDouble(5.729)
</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="writeInt"></A><B>writeInt</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>writeInt(</B> NAME <B>)</B></P>
			<P CLASS="western">Returns: 1 for success, 0 if an error occurs.</P>
			<P CLASS="western">
			Description: Write a binary int value to the file opened with writeOpen.
			NAME can be a variable name or a constant.</P>
<PRE CLASS="western">
writeInt(fkm.fk[i].num_slowness)
n = 3052
writeInt(n)
</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="writeFloat"></A><B>writeFloat</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>writeFloat(</B> NAME <B>)</B></P>
			<P CLASS="western">Returns: 1 for success, 0 if an error occurs.</P>
			<P CLASS="western">
			Description: Write a binary float value to the file opened with writeOpen.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="writeLong"></A><B>writeLong</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>writeLong(</B> NAME <B>)</B></P>
			<P CLASS="western">Returns: 1 for success, 0 if an error occurs.</P>
			<P CLASS="western">
			Description: Write a binary long value to the file opened with writeOpen.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="writeOpen"></A><B>writeOpen</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>writeOpen</B> file=FILE [append=(true,false)]</P>
			<P CLASS="western">
			Description: Open a file for binary output. If append is false, an existing file
			will be overwritten. The default is append=false.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="writeString"></A><B>writeString</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>writeString(</B> NAME <B>)</B></P>
			<P CLASS="western">Returns: the number of characters written.</P>
			<P CLASS="western">
			Description: Write a string of bytes to the file opened with writeOpen.</P>
		</TD>
	</TR>
	</TABLE>
</DL>
<H1 CLASS="western"><A NAME="Special Characters"></A> 4.0 Special Characters</H1>
<DL>
	<P CLASS="western"><A NAME="Logical operators"></A>Logical operators</P>
    <DL>
	<TABLE WIDTH=90% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western">==</P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Logical equals for numerical and string variables</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western">!=</P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Logical not equals for numerical and string variables</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western">&gt;</P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Greater than for numerical and string variables</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western">&lt;</P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Less than for numerical and string variables</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western">&gt;=</P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Greater than or equal to for numerical and string variables</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western">&lt;=</P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Less than or equal to for numerical and string variables</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western">~=</P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Case insensitive comparison for string variables</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western">^=</P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Case insensitive and length insensitive comparison for string variables</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western">&amp;&amp;</P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Logical and</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western">||</P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Logical or</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western">!</P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Logical not</P>
		</TD>
	</TR>
	</TABLE>
    </DL>

	<P CLASS="western"><A NAME="Parsing control"></A>Parsing control</P>

    <DL>
	<TABLE WIDTH=90% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western">“ “</P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Quotes to enclose strings</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western">' '</P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Quotes to enclose strings</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western">` `</P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Quotes to enclose strings</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western">#</P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Comment indicator. Everything on the line after # is ignored.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western">;</P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">End-of-line indicator. Use ';' to separate multiple commands on the same line.
					For example:</P>
			<PRE CLASS="western">
if(2 &gt; 1); print &quot;2 &gt; 1&quot;; endif</PRE>
			<P CLASS="western">is the same as</P>
			<PRE CLASS="western">
if(2 &gt; 1)
print &quot;2 &gt; 1&quot;
endif<PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western">\</P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Line continuation. Put \ at the end of a
			line to continue the command to the next line</P>
			<PRE CLASS="western">
print &quot;This is \
an con\
tinued line&quot;</PRE>
			<P CLASS="western">
			is the same as</P>
			<PRE CLASS="western">
print &quot;This is a continued line&quot;</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western">{ }</P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">
			Text input. Preserves the end-of-lines and does not parse the enclosed text. For example,
			to specify a callback script that will be interpreted only at the time of the callback:</P>
			<PRE CLASS="western">
Option.create name=&quot;F24&quot; type=&quot;button&quot;
Option.F24.activateCallback={
    foreach(sel_wave, w)      # Loop over all selected waveforms
        filter w low=2. high=4. order=3 type=&quot;BP&quot; # Filter each selected waveform
    endfor
}</PRE>
			<P CLASS="western">
			The following command displays text in a popup window with the end-of-lines preserved:</P>
			<PRE CLASS="western">
showMessage {
this is a
multi-line
message
}</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western">[ ]</P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Array index indicator. The first element of an array has index = 1. Examples:</P>
			<PRE CLASS="western">
print wave[2].sta arrival[4].phase
print fk_multi_band.sig[2].snr[55]</PRE>
			<P CLASS="western">Brackets and expressions inside of brackets are allowed.:</P>
			<PRE CLASS="western">
set a = 1, 2, 3, 4, 5
set b = 3.4, 2.6, 9.1, 7.2
c = b[a[2]+1]
print &quot;c =&quot; c</PRE>
			<P CLASS="western">produces:</P>
			<PRE CLASS="western">
c = 9.1</PRE>
		</TD>
	</TR>
	</TABLE>
    </DL>

	<P CLASS="western"><A NAME="Arithmetic operators"></A>Arithmetic operators</P>

    <DL>
	<TABLE WIDTH=90% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western">( ) +  -  *  /</P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Parentheses inside of parentheses are allowed. The order of
			evaluation precedence is (), +,- as positive and negative signs, *,/ multiplication
			and division, and finally +,- addition and subtraction.</P>
			<PRE CLASS="western">
# the following assignment can be interpreted, if b,c,g,h, and d are defined
a = ((1.43 + b*(c-3.0/g) - 4.63)*h - 1.45e-05)/d</PRE>
		</TD>
	</TR>
	</TABLE>
    </DL>

</DL>
<H1 CLASS="western"><A NAME="Control Flow"></A>5.0 Control Flow</H1>
<DL>
<P CLASS="western">
Conditional blocks using 'if', 'elseif', 'else', and 'endif' statements and loops using 'foreach', 'break', and 'endfor' statements are supported.
</P>
<H2 CLASS="western"><A NAME="Conditional Blocks"></A>Conditional Blocks (if, elseif, else, endif)</H2>
<P CLASS="western">
The conditional block structure is:</P>
<DL>
<PRE CLASS="western">
if( CONDITION )
    ...
elseif( CONDITION2 )
    ...
elseif( CONDITION3 )
    ...
else
    ...
endif</PRE>
</DL>
<P CLASS="western">
There can be one or more 'elseif' statements, or none at all. The 'else' statement is also optional. The arguments CONDITION, CONDITION2, etc.
can be numerical variables, one of the four strings (case-insensitive) &quot;true&quot;, &quot;false&quot;,
&quot;1&quot;, &quot;0&quot;, boolean variables, or boolean expressions.
A numerical variable as an 'if' or 'elseif' argument is evaluated as true, if it is non-zero and false, if it is zero. The C language
style <A HREF="#Logical operators">logical operators</A> are supported as well as two additional operators ~= and ^= for string comparisons. Also,
all of the C language operators ==, !=, &gt;, &lt;, &gt;=, &lt;= work with numerical arguments and string arguments.</P>
<DL>
<PRE CLASS="western">
string1 == string2   # a case sensitive string equal-to comparison        ( !strcmp(string1, string2) )
string1 != string2   # a case sensitive string not-equal-to comparison    (  strcmp(string1, string2) )
string1 ~= string2   # a case insensitive string equal-to comparison      ( !strcasecmp(string1, string2) )
string1 &gt; string2    # (strcmp(string1, string2) &gt; 0)
string1 &gt;= string2    # (strcmp(string1, string2) &gt;= 0)
string1 &lt; string2    # (strcmp(string1, string2) &lt; 0)
string1 &lt;= string2    # (strcmp(string1, string2) &lt;= 0)

# The following string comparison is insensitive to differences in case and string length. The
# characters of each string are compared up to the shorter length.

string1 ^= string2

# In C, this is equivalent to
# !strncasecmp(string1, string2, strlen(string1)&lt;strlen(string2) ? strlen(string1):strlen(string2));
</PRE>
</DL>
<P CLASS="western">
The following 'if' statements illustrate different types of valid arguments:</P>
<DL>
<PRE CLASS="western">
if( w.net == 'GERES')

if(o.orid == s.orid &amp;&amp; s.arid == a.arid)

if(w.net=='GERES' &amp;&amp; w.chan ^= 'S')

if(w.sta==r.sta &amp;&amp; w.chan==r.chan)

if( !sel_wave.size() )

if(s.orid == o.orid &amp;&amp; (s.phase == 'Pn' || s.phase == 'P'))

if(m &gt; 3.0 &amp;&amp; m &gt; s[k].snr[i-2] &amp;&amp; m &gt; s[k].snr[i-1] &amp;&amp; m &gt; s[k].snr[i+1] &amp;&amp; m &gt; s[k].snr[i+2])

if( k &lt;= 4 )

if( instrument_response.responses.num_selected_rows &gt; 0 )
</PRE>
</DL>

<H2 CLASS="western"><A NAME="Loops"></A>Loops (foreach, break, endfor)</H2>
<P CLASS="western">The foreach structure is:</P>
<DL>
<PRE CLASS="western">
foreach(...)
    ...
endfor
</PRE>
</DL>
<P CLASS="western">
The foreach statement can have one, two, or three arguments.</P>
<P CLASS="western"><A NAME="foreach(a)"></A><B>foreach(a)</B></P>
<P CLASS="western">
The single-argument foreach takes a string array as the argument. The loop is automatically executed for each element of the array.
Within the loop, the array name successively takes the value of each element. For example, the following script</P>
<DL>
<PRE CLASS="western">
set a=1.0,1.5,2.0,3.5,6.0,7.0

foreach(a)
    print &quot;a=&quot; a
endfor
</PRE>
</DL>
<P CLASS="western">produces the output:</P>
<DL>
<PRE CLASS="western">
a= 1.0
a= 1.5
a= 2.0
a= 3.5
a= 6.0
a= 7.0
</PRE>
</DL>
<P CLASS="western">Another example is</P>
<DL>
<PRE CLASS="western">
set s=&quot;P,Pn,Pg,S,Sg&quot;

foreach(s)
    print &quot;s=&quot; s
endfor
</PRE>
</DL>
<P CLASS="western">which produces the output:</P>
<DL>
<PRE CLASS="western">
s= P
s= Pn
s= Pg
s= S
s= Sg
</PRE>
</DL>
<P CLASS="western"><A NAME="foreach(wave, w)"><B>foreach(wave, w)</B></P>
<P CLASS="western">
The first argument of the two-argument version of the foreach statement, not including the prefix, must be one of the following:</P>
<DL>
	<TABLE WIDTH=90% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western"><B>Argument Name</B></P> </TD>
		<TD WIDTH=80%> <P CLASS="western"><B>foreach Action</B></P> </TD>
	</TR> <TR VALIGN=TOP>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">wave</P> </TD>
		<TD WIDTH=80%> <P CLASS="western">loop over all waveforms</P> </TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">sel_wave</P> </TD>
		<TD WIDTH=80%> <P CLASS="western">loop over all selected waveforms</P> </TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">row</P> </TD>
		<TD WIDTH=80%> <P CLASS="western">loop over all rows of a table</P> </TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">sel_row</P> </TD>
		<TD WIDTH=80%> <P CLASS="western">loop over all selected rows of a table</P> </TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">column</P> </TD>
		<TD WIDTH=80%> <P CLASS="western">loop over all columns of a table</P> </TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">sel_column</P> </TD>
		<TD WIDTH=80%> <P CLASS="western">loop over all selected columns of a table</P> </TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">arrival</P> </TD>
		<TD WIDTH=80%> <P CLASS="western">loop over all arrivals</P> </TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">sel_arrival</P> </TD>
		<TD WIDTH=80%> <P CLASS="western">loop over all selected arrivals</P> </TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">origin</P> </TD>
		<TD WIDTH=80%> <P CLASS="western">loop over all origins</P> </TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">sel_origin</P> </TD>
		<TD WIDTH=80%> <P CLASS="western">loop over all selected origins</P> </TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">NAME</P> </TD>
		<TD WIDTH=80%> <P CLASS="western">loop over all records of type NAME (affiliation,ampdescript,amplitude,
			arrival,assoc,...,instrument,netmag,origaux,origerr,origin,...)</P> </TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">SEL_NAME</P> </TD>
		<TD WIDTH=80%> <P CLASS="western">loop over all selected records of type NAME (affiliation,ampdescript,amplitude,
			arrival,assoc,...,instrument,netmag,origaux,origerr,origin,...)</P> </TD>
	</TR>
	</TABLE>
</DL>
<P CLASS="western">
The second argument of the two-argument version of the foreach statement is the name that will be used within the
loop to represent the current element of the array of objects. Some examples are:</P>
<DL>
<PRE CLASS="western">
foreach(wave, w)	# loop over all waveforms in the first waveform window
    print w.sta w.chan w.time(%t) w.samprate
endfor

foreach( 2.sel_wave, w )    # loop over all selected waveforms in the second waveform window
    filter w low=2.0 high=4.0
endfor

foreach( origin, o )       # loop over all origin objects in the first waveform window
    if( o.mb &gt; 3.0 )
        foreach( assoc, s )       # loop over all assoc objects in the waveform window
            if( s.orid == o.orid &amp;&amp; (s.phase == 'Pn' || s.phase == 'P') )
                foreach( arrival, a )       # loop over all arrival objects in the waveform window
                    if( a.arid == s.arid )
                        select a            # select the arrival in the waveform window
                    endif
                endfor
            endif
        endfor
    endif
endfor

foreach( tableviewer.wfdisc, w )        # loop over all wfdisc records in the TableViewer window
    if(w.sta ^= 'EK' &amp;&amp; w.chan ^= 's')
	print w.time(%t) w.sta w.chan w.nsamp
    endif
endfor

foreach( correlation.table.row, r )	# loop over all rows of the Correlation table
    if( r.time_lag &lt; 10.0 )
        print r.max_pos_coef r.time_lag
    endif
endfor </PRE>
</DL>

<P CLASS="western"><A NAME="foreach(beg, end, index)"><B>foreach(beg, end, index)</B></P>
<P CLASS="western">
The three-argument version of the foreach statement executes the loop end-beg+1 times, where beg and end
are integers or integer variables. The index variable assumes the values from beg to and including end. This version
of the foreach statement is equivalent to the C language statement 'for(index = beg; index &lt;= end; index++)'.
Some examples are:</P>
<DL>
<PRE CLASS="western">
# print the data values of waveform[4] for a 10 second time window starting at arrival[1].time
t = arrival[1].time
j = wave[4].nearestSegment(t)
beg = wave[4].nearestIndex(t)
end = wave[4].nearestIndex(t+10.)
foreach(beg, end, i)
    print wave[4].seg[j].data[i]
endfor

# print the FK matrix values 100 to 110 for the second frequency band and the 10'th time window
foreach(100, 110, i)
    print fk_multi_band.sig[2].fk[10].matrix[i]
endfor

# loop over the elements of an array
set lo = 1.0,1.5,2.0,2.5,3.0,2.0,2.0
set hi = 3.0,3.5,4.0,4.5,6.0,4.5,6.0
foreach(1, lo.size(), i)
    mid = (lo[i] + hi[i])/2.
    print "mid =" mid
endfor

# loop over waveforms 5 through 10
foreach(5, 10, i)
    filter wave[i] low=2.0 high=4.0
endfor</PRE>
</DL>
<P CLASS="western"><A NAME="break"><B>break</B></P>
<P CLASS="western">
The break statement inside of a foreach loop causes the interpreter to jump to the first statement after the loop.</P>
<DL>
<PRE CLASS="western">
# search the instrument table 
unset row
foreach(instrument_response.all_instruments.row, r)
    if(r.instype ~= &quot;KS5400&quot; &amp;&amp; r.samprate == 40.0)
	set row = r
	break
    endif
endfor

if( defined(row) )
    print row
endif</PRE>
</DL>
<P CLASS="western"><A NAME="for_index"><B>for_index</B></P>
<P CLASS="western">
The reserved variable for_index holds the current loop index. For example, the following script</P>
<DL>
<PRE CLASS="western">
s = &quot;a,b,c,d&quot;
foreach(s)
    print for_index s
endfor

print &quot;&quot;     # a blank line

foreach(wave, w)
    print for_index w.sta w.chan
endfor
</PRE>
</DL>
<P CLASS="western">produces the output like</P>
<DL>
<PRE CLASS="western">
1 a
2 b
3 c
4 d

1 GERES ib
2 DAVOX HHE
3 DAVOX HHN
4 DAVOX HHZ
5 VRAC BHE
6 VRAC BHN
7 VRAC BHZ
8 GEA0 SHZ
9 GEA1 SHZ
10 GEA2 SHE
11 GEA2 SHN
12 GEA2 SHZ
13 GEA3 SHZ
14 GEB1 SHZ
15 GEB2 SHZ
...
</PRE>
</DL>
<P CLASS="western"><A NAME="wave.find_indices"><B>wave.find_indices</B></P>
<P CLASS="western">
Often the purpose of a loop is to find objects whose members have specific values. For example,
the loop below looks for waveform objects whose sta, chan and jdate have specific values.</P>
<PRE CLASS="western">
foreach(wave, w)
    if(w.sta ~= &quot;LPAZ&quot; &amp;&amp; w.chan ~= &quot;BHZ&quot; &amp;&amp; w.jdate == 2006282)
        print w.sta w.chan w.duration
    endif
endfor
</PRE>
<P CLASS="western">
Another way to accomplish this type of search, that will execute much faster when there are
many waveforms, is to use the find_indices function. It returns an array of indices for the
waveform objects whose members match the search arguments.
</P>
<DL>
	<TABLE WIDTH=90% BORDER=2 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0 FRAME=VOID RULES=ROWS>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><B>wave.find_indices</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>wave.find_indices</B>( member1, value1, [member2, value2], ... ) </P>
			<P CLASS="western">
			Description: Returns a string array of indices of the waveforms for which member1 has value1, and
			member2 has value2, etc. Returns an empty string &quot;&quot;, if no waveforms match. All member and value arguments are strings
			or string variables. Value comparisons are
			case insensitive. Use the <A HREF="#set">set</A> command to assign this function to a variable:</P>
			<PRE CLASS="western">
set i = wave.find_indices(&quot;sta&quot;, &quot;LPAZ&quot;, &quot;chan&quot;, &quot;BHZ&quot;, &quot;jdate&quot;, &quot;2006282&quot;)</PRE>
		</TD>
	</TR>
	</TABLE>
</DL>
<P CLASS="western">
Using the find_indices function, an equivalent loop can be written as:</P>
<PRE CLASS="western">
set i = wave.find_indices(&quot;sta&quot;, &quot;LPAZ&quot;, &quot;chan&quot;, &quot;BHZ&quot;, &quot;jdate&quot;, &quot;2006282&quot;)
foreach(i)
    print wave[i].sta wave[i].chan wave[i].duration
endfor
</PRE>

<P CLASS="western"><A NAME="table.find_indices"><B>table.find_indices</B></P>
<P CLASS="western">
The equivalent function is available for searching an array of table objects or searching the rows of a Table component.
</P>
<DL>
	<TABLE WIDTH=90% BORDER=2 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0 FRAME=VOID RULES=ROWS>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><B>TABLE.find_indices</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>TABLE.find_indices</B>( member1, value1, [member2, value2], ... ) </P>
			<P CLASS="western">
			Description: Returns a string array of indices of the TABLE objects or TABLE rows for which member1
			has value1, and member2 has value2, etc. Returns an empty string &quot;&quot;, if no objects or rows match. TABLE is either the
			name of a table (arrival, assoc, origin, wfdisc, etc.),
			or the name of a Table component. In the latter case, the member names are the column labels.
			All member and value arguments are strings or string variables. Value comparisons are
			case insensitive. Use the <A HREF="#set">set</A> command to assign this function to a variable:</P>
			<PRE CLASS="western">
set i = arrival.find_indices(&quot;sta&quot;, &quot;ARCES&quot;, &quot;iphase&quot;, &quot;Pn&quot;)

set i = detection_beams.table.find_indices(&quot;net&quot;, &quot;TXAR&quot;, &quot;name&quot;, &quot;TX_2067&quot;)</PRE>
		</TD>
	</TR>
	</TABLE>
</DL>
<P CLASS="western">
For example, the following script finds the detection beam in the Detection Beams window that was used to
detect a each arrival and prints the filter band limits.</P>
<PRE CLASS="western">
foreach(arrival, a)
    # the detector sets the arrival.chan to the detection beam name
    set i = detection_beams.table.find_indices(&quot;name&quot;, a.chan)
    if(i.size() &gt; 0)
	j = i[1]
	alias r = detection_beams.table.row
	print a.sta(%-6s) a.iphase(%-6s) r[j].flo(%4.1f) r[j].fhi(%4.1f)
    endif
endfor
</PRE>
<H2 CLASS="western"><A NAME="Parsing Files"></A>Parsing Files (parse, return, relative_file_paths)</H2>
<P CLASS="western">
The <A HREF="#parse">parse</A> command reads and interprets the script lines in a file. Variables that are
created in the file with the set command, the setb command, or by assignment are local to the file. They will not
remain defined after the file is interpreted. Also, variables (excluding global variables) that are defined before
the file is read will not be defined while the file is being interpreted. In this respect, a script file is like
a subroutine. Variables can be passed to the script file, if they are created inside the braces '{}' on the parse
command line.</P>
<DL>
<PRE CLASS="western">
parse file=scripts/file1 { azimuth=35.21; set sta='MLR' }
</PRE>
</DL>
<P CLASS="western">
Variables can be 'returned' from a script file by using the <A HREF="#export">export</A> command in the file.</P>
<P CLASS="western"><A NAME="break"><B>return</B></P>
<P CLASS="western">
The return statement in a script file will cause the interpreter to stop reading the file and continue with the
next line after the parse command.</P>
<P CLASS="western"><A NAME="break"><B>relative_file_paths</B></P>
<P CLASS="western">
The local variable relative_file_paths defaults to true when a script file is interpreted. This means that all
file paths in the file that do not start with '/' will be relative to the directory that contains the script
file that is being interpreted. If the relative_file_paths variable is set to false, the file paths
will be relative the directory in which the program was executed.</P>

</DL>
<H1 CLASS="western"><A NAME="Variables"></A>6.0 Variables</H1>
<DL>
<P CLASS="western"><A NAME="Variable Assignment"><B>Variable Assignment</B></P>
<P CLASS="western">
Variables are not declared before they are assigned a value. Before a variable is assigned a value, it is undefined;
the <A HREF="#defined">defined</A>(variable) function returns false. Internally, all variables are stored as character strings.
A variable created by the <A HREF="#set">set</A> command is a character string enclosed in quotes. The setb command
creates one of the character strings &quot;true&quot; or &quot;false&quot;. Variables created by assignment are unquoted character strings.
Variables created by assignment of a float precision number are 7-digit precision strings. Variables created by assignment
of a double precision number are 15-digit precision strings.</P>
<P CLASS="western">
Waveform values are stored internally by geotool as float precision numbers. Table members are stored as long and
double precision numbers. Geotool stores processing results as int, long, float and double precision numbers.
An internal float is converted to a script string with the sprintf format &quot;.7g&quot;. An internal double is converted
to a script string with the sprintf format &quot;.15g&quot;.</P>
<DL>
	<TABLE WIDTH=90% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western"><B>variable assignment</B></P></TD>
		<TD WIDTH=70%> <P CLASS="western"><B>C equivalent assignment</B></P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">set sta=&quot;VRAC&quot;</P></TD>
		<TD WIDTH=70%> <P CLASS="western">char &lowast;sta = &quot;\&quot;VRAC\&quot;&quot;</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">set chan='bhz'</P></TD>
		<TD WIDTH=70%> <P CLASS="western">char &lowast;chan = &quot;\&quot;bhz\&quot;&quot;</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">set label=sta '/' chan</P></TD>
		<TD WIDTH=70%> <P CLASS="western">char &lowast;label = &quot;\&quot;VRAC/bhz\&quot;&quot;</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">set s=1.4</P></TD>
		<TD WIDTH=70%> <P CLASS="western">char &lowast;s = &quot;1.4&quot;</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">set s= 1.2, 4.5,7.0 , 3.2</P></TD>
		<TD WIDTH=70%> <P CLASS="western">char &lowast;s = &quot;1.2,4.5,7.0,3.2&quot;</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">setb b= true</P></TD>
		<TD WIDTH=70%> <P CLASS="western">char &lowast;b = &quot;true&quot;</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">setb b= false</P></TD>
		<TD WIDTH=70%> <P CLASS="western">char &lowast;b = &quot;false&quot;</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">setb b= (5 &gt; 1)</P></TD>
		<TD WIDTH=70%> <P CLASS="western">char &lowast;b = &quot;true&quot;</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">setb b= 0</P></TD>
		<TD WIDTH=70%> <P CLASS="western">char &lowast;b = &quot;false&quot;</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">setb b= 75.4</P></TD>
		<TD WIDTH=70%> <P CLASS="western">char &lowast;b = &quot;true&quot;</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">setb b= &quot;75.4&quot;</P></TD>
		<TD WIDTH=70%> <P CLASS="western">invalid assignment</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">setb b= &quot;sz&quot;</P></TD>
		<TD WIDTH=70%> <P CLASS="western">invalid assignment</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">a = 4.987</P></TD>
		<TD WIDTH=70%> <P CLASS="western">char &lowast;a = &quot;4.987&quot;</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">a = &quot;4.987&quot;</P></TD>
		<TD WIDTH=70%> <P CLASS="western">char &lowast;a = &quot;4.987&quot;</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">a = &quot;se&quot;</P></TD>
		<TD WIDTH=70%> <P CLASS="western">invalid assignment</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">i = 35</P></TD>
		<TD WIDTH=70%> <P CLASS="western">char &lowast;i = &quot;35&quot;</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">f = wave[1].seg[1].data[10]</P></TD>
		<TD WIDTH=70%> <P CLASS="western">sprintf(f, &quot;%.7g&quot;, wave[0].seg[0].data[9])</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">time = arrival[1].time</P></TD>
		<TD WIDTH=70%> <P CLASS="western">sprintf(time, &quot;%.15g&quot;, arrival[0].time)</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">d = fk.sig[3].snr[26]</P></TD>
		<TD WIDTH=70%> <P CLASS="western">sprintf(d, &quot;%.7g&quot;, fk.sig[2].snr[25])</P></TD>
	</TR>
	</TABLE>
</DL>

<P CLASS="western"><A NAME="Local and Global Scope"><B>Local and Global Scope</B></P>
<P CLASS="western">
Variables created by assignment are local to the script file. Variables created in a
script file will be undefined once the interpreter finishes reading the file. Variables created
by commands typed into the geotool shell window are local to the &quot;shell&quot; and will not be
defined when a script file is interpreted.</P>
<P CLASS="western">
There are two methods of passing information to script files. On the <A HREF="#parse">parse</A> command
line assignments that are within braces '{ }' will be made using the the current scope and the variable
will be created in the file's scope.</P>
<DL>
<PRE CLASS="western">
t = arrival[1].time + 10.;
parse scripts/file1 {a = 1.0; set phase=&quot;Pn&quot;; time=t}
# a, phase and time will be defined as scripts/file1 is interpreted. t will be undefined.
# a, phase and time are not defined in the current scope.
</PRE>
</DL>
<P CLASS="western">
The second method of passing information to script files is to use the <A HREF="#export">export</A> command
to make the variables global. A global variable will be defined in all script files.</P>
<DL>
<PRE CLASS="western">
time = arrival[1].time + 10.;
a = 1.0
set phase=&quot;Pn&quot;
export time
export a
export phase
parse scripts/file1
# a, phase and time will be defined as scripts/file1 is interpreted.
# they are also now defined in the current scope, and could have been modified by scripts/file1
</PRE>
</DL>
<P CLASS="western">
The export command can also be used inside a script file to insure that certain variable created in
the script file will be defined outside of the file. </P>

<P CLASS="western"><A NAME="Arrays"><B>Arrays</B></P>
<P CLASS="western">
All variables are arrays with at least one element. The index of the first element is 1. The following
script</P>
<DL>
<PRE CLASS="western">
set s = &quot;P&quot;
a = 7.5
b = a[1]
print s[1] a[1] b[1]
</PRE>
</DL>
<P CLASS="western">produces the output:</P>
<DL>
<PRE CLASS="western">P 7.5 7.5</PRE>
</DL>
<P CLASS="western">
Use the <A HREF="#export">set</A> command to create an array of string or numerical values with more than one element.
Each element is separated from the next by a comma. The elements do not need to be quoted, if they are numbers or
defined variable names. One array can be appended to another array. The following script</P>
<DL>
<PRE CLASS="western">
set s = &quot;P, Pn, S, Sn&quot;
set a = 1.2, 5.0, 3, 10.4
n1 = 3
n2 = 12
n3 = 7.5
set b = 2.67, n1, n2, 8.5, n3

set c = a ',' b

print s[3] a[4] b[2] c[7]
</PRE>
</DL>
<P CLASS="western">produces the output:</P>
<DL>
<PRE CLASS="western">S 10.4 3 12</PRE>
</DL>
<P CLASS="western">
The length of an array is obtained by appending &quot;.size()&quot; to the variable name:</P>
<DL>
<PRE CLASS="western">
n = s.size()
m = a.size()
print n m b.size() c.size()
</PRE>
</DL>
<P CLASS="western">produces the output:</P>
<DL>
<PRE CLASS="western">4 4 5 9</PRE>
</DL>
<P CLASS="western">
There are two ways to loop over the elements of an array:</P>
<DL>
<PRE CLASS="western">
set a = 1.2, 5.0, 3, 10.4

foreach(a)
    print a      # a takes on the value of each element with each iteration of the loop
endfor

foreach(1, a.size(), i)
    print a[i]
endfor
</PRE>
</DL>

</DL>
<H1 CLASS="western"><A NAME="Constants"></A>7.0 Constants and Reserved Names</H1>
<DL>
<P CLASS="western">
There are a few constants defined for convenience:</P>
    <DL>
	<TABLE WIDTH=90% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">pi</P></TD>
		<TD WIDTH=80%> <P CLASS="western">The system double precision &pi; (M_PI)</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">degrees_to_radians</P></TD>
		<TD WIDTH=80%> <P CLASS="western">&pi; / 180.0</P> </TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">radians_to_degrees</P></TD>
		<TD WIDTH=80%> <P CLASS="western">180.0 / &pi;</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">degrees_to_km</P></TD>
		<TD WIDTH=80%> <P CLASS="western">111.1954</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">km_to_degrees</P></TD>
		<TD WIDTH=80%> <P CLASS="western">1. / 111.1954</P></TD>
	</TR>
	</TABLE>
    </DL>
<P CLASS="western">
There are also a few reserved variable names.
</P>
    <DL>
	<TABLE WIDTH=90% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">true</P></TD>
		<TD WIDTH=80%> <P CLASS="western">logical expressions</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">false</P></TD>
		<TD WIDTH=80%> <P CLASS="western">logical expressions</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">standard_input</P></TD>
		<TD WIDTH=80%> <P CLASS="western">true for normal input,
			false if the program's stdin has been redirected: geotool &lt; file </P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">parse_only</P></TD>
		<TD WIDTH=20%> <P CLASS="western">true if the program is in non-graphical mode:
			geotool -i</P></TD>
	</TR>
	</TABLE>
    </DL>
</DL>
<H1 CLASS="western"><A NAME="Functions"></A>8.0 Functions</H1>
<DL>
<P CLASS="western">
<P CLASS="western"><A NAME="libm functions"><B>libm functions</B></P>
<P CLASS="western">
The following libm functions are defined.</P>
<DL>
	<TABLE WIDTH=90% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">abs(i)</P></TD>
		<TD WIDTH=80%> <P CLASS="western">absolute value of an integer</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">acos(x)</P></TD>
		<TD WIDTH=80%> <P CLASS="western">arc cosine of x (returns radians)</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">asin(x)</P></TD>
		<TD WIDTH=80%> <P CLASS="western">arc sine of x (returns radians)</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">atan2(y, x)</P></TD>
		<TD WIDTH=80%> <P CLASS="western">arc tangent of x,y (returns radians)</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">ceil(x)</P></TD>
		<TD WIDTH=80%> <P CLASS="western">smallest integral value not less that x</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">cos(x)</P></TD>
		<TD WIDTH=80%> <P CLASS="western">cos of x (x is radians)</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">double(i)</P></TD>
		<TD WIDTH=80%> <P CLASS="western">convert an integer to a double</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">exp(x)</P></TD>
		<TD WIDTH=80%> <P CLASS="western">base-e exponential of x</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">floor(x)</P></TD>
		<TD WIDTH=80%> <P CLASS="western">largest integral value not greater than x</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">fabs(x)</P></TD>
		<TD WIDTH=80%> <P CLASS="western">absolute value of floating-point number</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">int(x)</P></TD>
		<TD WIDTH=80%> <P CLASS="western">convert a float or double to integer</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">log(x)</P></TD>
		<TD WIDTH=80%> <P CLASS="western">natural logarithm of x</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">log10(x)</P></TD>
		<TD WIDTH=80%> <P CLASS="western">base-10 logarithm of x</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">pow(x, y)</P></TD>
		<TD WIDTH=80%> <P CLASS="western">returns the value of x raised to the power of y</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">sin(x)</P></TD>
		<TD WIDTH=80%> <P CLASS="western">sin of x (x is radians)</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">sqrt(x)</P></TD>
		<TD WIDTH=80%> <P CLASS="western">square root of x</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">tan(x)</P></TD>
		<TD WIDTH=80%> <P CLASS="western">tan of x (x is radians)</P></TD>
	</TR>
	</TABLE>
</DL>
<P CLASS="western"><A NAME="geographic and time functions"><B>geographic and time functions</B></P>
<P CLASS="western">The following functions are also defined:</P>
<DL>
	<TABLE WIDTH=95% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">azimuth(olat, olon, slat, slon)</P></TD>
		<TD WIDTH=70%> <P CLASS="western">returns the azimuth (clockwise from North) from o to s</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">distance(olat, olon, slat, slon)</P></TD>
		<TD WIDTH=70%> <P CLASS="western">returns the distance(degrees) from o to s</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">geocentric(geog_lat)</P></TD>
		<TD WIDTH=70%> <P CLASS="western">returns the geocentric latitude(deg) for the input geographic latitude</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">geographic(geoc_lat)</P></TD>
		<TD WIDTH=70%> <P CLASS="western">returns the geographic latitude(deg) for the input geocentric latitude</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">epoch(time_string)</P></TD>
		<TD WIDTH=70%> <P CLASS="western">returns the epoch time for the input time_string representation</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">etoh(epoch_time)</P></TD>
		<TD WIDTH=70%> <P CLASS="western">returns a string representation (YYYYJANDD hh:mm:ss.sss) of the input epoch_time</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">time()</P></TD>
		<TD WIDTH=70%> <P CLASS="western">returns the current epoch time</P></TD>
	</TR>
	</TABLE>
	<DD CLASS="western">travelTime(phase, olat, olon, odepth, slat, slon, elev, net, sta)</DD>
	<DD CLASS="western">travelTime(phase, origin[i], slat, slon, elev, net, sta)</DD>
	<DD CLASS="western">travelTime(phase, olat, olon, odepth, wave[j])</DD>
	<DD CLASS="western">travelTime(phase, origin[i], wave[j])</DD>
	<DL> <DD CLASS="western">
		These four versions of the travel time function return the travel
		time and set variables tt_phase and tt_slowness. tt_phase is the
		actual phase that was found when phase is input as &quot;firstP&quot;
		or &quot;firstS&quot;. tt_slowness is the slowness in
		seconds/degrees.
                </DD></DL>
</DL>
<P CLASS="western">The input arguments are</P>
<DL>
	<TABLE WIDTH=90% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">time_string</P></TD>
		<TD WIDTH=80%> <P CLASS="western">
			Many <A HREF="script_appendices.html#Appendix C">time formats</A> are supported.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">epoch_time</P></TD>
		<TD WIDTH=80%> <P CLASS="western">The number of seconds since 1970/1/1 00:00:00</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">geog_lat</P></TD>
		<TD WIDTH=80%> <P CLASS="western">A geographic latitude (degrees)</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">geoc_lat</P></TD>
		<TD WIDTH=80%> <P CLASS="western">A geocentric latitude (degrees)</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">phase</P></TD>
		<TD WIDTH=80%> <P CLASS="western">phase code</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">olat</P></TD>
		<TD WIDTH=80%> <P CLASS="western">origin latitude (degrees)</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">olon</P></TD>
		<TD WIDTH=80%> <P CLASS="western">origin longitude (degrees)</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">slat</P></TD>
		<TD WIDTH=80%> <P CLASS="western">station latitude (degrees)</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">slon</P></TD>
		<TD WIDTH=80%> <P CLASS="western">station longitude (degrees)</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">elev</P></TD>
		<TD WIDTH=80%> <P CLASS="western">station elevation (meters)</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">net</P></TD>
		<TD WIDTH=80%> <P CLASS="western">network code</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=20%> <P CLASS="western">sta</P></TD>
		<TD WIDTH=80%> <P CLASS="western">station code</P></TD>
	</TR>
	</TABLE>
</DL>
<P CLASS="western">
		An origin object can be input to travelTime() instead of olat, olon, and odepth. A wave object can be input instead of
		slat, slon, elev, net and sta. For example:</P>
<DL>
<PRE CLASS="western">
t = travelTime(&quot;P&quot;, origin[1], wave[3])
t = travelTime(&quot;P&quot;, origin[1], slat, slon, elev, net, sta)
t = travelTime(&quot;P&quot;, olat, olon, odepth, wave[3])
</DL>
</PRE>
<P CLASS="western">The following script</P>
<DL>
<PRE CLASS="western">
read file=&quot;data/tutorial/DPRK_reduced.wfdisc&quot;
t = travelTime(&quot;firstP&quot;, origin[1], wave[4])
print wave[4].sta tt_phase t(%.2f) tt_slowness(%.2f)

t = travelTime(&quot;firstP&quot;, origin[1], wave[6])
print wave[6].sta tt_phase t(%.2f) tt_slowness(%.2f)

print wave[1].sta arrival[1].sta arrival[1].phase
t = travelTime(&quot;P&quot;, origin[1], wave[1])
print wave[1].sta tt_phase t(%.2f) tt_slowness(%.2f)
d = t - (arrival[1].time - origin[1].time)
print &quot;observed - predicted =&quot; d(%.2f)
</PRE>
</DL>
<P CLASS="western">produces:</P>
<DL>
<PRE CLASS="western">
JKA pP 150.03 13.70
LPAZ PKPdf 1188.63 1.53
DAVOX DAVOX P
DAVOX P 714.24 5.64
observed - predicted = -0.93
</PRE>
</DL>
</DL>
<H1 CLASS="western"><A NAME="Waveforms"></A>9.0 Waveforms</H1>
<DL>
<P CLASS="western"><A NAME="waveform object names"><B>waveform object names</B></P>
<P CLASS="western">
The waveform object array wave[] provides access to the waveform data and attributes in any
window that displays waveforms. The table below shows the waveform object name in different windows: </P>
<DL>
	<TABLE WIDTH=90% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western"><B>waveform object</B></P></TD>
		<TD WIDTH=60%> <P CLASS="western"><B>window</B></P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">wave</P></TD>
		<TD WIDTH=60%> <P CLASS="western">the first waveform window</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">2.wave</P></TD>
		<TD WIDTH=60%> <P CLASS="western">the second waveform window</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">3.wave</P></TD>
		<TD WIDTH=60%> <P CLASS="western">the third waveform window, etc.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">arrivals.amp_mag.wplot.wave</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Amplitude/Magnitudes window waveforms</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">calibration.wave</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Calibration window waveforms</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">cluster.all.wave</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Cluster window All tab</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">cluster.cluster0.wave</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Cluster window Cluster 0 tab</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">cluster.cluster1.wave</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Cluster window Cluster 1 tab, etc.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">correlation.plot1.wave</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Correlation window Reference Trace</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">correlation.plot2.wave</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Correlation window Correlation Traces</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">detection_beams.beams</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Detection beams window</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">fk.beam_plot.wave</P></TD>
		<TD WIDTH=60%> <P CLASS="western">FK window beams</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">fk.signal.beam_plot.wave</P></TD>
		<TD WIDTH=60%> <P CLASS="western">FK Signal window beams</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">fk_multi_band.beam_plot.wave</P></TD>
		<TD WIDTH=60%> <P CLASS="western">FK Multi-Band window beams</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">fk_multi_band.signal.beam_plot.wave</P></TD>
		<TD WIDTH=60%> <P CLASS="western">FK Multi-Band Signal window beams</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">multi_channel_cross_correlation.wplot.wave</P></TD>
		<TD WIDTH=70%> <P CLASS="western">Multi Channel Cross Correlations</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">origin_beams.beams</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Origin beams window</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">pmcc.wplot.wave</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Pmcc window waveforms</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">polarization.wplot.wave</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Polarization window rotated waveforms</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">real_time_display.wave</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Real Time Display window waveforms</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">spectrogram.wplot.wave</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Spectrogram window waveform</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">edit_wave</P></TD>
		<TD WIDTH=60%> <P CLASS="western">the waveform whose tag menu or arrival menu was last displayed</P></TD>
	</TR>
	</TABLE>
</DL>
<P CLASS="western">
All of the wave objects listed above are arrays whose elements are referenced with the syntax wave[i], except for
edit_wave. This name references to a single waveform, whose members are referenced as edit_wave.MEMBER</P>
<P CLASS="western">
As discussed in <A HREF="#Command and Variable Context">2.0 Command and Variable Context</A>, there are also
many other potential windows that can be created with the &quot;New Window&quot; option buttons. If a second Waveform
Window is created with the File/New Window button (or the 2.open or any command that starts with &quot;2.&quot;), it will
have has it's own set of data analysis windows, Arrivals, Calibration, Cluster, Correlation, etc. The table
above can be repeated with a &quot;2.&quot; (or &quot;3.&quot;, etc.) prefixed to the waveform objects.</P>
<DL>
	<TABLE WIDTH=90% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">2.arrivals.amp_mag.wplot.wave</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Amplitude/Magnitudes window waveforms for the second waveform window</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">2.calibration.wave</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Calibration window waveforms for the second waveform window</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">n.correlation.plot1.wave</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Correlation window Reference Trace for the n<SUP>th</SUP> waveform window</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">etc.</P></TD>
		<TD WIDTH=60%> <P CLASS="western">etc.</P></TD>
	</TR>
	</TABLE>
</DL>
<P CLASS="western">
Some of the analysis windows can also be duplicated (FK, Polarization, Spectrogram, etc) for each Waveform window. It is
possible to have more potential waveform displays, such as: </P>
<DL>
	<TABLE WIDTH=90% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">fk.2.beam_plot.wave</P></TD>
		<TD WIDTH=60%> <P CLASS="western">The beams in the second FK window of the first waveform window</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">polarization.2.wplot.wave</P></TD>
		<TD WIDTH=60%> <P CLASS="western">The second Polarization window of the first waveform window</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">n.fk.m.beam_plot.wave</P></TD>
		<TD WIDTH=60%> <P CLASS="western">The beams in the m<SUP>th</SUP> FK window of the n<SUP>th</SUP> waveform window</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">etc.</P></TD>
		<TD WIDTH=60%> <P CLASS="western">etc.</P></TD>
	</TR>
	</TABLE>
</DL>
<P CLASS="western"><A NAME="selected waveform object names"><B>selected waveform object names</B></P>
<P CLASS="western">
There is a separate waveform array, sel_wave[], for selected waveforms. The tables above can be
repeated with &quot;wave&quot; replaced with &quot;sel_wave&quot;.</P>
<DL>
	<TABLE WIDTH=90% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western"><B>selected waveform object</B></P></TD>
		<TD WIDTH=60%> <P CLASS="western"><B>window</B></P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">sel_wave</P></TD>
		<TD WIDTH=60%> <P CLASS="western">the selected waveforms in the first waveform window</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">2.sel_wave</P></TD>
		<TD WIDTH=60%> <P CLASS="western">the selected waveforms in the second waveform window</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">n.fk.m.beam_plot.sel_wave</P></TD>
		<TD WIDTH=60%> <P CLASS="western">The selected beams in the m<SUP>th</SUP> FK window of the n<SUP>th</SUP> waveform window</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">etc.</P></TD>
		<TD WIDTH=60%> <P CLASS="western">etc.</P></TD>
	</TR>
	</TABLE>
</DL>
<P CLASS="western"><A NAME="waveform object syntax"><B>waveform object syntax</B></P>
<P CLASS="western">
The order of the waveform objects in the wave[] array is order waveforms are displayed in the window, from top to bottom.
The waveform wave[1] is the first waveform at the top. If a sort command reorders the waveforms in the window, the wave[]
array will reflect this new order. If the waveforms are reordered by distance when the travel time curves are displayed,
the wave[] array will reflect the new order. If the waveforms are reordered by any other means, such as interactively
dragging them to new vertical locations, the wave[] array will reflect the new order.</P>
<P CLASS="western">
There are two ways to use the wave[] array in a foreach loop. The following two foreach loops do the same thing.</P>
<DL>
<PRE CLASS="western">
foreach(wave, w)           # loop over all waveforms in the first waveform window
    # the w variable successively becomes wave[1], wave[2], etc as the loop is repeated
    if(w.sta == 'GERES')
	print w.sta w.chan w.tbeg(%t)
    endif
endfor

foreach(1, wave.size(), i)
    if(wave[i].sta == 'GERES')
	print wave[i].sta wave[i].chan wave[i].tbeg(%t)
    endif
endfor</PRE>
</DL>
<P CLASS="western">
The following commands take the wave object as an argument.</P>
<DL>
	<TABLE WIDTH=90% BORDER=2 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0 FRAME=VOID RULES=ROWS>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="convolve"></A><B>convolve</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>convolve</B> [ wave[i] ] [ instrument[j] ] [inid=INID] [low=LOW]
				[high=HIGH] [data_taper=SECS] [remove_time_shift=(true,false)]</P>
			<P CLASS="western">
			Description: Convolve an instrument response with the i<SUP>th</SUP> waveform. The response is specified
			with an instrument object instrument[j] or with an INID value. If neither of these parameters is specified,
			then the instrument that is currently selected in the Instrument Response All Instruments table is used.
			LOW and HIGH are the frequency limits. SECS is the length of the taper that is applied to each end of the waveform
			before the convolution (defaults to 5 seconds). If remove_time_shift is true (the default), any time shift caused
			by the response is removed. (The linear trend in the response phase is removed.) If there is no wave[i] argument, the
			convolve command operates on all selected waveforms.</P>
			<PRE CLASS="western">
convolve wave[3] inid=211455 low=0.1 high=15.</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="copy"></A><B>copy</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>copy</B> [ wave[i] ] [tmin=TMIN tmax=TMAX]</P>
			<P CLASS="western">
			Description: Copy the i<SUP>th</SUP> waveform to the paste buffer. If there is no wave[i] argument, the
			copy command copies all selected waveforms.</P>
			<PRE CLASS="western">
copy wave[4]   # copy the forth waveform to the paste buffer
2.paste        # paste the waveform into the second waveform window

copy fk_multi_band.beam_plot.wave[1]   # copy the first beam in the fk window
paste          # paste the beam into the first waveform window

# copy a two minute segment of the first waveforms centered at the 5'th arrival
copy wave[1] tmin=arrival[5].time-60. tmax=arrival[5].time+60.
2.paste     # paste the segment in the second waveform window</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="cut"></A><B>cut</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>cut</B> [ wave[i] ] [tmin=TMIN tmax=TMAX]</P>
			<P CLASS="western">
			Description: Copy the i<SUP>th</SUP> waveform to the paste buffer. If tmin and tmax are not specified,
			copy the entire waveform and remove it from the window. Otherwise, copy the waveform between tmin and
			tmax to the paste buffer and remove that part of the waveform. If there is no wave[i] argument, the
                        cut command operates on all selected waveforms.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="deconvolve"></A><B>deconvolve</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>deconvolve</B> [ wave[i] ] [ instrument[j] ] [inid=INID] [low=LOW]
				[high=HIGH] [data_taper=SECS] [remove_time_shift=(true,false)] [amp_cutoff=CUTOFF]</P>
			<P CLASS="western">
			Description: Deconvolve an instrument response from the i<SUP>th</SUP> waveform. The response is specified
			with an instrument object instrument[j] or an INID value. If neither of these parameters is specified,
			then the instrument that is associated with the station and channel of the waveform is deconvolved.
			LOW and HIGH are the frequency limits. SECS is the length of the taper that is applied to each end of the waveform
			before the convolution (defaults to 5 seconds). If remove_time_shift is true (the default), any time shift caused
			by the response is removed. (The linear trend in the response phase is removed.) If there is no wave[i] argument, the
			convolve command operates on all selected waveforms. The CUTOFF value is the minimum response amplitude, as a fraction
			of the maximum amplitude, that will be used in the inversion of the response for the deconvolution. The CUTOFF value
			is input as a negative logarithm value. For example, to limit the response amplitudes to values that are greater than
			1.e-06 times the maximum response amplitude, set amp_cutoff = -6. This is the default value.</P>
			<PRE CLASS="western">
deconvolve wave[3] low=0.1 high=15.</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="delete"></A><B>delete</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>delete</B> wave[i]</P>
			<P CLASS="western">
			Description: Remove the i<SUP>th</SUP> waveform from the program.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="deselect"></A><B>deselect</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>deselect</B> wave[i]</P>
			<P CLASS="western">
			Description: Deselect the i<SUP>th</SUP> waveform.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="display_calib"></A><B>display_calib</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>display_calib</B> [ wave[i] ]</P>
			<P CLASS="western">
			Description: Multiply the i<SUP>th</SUP> waveform by the calib factor. If there is no wave[i] argument, the
                        display_calib command operates on all selected waveforms.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="display_counts"></A><B>display_counts</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>display_counts</B> [ wave[i] ]</P>
			<P CLASS="western">
			Description: Display the i<SUP>th</SUP> waveform in counts. If there is no wave[i] argument, the
                        display_counts command operates on all selected waveforms.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="display_waveform"></A><B>display_waveform</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>display_waveform</B> wave[i]</P>
			<P CLASS="western">
			Description: Display the i<SUP>th</SUP> waveform, if only arrivals were original displayed.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="filter"></A><B>filter</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>filter</B> [ wave[i] ] low=LOW high=HIGH [type=TYPE]
				[order=ORDER] [zp=ZP]</P>
			<P CLASS="western">
			Description: Filter the i<SUP>th</SUP> waveform. LOW and HIGH are the frequency limits. TYPE is
			&quot;BP&quot;, &quot;BR&quot;, &quot;HP&quot;, &quot;LP&quot;. It defaults to &quot;BP&quot;.
			ORDER is [0-10]. It defaults to 3. ZP is true for
			zero-phase filter or false for causal. It defaults to false. If there is no wave[i] argument, the
                        filter command operates on all selected waveforms.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="output"></A><B>output</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>output</B> [ wave[i] ] file=FILE [tmin=TMIN] [tmax=TMAX] [append=(true,false)]
				[raw=(true,false)] [format=(css,sac,ascii)] [output_tables=(true,false)] [remark=REMARK]</P>
			<P CLASS="western">
			Description: Write the waveform to the file FILE. TMIN and TMAX define a segment to write out. The file
			will be overwritten if append is false. If raw is true, all modifications to the waveform are removed before
			it is written, otherwise the current waveform values are written. If output_tables is true, the associated
			tables, origin, arrival, assoc, etc. are also written. The optional remark is written to as remark record.
			The defaults are append=true, raw=true, format=&quot;css&quot;, and output_tables=false.
			If there is no wave[i] argument, the output command writes out all selected waveforms.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P CLASS="western"><A NAME="position"></A><B>position</B></P>
		</TD>
		<TD>
			<P CLASS="western">Synopsis: <B>position</B> wave[i] x=X y=Y</P>
			<P CLASS="western">
			Description: Position the first sample of the i<SUP>th</SUP> waveform at the plot coordinates (x,y).</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="print_wave"></A><B>print</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>print</B> wave[i]</P>
			<P CLASS="western">
			Description: List the member values of the i<SUP>th</SUP> waveform object in the
			form &quot;member_name=value&quot;.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="normal_polarity"></A><B>normal_polarity</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>normal_polarity</B> [ wave[i] ]</P>
			<P CLASS="western">
			Description: Display the i<SUP>th</SUP> waveform with the normal polarity. (Do not multiply the
			values by -1.) If there is no wave[i] argument, the normal_polarity command operates on all
			selected waveforms.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="remove_all_methods"></A><B>remove_all_methods</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>remove_all_methods</B> [ wave[i] ]</P>
			<P CLASS="western">
			Description: Remove all processing methods that have altered the i<SUP>th</SUP> waveform. If there is no wave[i] argument, the
			remove_all_methods command operates on all selected waveforms.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="remove_con_decon"></A><B>remove_con_decon</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>remove_con_decon</B> [ wave[i] ]</P>
			<P CLASS="western">
			Description: Remove all convolution and deconvolution operations from the i<SUP>th</SUP> waveform.
			If there is no wave[i] argument, the remove_con_decon command operates on all selected waveforms.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="remove_mean"></A><B>remove_mean</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>remove_mean</B> [ wave[i] ]</P>
			<P CLASS="western">
			Description: Demean the i<SUP>th</SUP> waveform. If there is no wave[i] argument, the
			remove_mean command operates on all selected waveforms.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="restore_mean"></A><B>restore_mean</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>restore_mean</B> [ wave[i] ]</P>
			<P CLASS="western">
			Description: Restore the mean to the i<SUP>th</SUP> waveform. If there is no wave[i] argument, the
			restore_mean command operates on all selected waveforms.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="reverse_polarity"></A><B>reverse_polarity</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>reverse_polarity</B> [ wave[i] ]</P>
			<P CLASS="western">
			Description: Display the i<SUP>th</SUP> waveform with the reversed polarity. (Multiply the
			values by -1.) If there is no wave[i] argument, the reverse_polarity command operates on all selected waveforms.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="rotate"></A><B>rotate</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>rotate</B> wave[i] azimuth=AZIMUTH [incidence=INCIDENCE]</P>
			<P CLASS="western">
			Description: Rotate the i<SUP>th</SUP> waveform and it's associated component waveforms to the
			specified station-to-source AZIMUTH, and INCIDENCE. The input waveform wave[i] can be any of the
			three components. The INCIDENCE is measured from vertical and defaults to 90. degrees. AZIMUTH
			and INCIDENCE are in degrees.  If only the horizontal components are available, then the
			INCIDENCE is forced to be 90.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="select"></A><B>select</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>select</B> wave[i]</P>
			<P CLASS="western">
			Description: Select the i<SUP>th</SUP> waveform.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="unfilter"></A><B>unfilter</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>unfilter</B> wave[i]</P>
			<P CLASS="western">
			Description: Remove the last filter applied to the i<SUP>th</SUP> waveform.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="unrotate"></A><B>unrotate</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>unrotate</B> wave[i]</P>
			<P CLASS="western">
			Description: Unrotate the i<SUP>th</SUP> waveform and it's associated component waveforms.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="update_tag"></A><B>update_tag</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>update_tag</B> wave[i]</P>
			<P CLASS="western">
			Description: Update the tag of i<SUP>th</SUP> waveform. This would
			normally be called after making changes to the tag contents with
			the tag_contents commands.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="zoom_on_waveform"></A><B>zoom_on_waveform</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>zoom_on_waveform</B> [ wave[i] ]</P>
			<P CLASS="western">
			Description: Zoom-in to display only the i<SUP>th</SUP> waveform. If there is no wave[i] argument, the
                        zoom_on_waveform command zooms to display all selected waveforms.</P>
		</TD>
	</TR>
	</TABLE>
</DL>

<P CLASS="western"><A NAME="waveform members"><B>waveform members</B></P>
<P CLASS="western">The wave[] object has the following members. They are accessed as suffixes to the wave[] object: wave[i].member.
For example:</P>
<DL>
<PRE CLASS="western">
print wave[2].hang wave[2].vang

foreach(sel_wave, w)
    if(w.sta ~= &quot;ARCES&quot; &amp;&amp; w.chan ~= &quot;sz&quot;)
	print w.tbeg(%t) w.length
    endif
endfor</PRE>
</DL>
<DL>
	<TABLE WIDTH=90% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western"><B>name</B></P></TD> <TD WIDTH=50%> <P CLASS="western"><B>description</B></P></TD> <TD WIDTH=25%> <P CLASS="western"><B>source</B></P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">begSelect</P></TD> <TD WIDTH=50%> <P CLASS="western">beginning time of a partial selection</P></TD> <TD WIDTH=25%> <P CLASS="western">computed</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">calib</P></TD> <TD WIDTH=50%> <P CLASS="western">nominal calibration</P></TD> <TD WIDTH=25%> <P CLASS="western">wfdisc table</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">calper</P></TD> <TD WIDTH=50%> <P CLASS="western">nominal calibration period</P></TD> <TD WIDTH=25%> <P CLASS="western">wfdisc table</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">chan</P></TD> <TD WIDTH=50%> <P CLASS="western">channel</P></TD> <TD WIDTH=25%> <P CLASS="western">wfdisc table</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">chanid</P></TD> <TD WIDTH=50%> <P CLASS="western">channel operation id</P></TD> <TD WIDTH=25%> <P CLASS="western">wfdisc table</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">clip</P></TD> <TD WIDTH=50%> <P CLASS="western">clipped flag</P></TD> <TD WIDTH=25%> <P CLASS="western">wfdisc table</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">current_alpha</P></TD> <TD WIDTH=50%> <P CLASS="western">Euler angle of current orientation</P></TD> <TD WIDTH=25%> <P CLASS="western">computed after rotation</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">current_beta</P></TD> <TD WIDTH=50%> <P CLASS="western">Euler angle of current orientation</P></TD> <TD WIDTH=25%> <P CLASS="western">computed after rotation</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">current_gamma</P></TD> <TD WIDTH=50%> <P CLASS="western">Euler angle of current orientation</P></TD> <TD WIDTH=25%> <P CLASS="western">computed after rotation</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">dataMax</P></TD> <TD WIDTH=50%> <P CLASS="western">maximum data value</P></TD> <TD WIDTH=25%> <P CLASS="western">computed when referenced</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">dataMaxIndex</P></TD> <TD WIDTH=50%> <P CLASS="western">data index of the maximum value</P></TD> <TD WIDTH=25%> <P CLASS="western">computed when referenced</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">dataMaxSegment</P></TD> <TD WIDTH=50%> <P CLASS="western">segment index of the maximum data value</P></TD> <TD WIDTH=25%> <P CLASS="western">computed when referenced</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">dataMin</P></TD> <TD WIDTH=50%> <P CLASS="western">minimum data value</P></TD> <TD WIDTH=25%> <P CLASS="western">computed when referenced</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">dataMinIndex</P></TD> <TD WIDTH=50%> <P CLASS="western">data index of the minimum value</P></TD> <TD WIDTH=25%> <P CLASS="western">computed when referenced</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">dataMinSegment</P></TD> <TD WIDTH=50%> <P CLASS="western">segment index of the minimum data value</P></TD> <TD WIDTH=25%> <P CLASS="western">computed when referenced</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">datatype</P></TD> <TD WIDTH=50%> <P CLASS="western">storage type</P></TD> <TD WIDTH=25%> <P CLASS="western">wfdisc table</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">deast</P></TD> <TD WIDTH=50%> <P CLASS="western">offset from array reference (km)</P></TD> <TD WIDTH=25%> <P CLASS="western">site table</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">dnorth</P></TD> <TD WIDTH=50%> <P CLASS="western">offset from array reference (km)</P></TD> <TD WIDTH=25%> <P CLASS="western">site table</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">duration</P></TD> <TD WIDTH=50%> <P CLASS="western">time of last sample minus time of first sample (sec)</P></TD> <TD WIDTH=25%> <P CLASS="western">computed</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">elev</P></TD> <TD WIDTH=50%> <P CLASS="western">station elevation (meters)</P></TD> <TD WIDTH=25%> <P CLASS="western">site table</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">endSelect</P></TD> <TD WIDTH=50%> <P CLASS="western">end time of a partial selection</P></TD> <TD WIDTH=25%> <P CLASS="western">computed</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">hang</P></TD> <TD WIDTH=50%> <P CLASS="western">horizontal angle of 3-component channel (deg)</P></TD> <TD WIDTH=25%> <P CLASS="western">sitechan table</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">index</P></TD> <TD WIDTH=50%> <P CLASS="western">index of waveform object</P></TD> <TD WIDTH=25%> <P CLASS="western">computed</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">instype</P></TD> <TD WIDTH=50%> <P CLASS="western">instrument code</P></TD> <TD WIDTH=25%> <P CLASS="western">wfdisc table</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">jdate</P></TD> <TD WIDTH=50%> <P CLASS="western">Julian date</P></TD> <TD WIDTH=25%> <P CLASS="western">wfdisc table</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">lat</P></TD> <TD WIDTH=50%> <P CLASS="western">station latitude (degrees)</P></TD> <TD WIDTH=25%> <P CLASS="western">site table</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">length</P></TD> <TD WIDTH=50%> <P CLASS="western">total number of samples</P></TD> <TD WIDTH=25%> <P CLASS="western">computed</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">lon</P></TD> <TD WIDTH=50%> <P CLASS="western">station longitude (degrees)</P></TD> <TD WIDTH=25%> <P CLASS="western">site table</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">mean</P></TD> <TD WIDTH=50%> <P CLASS="western">mean of sample values</P></TD> <TD WIDTH=25%> <P CLASS="western">computed when referenced</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">net</P></TD> <TD WIDTH=50%> <P CLASS="western">station network</P></TD> <TD WIDTH=25%> <P CLASS="western">affiliation table</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">num_dp</P></TD> <TD WIDTH=50%> <P CLASS="western">number of line cursor intersections</P></TD> <TD WIDTH=25%> <P CLASS="western">computed</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">dp[i].label</P></TD> <TD WIDTH=50%> <P CLASS="western">label of the i<SUP>th</SUP> line cursor</P></TD> <TD WIDTH=25%> <P CLASS="western">computed</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">dp[i].time</P></TD> <TD WIDTH=50%> <P CLASS="western">time of the sample nearest to the i<SUP>th</SUP> line cursor</P></TD> <TD WIDTH=25%> <P CLASS="western">computed</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">dp[i].data</P></TD> <TD WIDTH=50%> <P CLASS="western">value of the sample nearest to the i<SUP>th</SUP> line cursor</P></TD> <TD WIDTH=25%> <P CLASS="western">computed</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">num_dw</P></TD> <TD WIDTH=50%> <P CLASS="western">number of time-window cursor intersections</P></TD> <TD WIDTH=25%> <P CLASS="western">computed</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">dw[i].label</P></TD> <TD WIDTH=50%> <P CLASS="western">label of the i<SUP>th</SUP> time-window cursor</P></TD> <TD WIDTH=25%> <P CLASS="western">computed</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">dw[i].tbeg</P></TD> <TD WIDTH=50%> <P CLASS="western">time of the sample nearest to the beginning of the i<SUP>th</SUP> time-window cursor</P></TD> <TD WIDTH=25%> <P CLASS="western">computed</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">dw[i].tend</P></TD> <TD WIDTH=50%> <P CLASS="western">time of the sample nearest to the end of the i<SUP>th</SUP> time-window cursor</P></TD> <TD WIDTH=25%> <P CLASS="western">computed</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">nsegs</P></TD> <TD WIDTH=50%> <P CLASS="western">number of segments</P></TD> <TD WIDTH=25%> <P CLASS="western">computed</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">refsta</P></TD> <TD WIDTH=50%> <P CLASS="western">reference station for array members</P></TD> <TD WIDTH=25%> <P CLASS="western">site table</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">samprate</P></TD> <TD WIDTH=50%> <P CLASS="western">sampling rate in samples/second</P></TD> <TD WIDTH=25%> <P CLASS="western">wfdisc table</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">segtype</P></TD> <TD WIDTH=50%> <P CLASS="western">indexing method</P></TD> <TD WIDTH=25%> <P CLASS="western">wfdisc table</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">seg[]</P></TD> <TD WIDTH=50%> <P CLASS="western">there are nseg segment objects</P></TD> <TD WIDTH=25%> <P CLASS="western">computed</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">sta</P></TD> <TD WIDTH=50%> <P CLASS="western">station</P></TD> <TD WIDTH=25%> <P CLASS="western">wfdisc table</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">station_alpha</P></TD> <TD WIDTH=50%> <P CLASS="western">Euler angle of station orientation</P></TD> <TD WIDTH=25%> <P CLASS="western">computed from hang/vang</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">station_beta</P></TD> <TD WIDTH=50%> <P CLASS="western">Euler angle of station orientation</P></TD> <TD WIDTH=25%> <P CLASS="western">computed from hang/vang</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">station_gamma</P></TD> <TD WIDTH=50%> <P CLASS="western">Euler angle of station orientation</P></TD> <TD WIDTH=25%> <P CLASS="western">computed from hang/vang</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">tbeg</P></TD> <TD WIDTH=50%> <P CLASS="western">time of first sample</P></TD> <TD WIDTH=25%> <P CLASS="western">computed</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">tend</P></TD> <TD WIDTH=50%> <P CLASS="western">time of last sample</P></TD> <TD WIDTH=25%> <P CLASS="western">computed</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">time[i]</P></TD> <TD WIDTH=50%> <P CLASS="western">epoch time of i<SUP>th</SUP> sample</P></TD> <TD WIDTH=25%> <P CLASS="western">computed</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">vang</P></TD> <TD WIDTH=50%> <P CLASS="western">vertical angle of 3-component channel (deg)</P></TD> <TD WIDTH=25%> <P CLASS="western">sitechan table</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">xchan</P></TD> <TD WIDTH=50%> <P CLASS="western">channel name of x-axis component</P></TD> <TD WIDTH=25%> <P CLASS="western">computed</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">ychan</P></TD> <TD WIDTH=50%> <P CLASS="western">channel name of y-axis component</P></TD> <TD WIDTH=25%> <P CLASS="western">computed</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">zchan</P></TD> <TD WIDTH=50%> <P CLASS="western">channel name of z-axis component</P></TD> <TD WIDTH=25%> <P CLASS="western">computed</P></TD>
	</TR>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">xpos</P></TD> <TD WIDTH=50%> <P CLASS="western">the x-position of the first sample</P></TD> <TD WIDTH=25%> <P CLASS="western">computed</P></TD>
	</TR>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">ypos</P></TD> <TD WIDTH=50%> <P CLASS="western">the y-position of the first sample</P></TD> <TD WIDTH=25%> <P CLASS="western">computed</P></TD>
	</TR>
	</TABLE>
</DL>

<P CLASS="western"><A NAME="waveform members"><B>waveform segment members</B></P>
<P CLASS="western">The wave[].seg[] object has the following members. They are accessed as suffixes to the wave[].seg[] object: wave[i].seg[j].member</P>
<DL>
<PRE CLASS="western">
print wave[2].seg[1].length

foreach(1, wave[2].nsegs, i)
    print wave[2].seg[i].tbeg(%t) wave[2].seg[i].tend(%t)
endfor

foreach(1, 10, i)
    print wave[2].seg[1].data[i](%.4g)
endfor
</PRE>
</DL>
<DL>
	<TABLE WIDTH=90% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR VALIGN=TOP>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western"><B>name</B></P></TD> <TD WIDTH=50%> <P CLASS="western"><B>description</B></P></TD> <TD WIDTH=25%> <P CLASS="western"><B>source</B></P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">data[]</P></TD> <TD WIDTH=50%> <P CLASS="western">segment data values</P></TD> <TD WIDTH=25%> <P CLASS="western">input</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">length</P></TD> <TD WIDTH=50%> <P CLASS="western">number of samples</P></TD> <TD WIDTH=25%> <P CLASS="western">computed</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">tbeg</P></TD> <TD WIDTH=50%> <P CLASS="western">time of first sample</P></TD> <TD WIDTH=25%> <P CLASS="western">computed</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">tdel</P></TD> <TD WIDTH=50%> <P CLASS="western">time increment between samples</P></TD> <TD WIDTH=25%> <P CLASS="western">computed</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">tend</P></TD> <TD WIDTH=50%> <P CLASS="western">time of last sample</P></TD> <TD WIDTH=25%> <P CLASS="western">computed</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=25%> <P CLASS="western">samprate</P></TD> <TD WIDTH=50%> <P CLASS="western">sample rate = 1./tdel</P></TD> <TD WIDTH=25%> <P CLASS="western">computed</P></TD>
	</TR>
	</TABLE>
</DL>

<P CLASS="western"><A NAME="waveform object methods"><B>waveform object methods</B></P>
<P CLASS="western">
The following are wave object methods that take an epoch time as a single argument. The syntax is wave[i].methodName(time).</P>
<DL>
<PRE CLASS="western">
# check that there is no gap in the waveform during the time interval of interest
if( wave[4].nearestSegment(tmin) != wave[4].nearestSegment(tmax) )
    print "Multiple segments in the time interval"
    return
endif

# compute the long-term average over an interval of 60 seconds before the arrival
tmin = arrival[1].time - ltav_len
tmax = arrival[1].time

j = wave[4].nearestSegment(tmin)
beg = wave[4].nearestIndex(tmin)
end = wave[4].nearestIndex(tmax)
ltav = 0.
foreach(beg, end, i)
    ltav = ltav + fabs(wave[4].seg[j].data[i])
endfor

n = end - beg + 1
if( n &gt; 0 )
    ltav = ltav/double(n)
endif
</PRE>
</DL>
<DL>
	<TABLE WIDTH=90% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western"><B>method name</B></P></TD> <TD WIDTH=70%> <P CLASS="western"><B>description</B></P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">nearestData(time)</P></TD> <TD WIDTH=70%> <P CLASS="western">value of sample nearest to time</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">nearestSegment(time)</P></TD> <TD WIDTH=70%> <P CLASS="western">segment index of sample nearest to time</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">nearestIndex(time)</P></TD> <TD WIDTH=70%> <P CLASS="western">data index of sample nearest to time</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">lowerBoundData(time)</P></TD> <TD WIDTH=70%> <P CLASS="western">value of sample whose time is &lt;= time</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">lowerBoundSegment(time)</P></TD> <TD WIDTH=70%> <P CLASS="western">segment index of sample whose time is &lt;= time</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">lowerBoundIndex(time)</P></TD> <TD WIDTH=70%> <P CLASS="western">data index sample whose time is &lt;= time</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">upperBoundData(time)</P></TD> <TD WIDTH=70%> <P CLASS="western">value of sample whose time is &gt;= time</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">upperBoundSegment(time)</P></TD> <TD WIDTH=70%> <P CLASS="western">segment index of sample whose time is &gt;= time</P></TD>
	</TR> <TR VALIGN=TOP>
		<TD WIDTH=30%> <P CLASS="western">upperBoundIndex(time)</P></TD> <TD WIDTH=70%> <P CLASS="western">data index sample whose time is &gt;= time</P></TD>
	</TR>
	</TABLE>
</DL>

</DL>
<H1 CLASS="western"><A NAME="Database Tables"></A>10.0 Database Tables</H1>
<DL>
<P CLASS="western">
The syntax for accessing database table objects is the same as for the wave[] object array. Each member of the table is referenced as:</P>
<DL>
<P CLASS="western">TABLE_NAME[i].member_name</P>
</DL>
<P CLASS="western">
These objects can be accessed from most windows that display waveforms and also from the TableQuery window, after they have been loaded
from flat files or from an ODBC interface. To access TableQuery objects use the prefix &quot;tq&quot;. For example: </P>
<DL>
<PRE CLASS="western">
select tq.origin[5]

print tq.netmag[1].magnitude

foreach(tq.arrival, a)
    if(a.sta ~= 'ASAR')
        print a.sta a.arid a.amp a.per
    endif
endfor</PRE>
</DL>
<P CLASS="western">
The size() method gives the number of table objects in an array.  Selected table records are referenced by prefixing the table name with &quot;sel_&quot;.</P>
<DL>
<PRE CLASS="western">
# the following two loops do the same thing
foreach(1, sel_arrival.size(), i)
    print arrival[i].sta arrival[i].chan arrival[i].iphase
endfor

foreach(sel_arrival, a)
    print a.sta a.chan a.iphase
endfor
</PRE>
</DL>

<P CLASS="western">
Some more examples of foreach usage with tables are:</P>
<DL>
<PRE CLASS="western">
foreach(origin, o)                     # loop over all origin objects
    if( o.mb &gt; 3.0 )
        foreach(assoc, s)              # loop over all assoc objects
            if( s.orid == o.orid &amp;&amp; (s.phase == 'Pn' || s.phase == 'P') )
                foreach(arrival, a)            # loop over all arrival objects
                    if(a.arid == s.arid)
                        select a               # select the arrival
                    endif
                endfor
            endif
        endfor
    endif
endfor

foreach( tableviewer.wfdisc, w )        # loop over all wfdisc records in the TableViewer window
    if(w.sta ^= 'EK' &amp;&amp; w.chan ^= 's')
	print w.time(%t) w.sta w.chan w.nsamp
    endif
endfor
</PRE>
</DL>
<P CLASS="western">
The following commands take a table object as an argument.</P>
<DL>
	<TABLE WIDTH=90% BORDER=2 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0 FRAME=VOID RULES=ROWS>
	<TR VALIGN=TOP>
		<TD WIDTH=15%>
			<P CLASS="western"><A NAME="deselect_table"></A><B>deselect</B></P>
		</TD>
		<TD WIDTH=85%>
			<P CLASS="western">Synopsis: <B>deselect</B> TABLE[i]</P>
			<P CLASS="western">
			Description: Deselect the i<SUP>th</SUP> member of the TABLE object array. TABLE can
			be origin, arrival, assoc, etc.</P>
			<PRE CLASS="western">
deselect arrival[2]      # deselect the second arrival in the first waveform window
deselect 2.arrival[5]    # deselect the fifth arrival in the second waveform window
deselect tq.origin[1]    # deselect the first origin in the TableQuery window</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=15%>
			<P CLASS="western"><A NAME="edit_table"></A><B>edit</B></P>
		</TD>
		<TD WIDTH=85%>
			<P CLASS="western">Synopsis: <B>edit</B> TABLE[i] member=VALUE [member=VALUE] ...</P>
			<P CLASS="western">
			Description: Edit the i<SUP>th</SUP> member of the TABLE object array. TABLE can
			be origin, arrival, assoc, etc. The changes are written to the disk file or database.
			All table components and waveform windows are updated to display the new table
			member values.</P>
			<PRE CLASS="western">
edit arrival[2] time=&quot;2004Feb12 09:14:46.338&quot;  # set the time of the second arrival.
edit arrival[2] time=1076577286.338    # set the time of the second arrival.

# set fields in assoc[5] of the second waveform window
edit 2.assoc[5] phase=&quot;Pn&quot; seaz=134.32 timedef=&quot;d&quot;

latitude = 44.62
longitude = 12.92

# set fields in a TableQuery origin
edit tq.origin[3] time=1076577209.374 lat=latitude lon=longitude depth=0.
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=15%>
			<P CLASS="western"><A NAME="print_table"></A><B>print</B></P>
		</TD>
		<TD WIDTH=85%>
			<P CLASS="western">Synopsis: <B>print</B> TABLE[i]</P>
			<P CLASS="western">
			Description: List the member values of the i<SUP>th</SUP> TABLE object in the
			form &quot;member_name=value&quot;.</P>
			<PRE CLASS="western">print arrival[3]</PRE>
			<P CLASS="western">produces</P>
<PRE CLASS="western">
phase=Sn
sta=GERES
time=2004Feb12 09:15:26.057
arid=15894583
jdate=2004043
stassid=1490591
chanid=-1
chan=GE_055
iphase=Pg
stype=-
deltim=0.588
azimuth=188.97
delaz=6.57
slow=18.87
delslo=2.16
ema=56.28
rect=0.508
amp=12.7
per=0.5
logat=-999
clip=-
fm=-
snr=7.39
qual=1
auth=ARS:kasmi
commid=-1
lddate=2004-Feb-23
</PRE>
			<P CLASS="western">
			Individual table members can also be printed, as in:</P>
			<PRE CLASS="western">print arrival[3].sta arrival[3].chan arrival[3].time(%t)</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=15%>
			<P CLASS="western"><A NAME="select_table"></A><B>select</B></P>
		</TD>
		<TD WIDTH=85%>
			<P CLASS="western">Synopsis: <B>select</B> TABLE[i]</P>
			<P CLASS="western">
			Description: Select the i<SUP>th</SUP> member of the TABLE object array. TABLE can
			be origin, arrival, assoc, etc.</P>
			<PRE CLASS="western">
select arrival[2]      # select the second arrival in the first waveform window
select 2.arrival[5]    # select the fifth arrival in the second waveform window
select tq.origin[1]    # select the first origin in the TableQuery window</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=15%>
			<P CLASS="western"><A NAME="remove_from_db"></A><B>remove_from_db</B></P>
		</TD>
		<TD WIDTH=85%>
			<P CLASS="western">Synopsis: <B>remove_from_db</B> TABLE[i]</P>
			<P CLASS="western">
			Description: Permanently remove the i<SUP>th</SUP> member of the TABLE object array 
			from the program and from the disk file or the database table that contains it.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=15%>
			<P CLASS="western"><A NAME="add_table_cb"></A><B>add_table_cb</B></P>
		</TD>
		<TD WIDTH=85%>
			<P CLASS="western">Synopsis: <B>add_table_cb</B>=CALLBACK_SCRIPT</P>
			<P CLASS="western">
			Description: Assign a callback script to be interpreted whenever a table record is
			inserted into the database. The global variable "modified_table" refers to the table object
			during the interpretation of the CALLBACK_SCRIPT. An example script that send an IPC message
			to the ARS program whenever an arrival, assoc, or origin is added to the database is:</P>
			<PRE CLASS="western">
add_table_cb={
  if(modified_table.tableName == 'arrival')
    sprintf s '(add-arrival arid="' modified_table.arid '")'
    send_message dest="ARS" msg_id="CallScheme" msg=s class="geotool"
  else if(modified_table.tableName == 'assoc')
    sprintf s '(add-assoc arid="' modified_table.arid ' orid=' modified_table.orid '")'
    send_message dest="ARS" msg_id="CallScheme" msg=s class="geotool"
  else if(modified_table.tableName == 'origin')
    sprintf s '(add-origin orid="' modified_table.orid '")'
    send_message dest="ARS" msg_id="CallScheme" msg=s class="geotool"
  endif
  #  etc.
}
</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=15%>
			<P CLASS="western"><A NAME="deleted_table_cb"></A><B>deleted_table_cb</B></P>
		</TD>
		<TD WIDTH=85%>
			<P CLASS="western">Synopsis: <B>deleted_table_cb</B>=CALLBACK_SCRIPT</P>
			<P CLASS="western">
			Description: Assign a callback script to be interpreted whenever a table record is
			deleted. The global variable "modified_table" refers to the table object during the
			interpretation of the CALLBACK_SCRIPT.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=15%>
			<P CLASS="western"><A NAME="modified_table_cb"></A><B>modified_table_cb</B></P>
		</TD>
		<TD WIDTH=85%>
			<P CLASS="western">Synopsis: <B>modified_table_cb</B>=CALLBACK_SCRIPT</P>
			<P CLASS="western">
			Description: Assign a callback script to be interpreted whenever a table record is
			modified or deleted. Global variables are defined during the interpretation of the
			script that specify the table object and which members of the object have been modified.
			The variable "modified_table" refers to the table object. The variables "MEMBER_modified",
			where MEMBER is any table member name, is true if the member has been modified and
			false otherwise. For example, the script below can be used to send a message to another
			process whenever the phase name of an arrival is changed.</P>
			<PRE CLASS="western">
modified_table_cb={
  if(modified_table.tableName == 'assoc')
    if(phase_modified)
      sprintf s '(update-arrival-par-list "arid=' modified_table.arid \
          ' phase=' modified_table.phase '")'
      send_message dest="ARS" msg_id="CallScheme" msg=s class="gspectro"
    endif
  endif
}
</PRE>
			<P CLASS="western">
			This script sends a message in the following form to the receiver process, ARS:</P>
			<PRE CLASS="western">
(update-arrival-par-list "arid=32062500 phase=Pn")
</PRE>
		</TD>
	</TR>
	</TABLE>
</DL>
<P CLASS="western">
The following database tables are defined.</P>

<DD CLASS="western"><A HREF=csstables.html#affiliation>affiliation</A></DD>
<DD CLASS="western"><A HREF=csstables.html#ampdescript>ampdescript</A></DD>
<DD CLASS="western"><A HREF=csstables.html#amplitude>amplitude</A></DD>
<DD CLASS="western"><A HREF=csstables.html#arrival>arrival</A></DD>
<DD CLASS="western"><A HREF=csstables.html#assoc>assoc</A></DD>
<DD CLASS="western"><A HREF=csstables.html#channame>channame</A></DD>
<DD CLASS="western"><A HREF=csstables.html#clf>clf</A></DD>
<DD CLASS="western"><A HREF=csstables.html#dervdisc>dervdisc</A></DD>
<DD CLASS="western"><A HREF=csstables.html#filter>filter</A></DD>
<DD CLASS="western"><A HREF=csstables.html#fpdescription>fpdescription</A></DD>
<DD CLASS="western"><A HREF=csstables.html#frameproduct>frameproduct</A></DD>
<DD CLASS="western"><A HREF=csstables.html#fsave>fsave</A></DD>
<DD CLASS="western"><A HREF=csstables.html#fsdisc>fsdisc</A></DD>
<DD CLASS="western"><A HREF=csstables.html#fsrecipe>fsrecipe</A></DD>
<DD CLASS="western"><A HREF=csstables.html#fstag>fstag</A></DD>
<DD CLASS="western"><A HREF=csstables.html#gards_bg_energy_cal>gards_bg_energy_cal</A></DD>
<DD CLASS="western"><A HREF=csstables.html#gards_bg_isotope_concs>gards_bg_isotope_concs</A></DD>
<DD CLASS="western"><A HREF=csstables.html#gards_bg_proc_params>gards_bg_proc_params</A></DD>
<DD CLASS="western"><A HREF=csstables.html#gards_bg_proc_params_roi>gards_bg_proc_params_roi</A></DD>
<DD CLASS="western"><A HREF=csstables.html#gards_bg_qc_result>gards_bg_qc_result</A></DD>
<DD CLASS="western"><A HREF=csstables.html#gards_bg_roi_concs>gards_bg_roi_concs</A></DD>
<DD CLASS="western"><A HREF=csstables.html#gards_bg_roi_counts>gards_bg_roi_counts</A></DD>
<DD CLASS="western"><A HREF=csstables.html#gards_bg_std_spectra_result>gards_bg_std_spectra_result</A></DD>
<DD CLASS="western"><A HREF=csstables.html#gards_efficiency_pairs>gards_efficiency_pairs</A></DD>
<DD CLASS="western"><A HREF=csstables.html#gards_roi_channels>gards_roi_channels</A></DD>
<DD CLASS="western"><A HREF=csstables.html#gards_roi_limits>gards_roi_limits</A></DD>
<DD CLASS="western"><A HREF=csstables.html#gards_sample_data>gards_sample_data</A></DD>
<DD CLASS="western"><A HREF=csstables.html#gards_sample_status>gards_sample_status</A></DD>
<DD CLASS="western"><A HREF=csstables.html#history>history</A></DD>
<DD CLASS="western"><A HREF=csstables.html#hydrofeatures>hydrofeatures</A></DD>
<DD CLASS="western"><A HREF=csstables.html#infrafeatures>infrafeatures</A></DD>
<DD CLASS="western"><A HREF=csstables.html#instrument>instrument</A></DD>
<DD CLASS="western"><A HREF=csstables.html#lastid>lastid</A></DD>
<DD CLASS="western"><A HREF=csstables.html#md5_digest>md5_digest</A></DD>
<DD CLASS="western"><A HREF=csstables.html#netmag>netmag</A></DD>
<DD CLASS="western"><A HREF=csstables.html#origaux>origaux</A></DD>
<DD CLASS="western"><A HREF=csstables.html#origerr>origerr</A></DD>
<DD CLASS="western"><A HREF=csstables.html#origin>origin</A></DD>
<DD CLASS="western"><A HREF=csstables.html#outage>outage</A></DD>
<DD CLASS="western"><A HREF=csstables.html#parrival>parrival</A></DD>
<DD CLASS="western"><A HREF=csstables.html#pick>pick</A></DD>
<DD CLASS="western"><A HREF=csstables.html#pmcc_features>pmcc_features</A></DD>
<DD CLASS="western"><A HREF=csstables.html#pmcc_recipe>pmcc_recipe</A></DD>
<DD CLASS="western"><A HREF=csstables.html#sensor>sensor</A></DD>
<DD CLASS="western"><A HREF=csstables.html#site>site</A></DD>
<DD CLASS="western"><A HREF=csstables.html#sitechan>sitechan</A></DD>
<DD CLASS="western"><A HREF=csstables.html#spdisc>spdisc</A></DD>
<DD CLASS="western"><A HREF=csstables.html#stanet>stanet</A></DD>
<DD CLASS="western"><A HREF=csstables.html#stassoc>stassoc</A></DD>
<DD CLASS="western"><A HREF=csstables.html#stamag>stamag</A></DD>
<DD CLASS="western"><A HREF=csstables.html#staconf>staconf</A></DD>
<DD CLASS="western"><A HREF=csstables.html#waveinterval>waveinterval</A></DD>
<DD CLASS="western"><A HREF=csstables.html#wfdisc>wfdisc</A></DD>
<DD CLASS="western"><A HREF=csstables.html#wftag>wftag</A></DD>
<DD CLASS="western"><A HREF=csstables.html#xtag>xtag</A></DD>
</DL>
<H1 CLASS="western"><A NAME="Data I/O"></A>11.0 Data I/O</H1>
<DL>
<P CLASS="western">
Flat files can be input using the read command. Table records are stored in files whose names end with the a period
followed by the table type, such as &quot;.wfdisc&quot;, &quot;.origin&quot;, &quot;.arrival&quot;, etc. All table files that have the same
prefix are input together with the read command.</P>
<P CLASS="western">
Flat files can also be input by using the connect and read_waveforms commands, which allow for more control over the table records
and waveforms or parts of waveforms that are read. The interface provides commands to input records from flat files and ODBC connected databases.
The records are listed in the TableQuery window before they are input into the waveform window. There are commands that automatically
generate queries to fetch associated records from the ODBC connection and commands that constrain the waveforms or parts of waveforms
that are displayed in the waveform window.</P>
<DL>
	<TABLE WIDTH=90% BORDER=2 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0 FRAME=VOID RULES=ROWS>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="read"></A><B>read</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>read</B> FILE_OR_PREFIX [query=QUERY]</P>
			<P CLASS="western">
			Description: Read waveforms and table records. FILE_OR_PREFIX can be the file name of
			any of the table files, or the prefix. For example, the following commands are
			equivalent. They each read all of the waveforms referenced by the wfdisc records in
			DPRK.wfdisc and all tables from DPRK.arrival, DPRK.origin, DPRK.assoc, etc.</P>
			<PRE CLASS="western">
read &quot;../data/tutorial/DPRK.wfdisc&quot;   # read all waveforms and tables from DPRK files
read &quot;../data/tutorial/DPRK.origin&quot;   # read all waveforms and tables from DPRK files
read &quot;../data/tutorial/DPRK&quot;          # read all waveforms and tables from DPRK files </PRE>
			<P CLASS="western">
			The optional QUERY argument can be a simple query using the members of the wfdisc table.
			Some examples are:</P>
			<PRE CLASS="western">
set file=&quot;../data/tutorial/DPRK.wfdisc&quot;
read file query=&quot;select * from wfdisc where sta='JKA'&quot;
read file query=&quot;select * from wfdisc where sta in ('jka','JKA')&quot;
read file query=&quot;select * from wfdisc where sta in ('JKA','LPAZ','VRAC') and chan='BHZ'&quot;
read file query=&quot;select * from wfdisc where sta like 'AK' and chan='BHZ'&quot;
read file query=&quot;select * from wfdisc where chan='BHZ'&quot;
read file query=&quot;select * from wfdisc where time &lt; 1160358400 and endtime &gt; 1160358400&quot;
</PRE>
			<P CLASS="western">
			The read command will also read files in SAC (Seismic Analysis Code) format, GSE2.0 format and a geotool ASCII format that
			is described below. The file names of SAC, GSE or ASCII formatted files are not restricted. The program
			attempts to read a file using each format. There are suffixes which can be used to instruct the program
			to read using a specific format: &quot;.sac&quot; for SAC, &quot;.gse&quot; or &quot;.msg&quot;
			for a GSE message and &quot;.asc&quot; for an ASCII file.</P>
			<PRE CLASS="western">
read &quot;DBIC.BHE.2.sac&quot;       # read a SAC file
read &quot;msg10.27.gse&quot;         # read a GSE message file
read &quot;signals.asc&quot;          # read an ASCII file</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="recent_input"></A><B>recent_input</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>recent_input</B></P>
			<P CLASS="western">
			Description: Re-read the last flat-file set of waveforms and tables that was input during
			the current or previous execution of the program.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="connect"></A><B>connect</B></P>
		</TD>
		<TD WIDTH=90%>
			<DD CLASS="western">Synopsis: <B>connect</B> data_source=DATA_SOURCE user=USER password=PASSWORD</DD>
			<DD CLASS="western">Synopsis: <B>connect</B> prefix=PREFIX</DD>
			<DD CLASS="western">Synopsis: <B>connect</B> param_root=PARAM_DIR seg_root=SEG_DIR</DD>
			<P CLASS="western">
			Description: The connect command has three forms. The first form opens an ODBC connection to a database. The second form
			opens a 'connection' to a set of flat files with the prefix PREFIX. The third form opens a connection to a flat-file-database.
			Any previously opened connection is closed. No tables are initially input.  Subsequent commands will refer to this
			connection until either disconnect is called or connect is called again.</P>
			<PRE CLASS="western">
connect data_source=&quot;ORACLE&quot; user=&quot;user1&quot; password=&quot;passwd&quot;
connect prefix=&quot;../data/tutorial/DPRK&quot; # same as prefix=&quot;../data/tutorial/DPRK.wfdisc&quot;</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="disconnect"></A><B>disconnect</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>disconnect</B></P>
			<P CLASS="western">
			Description: Close an open connection. A connection is automatically disconnected when connect is called.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="get_aao"></A><B>get_aao</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>get_aao</B> ORIGIN</P>
			<P CLASS="western">
			Description: Automatically run queries for tables associated with the ORIGIN: origerr, assoc, arrival,
			amplitude, parrival, netmag, and stamag. The mapping table is used to make substitutions for the table
			names in the queries. The queries for each table have the following forms:<P>
			<P CLASS="western">origerr: select * from origerr where orid in (2316236)</P>
			<P CLASS="western">assoc: select * from assoc where orid in (2316236)</P>
			<P CLASS="western">arrival: select * from arrival where arid in (15833607, 15833630, 15833631, ...)</P>
			<P CLASS="western">parrival: select * from parrival where orid in (2316236)</P>
			<P CLASS="western">netmag: select * from netmag where orid in (2316236)</P>
			<P CLASS="western">stamag: select * from stamag where arid in (15833607, 15833630, 15833631, ...)</P>
			<PRE CLASS="western">
get_aao origin[10]</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="get_aaow"></A><B>get_aaow</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>get_aaow</B> ORIGIN</P>
			<P CLASS="western">
			Description: Automatically run queries for tables associated with the ORIGIN: origerr, assoc, arrival,
			amplitude, parrival, netmag, stamag, and wfdisc. The queries for each table are the same as for the get_aao
			command with the additional query for the wfdisc records in the form:</P>
			<P CLASS="western">select distinct w.* from affiliation a, wfdisc w where a.net='PDAR' and w.sta=a.sta and endtime &gt; 1076162140.40
			and time between 1076162140.40 - 144000.00 and 1076162440.40</P>
			<P CLASS="western">select distinct w.* from affiliation a, wfdisc w where a.net='NVAR' and w.sta=a.sta and endtime &gt; 1076162123.72
			and time between 1076162123.72 - 144000.00 and 1076162423.72</P>
			<P CLASS="western">There is a wfdisc query for each arrival. The net and epoch times in the query are from the arrival records.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="get_all_tables"></A><B>get_all_tables</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>get_all_tables</B></P>
			<P CLASS="western">
			Description: Read in all of the table files for an open prefix connection. This command works
			only for file prefix connections.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="get_wfdiscs"></A><B>get_wfdiscs</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>get_wfdiscs</B> ARRIVAL</P>
			<P CLASS="western">
			Description: Run queries to retrieve all wfdisc records associated with the ARRIVAL. The form of the queries
			is shown in the description of the get_aaow command.</P>
			<PRE CLASS="western">
get_wfdiscs_from arrival[6]</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="mapping"></A><B>mapping</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>mapping</B> table_name=NAME</P>
			<P CLASS="western">
			Description: Set a mapping from the table type (arrival, assoc, origin, wfdisc, etc.) to the
			database table name, which can include an account prefix. These mappings are used by the commands
			that automatically generate queries.</P>
			<PRE CLASS="western">
mapping arrival="tmp_arrival"
mapping origin="tmp_origin"
mapping wfdisc="sel3.wfdisc"</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="query"></A><B>query</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>query</B> TABLE QUERY</P>
			<P CLASS="western">
			Description: Run a query that will return the table records of type TABLE.</P>
			<PRE CLASS="western">
query &quot;origin&quot; &quot;select * from origin where time &gt; 1076161920 and time &lt; 1076164000&quot;
query &quot;arrival&quot; &quot;select * from tmp_arrival where arid in (15833607, 15833630, 15833631)&quot;
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="read_waveforms"></A><B>read_waveforms</B></P>
		</TD>
		<TD WIDTH=90%>
			<DD CLASS="western">Synopsis: <B>read_waveforms</B> [constraint=] ...</DD>
			<DD CLASS="western">Synopsis: <B>read_waveforms</B> ARRIVAL [constraint=] ...</DD>
			<DD CLASS="western">Synopsis: <B>read_waveforms</B> ORIGIN [constraint=] ...</DD>
			<P CLASS="western">
			Description: The read_waveforms command has three forms. The first form reads the waveforms
			for the selected wfdisc records. If no wfdisc records are selected, then all wfdisc records are used,
			subject to the optional constraints. One or more of waveform constraints can be specified.</P>
			<P CLASS="western">
			The second form runs queries for the waveforms and tables associated with the ARRIVAL and
			reads all waveforms. The queries are:</P>
			<PRE CLASS="western">
select * from assoc where arid in (ARRIVAL.arid)
select * from origin where orid in (assoc.orid)
select * from origerr where orid in (assoc.orid)
select * from netmag where orid in (assoc.orid)
select * from parrival where orid in (assoc.orid)
select * from amplitude where arid in (ARRIVAL.arid)
select * from stamag where orid in (assoc.orid)
select distinct w.* from affiliation a, wfdisc w where a.net=ARRIVAL.net
	and w.sta=a.sta and endtime &gt; ARRIVAL.time
	and time between ARRIVAL.time - 144000.00 and ARRIVAL.time</PRE>
			<P CLASS="western">
			The third form runs queries for the waveforms and tables associated with the ORIGIN and
			reads all waveforms. The queries are:</P>
			<PRE CLASS="western">
select * from assoc where orid in (ORIGIN.orid)
select * from arrival where arid in (assoc1.arid, assoc2.arid, ...)
select * from origerr where orid in (ORIGIN.orid)
select * from netmag where orid in (ORIGIN.orid)
select * from assoc where orid in (ORIGIN.orid)
select * from parrival where orid in (ORIGIN.orid)
select * from amplitude where arid in (assoc1.arid, assoc2.arid, ...)
select distinct w.* from affiliation a, wfdisc w where a.net=arrival1.net
	and w.sta=a.sta and endtime &gt; arrival1.time
	and time between arrival1.time - 144000.00 and arrival1.time   # for each arrival
</PRE>
		</TD>
	</TR>
	</TABLE>
<DL>
<P CLASS="western"><A NAME="read_waveforms constraints"><B>read_waveforms constraints</B></P>
<P CLASS="western">
One or more of the following constraints can be specified on the read_waveforms command line. They constrain the waveforms or the
parts of waveforms that are input.</P>
	<TABLE WIDTH=90% BORDER=2 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0 FRAME=VOID RULES=ROWS>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="start_phase"></A><B>start_phase</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: start_phase=PHASE</P>
			<P CLASS="western">
			The start time of the waveform is relative the this phase.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="end_phase"></A><B>end_phase</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: end_phase=PHASE</P>
			<P CLASS="western">
			The end time of the waveform is relative the this phase.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="start_phase_lead"></A><B>start_phase_lead</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: start_phase_lead=SECONDS</P>
			<P CLASS="western">
			The start time of the waveform is start_phase.time - start_phase_lead.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="end_phase_lag"></A><B>end_phase_lag</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: end_phase_lag=SECONDS</P>
			<P CLASS="western">
			The end time of the waveform is end_phase.time + end_phase_lag.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="start_time"></A><B>start_time</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: start_time=TIME_STRING</P>
			<P CLASS="western">
			Set the start time of the waveform. This constraint overrides start_phase.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="end_time"></A><B>end_time</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: end_time=TIME_STRING</P>
			<P CLASS="western">
			Set the end time of the waveform. This constraint overrides end_phase.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="distance_min"></A><B>distance_min</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: distance_min=DEGREES</P>
			<P CLASS="western">
			Input only waveforms whose associated origin has a distance &gt; distance_min.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="distance_max"></A><B>distance_max</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: distance_max=DEGREES</P>
			<P CLASS="western">
			Input only waveforms whose associated origin has a distance &lt; distance_max.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="azimuth_min"></A><B>azimuth_min</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: azimuth_min=DEGREES</P>
			<P CLASS="western">
			Input only waveforms whose associated origin has a azimuth &gt; azimuth_min.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="azimuth_max"></A><B>azimuth_max</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: azimuth_max=DEGREES</P>
			<P CLASS="western">
			Input only waveforms whose associated origin has a azimuth &lt; azimuth_max.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="segment_length"></A><B>segment_length</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: segment_length=SECONDS</P>
			<P CLASS="western">
			Display the waveform as separate segments of length segment_length.</P>
		</TD>
	</TR>
	</TABLE>
<P CLASS="western">
For example, the following script queries for an origin and some related wfdiscs. A 410 second segment of
each waveform at the predicted first P arrival is read. The waveforms are sorted, the instrument
response for each waveform is deconvolved and the window is printed to a PostScript file.</P>
<PRE CLASS="western">
connect data_source=&quot;ORACLE&quot; user=&quot;user1&quot; password=&quot;passwd&quot;

query &quot;origin&quot; &quot;select * from origin where orid=2316236&quot;

query &quot;wfdisc&quot; &quot;select distinct w.* from idcx.wfdisc w , reb.origin o, idcx.site s, reb.assoc a,\
idcx.affiliation f where a.orid=o.orid and o.orid=2316236 and w.chan in ('BHZ','bz','HHZ') and \
w.sta =s.sta and s.offdate &lt; 0 and w.sta in (select refsta from refsta where \
deg_distance(o.lat,o.lon,s.lat,s.lon) between 30 and 105) and w.sta=f.sta and \
f.net=a.sta and w.time between o.time-3600 and o.time+3600 order by w.time&quot;

read_waveforms start_phase=&quot;FirstP&quot; start_phase_lead=10. end_phase=&quot;FirstP&quot; end_phase_lag=400

sort_waveforms order=&quot;time/sta/chan&quot;
select_all
deconvolve low=0.1 high=15.
print_window.set command=&quot;&quot; filename=&quot;geotool.ps&quot;
print_window.print</PRE>

</DL>
</DL>
<P CLASS="western"><A NAME="The edit command"><B>The edit and remove_from_db commands</B></P>
<P CLASS="western">
All table objects in the program can be edited or deleted, and the changes will be updated in the disk file
or database table that contains the object.</P>
<P CLASS="western">The <A HREF="#edit_table">edit</A> command allows table member values to be changed. One or
more members can be changed with a single edit command. If one of the changes is invalid, then none of the
changes is made. For example, the following edit command</P>
<PRE CLASS="western">
edit origin[1] depth=30. time=&quot;today&quot; lat=34.6</PRE>
<P CLASS="western">produces the warning:</P>
<PRE CLASS="western">
edit: invalid value for origin.time: today</PRE>
<P CLASS="western">and no changes to the origin will be made. If all member changes are valid, the table will be
written to the disk or the database from which it was obtained. All geotool windows that display the table member
values will be updated.</P>
<P CLASS="western">The <A HREF="#remove_from_db">remove_from_db</A> command removes a table object from the program and permanently removes the
table record from the disk file or database from which it was obtained. All geotool windows that displayed the
table object will be updated.</P>
<P CLASS="western"><A NAME="Other data formats"><B>Other data formats</B></P>
<P CLASS="western">
The <A HREF="#read">read</A> command will read data files in three other formats in addition to CSS formatted records. The three
formats are SAC (Seismic Analysis Code), GSE2.0 and ASCII. When geotool creates new tables for waveforms that are read from these
types of files, the table records will be written in CSS format using the filename as a prefix. For example, if an arrival is added
to a waveform that was was read from a SAC formatted file named &quot;DBIC.BHE.2.sac&quot;, the following files will be created to hold the
arrival information.</P>
<PRE CLASS="western">
DBIC.BHE.2.sac.arrival
DBIC.BHE.2.sac.assoc
DBIC.BHE.2.sac.amplitude
DBIC.BHE.2.sac.pick
etc.
</PRE>
<P CLASS="western">
The ASCII format provides a simple method of describing CSS tabular data and waveform data. Each line in the file contains
free-formatted table member values or data values. To specify table values, use the table name followed by member=value phrases.
To specify data, use the &quot;wfdisc&quot; command to set some wfdisc member values and then use the &quot;data&quot; command followed by free-formatted
numbers. For example:</P>
<PRE CLASS="western">
# this is a comment
wfdisc
sta=AS01 chan=SHZ time=1160358307.70000 samprate=20.00000 calib=0.00925
calper=1.00000
origin orid=1 time=1160358000.0 lat=45. lon=150.
arrival arid=1 sta=AS01 chan=SHZ time=1160358327.7 iphase=P
# another comment
assoc orid=1 arid=1
data
208. 242. 228. 173. 145. 167.  202.0 247.0 272.0
287.0
308.0
302.0
324.0
# another comment
434.0
472.0 342.0 251.0
297.0 267.0
169.0
153.0

wfdisc sta=AKASG chan=001 time=1160358307.575 samprate=0.494
data 0.37274 0.81856
0.42401
0.35429
0.18553
0.099011
0.097231
0.046003
0.019546
0.015043
0.039958
0.07193
...</PRE>
<P CLASS="western">
The placement of new lines is not important, except to indicate a comment. If the first character of a line is '#', then the rest of the line
is a comment. A file that does not contain comments would not need any new lines. A file can contain more that one waveform and any number of
tables. The waveform data values are read until another command or the end of file is found.</P>

<P CLASS="western"><A NAME="import"><B>import</B></P>
<P CLASS="western">
The import command is used to read table members from a file that has &quot;columns&quot; of table members from one or more different table types. The
members can be in any order on the lines.</P>
<DL>
	<TABLE WIDTH=90% BORDER=2 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0 FRAME=VOID RULES=ROWS>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="import"></A><B>import</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>import</B> tables=TABLES members=MEMBERS [file=FILE] [member=VALUE] [member_start=VALUE] ...
			<P CLASS="western">
			Description: Read a free-formatted ascii file or read from the standard input if no file is
			specified. TABLES is a quoted list of one or more table names separated by commas. MEMBERS is
			a quoted list of table member names separated by commas that will be read on each column.
			The minus sign '-' can be used to skip a column.
			One or more member values can be specified with the
member=VALUE argument. This will set the member to the specified VALUE in all
records. The member_start=VALUE argument will increment the member value,
beginning with the specified VALUE.
</P>
		</TD>
	</TR>
	</TABLE>
</DL>
<P CLASS="western">
For example the following script will read a file that contains columns of sta, lat, lon, and other members of the site table.
The records go into the TableViewer window. All site records with an offdate &lt; 2009001 are removed. The records are
sorted by &quot;sta&quot; and written to the file &quot;iris.site&quot;.</P>
<PRE CLASS="western">
import tables=&quot;site&quot; members=&quot;sta,lat,lon,elev,ondate,offdate,staname&quot; file=&quot;iris.stations&quot;

foreach(tv.site, s)               # &quot;tv&quot; is a predefined alias for &quot;tableviewer&quot;
    if(s.offdate &lt; 2009001)
	tv.site.remove_record s
    endif
endfor

tv.site.sort_up column=&quot;sta&quot;

tv.save_all_tables file=&quot;iris.site&quot; append=false
</PRE>
<P CLASS="western">
The input file "iris.stations" might look like:</P>
<PRE CLASS="western">
ATKA 52.2027 -174.1955 0.055000 &quot;2002-10-03 00:00:00.0&quot; &quot;2599-12-31 23:59:59.0&quot; &quot;Atka Island Broadband&quot;
BESE 58.5796 -134.8543 0.870200 &quot;2003-09-20 00:00:00.0&quot; &quot;2599-12-31 23:59:59.0&quot; &quot;Bessie Mountain&quot;
BMR 60.9682 -144.603 0.842000 &quot;1979-08-19 00:00:00.0&quot; &quot;2599-12-31 23:59:59.0&quot; &quot;Bremner River&quot;
BPAW 64.1002 -150.9848 0.619000 &quot;2004-05-13 00:00:00.0&quot; &quot;2599-12-31 23:59:59.0&quot; &quot;Bear Paw Mountain Broadband&quot;
CHUM 63.8827 -152.3147 0.058000 &quot;2004-06-02 00:00:00.0&quot; &quot;2599-12-31 23:59:59.0&quot; &quot;Lake Minchumina Broadband&quot;
COLD 67.2274 -150.2013 0.377000 &quot;2004-05-19 00:00:00.0&quot; &quot;2599-12-31 23:59:59.0&quot; &quot;Coldfoot Broadband&quot;
DCPH 59.0912 -138.2136 0.678000 &quot;2002-08-03 00:00:00.0&quot; &quot;2599-12-31 23:59:59.0&quot; &quot;Deception Hills&quot;
DIV 61.1297 -145.7728 0.939000 &quot;1999-01-07 00:00:00.0&quot; &quot;2599-12-31 23:59:59.0&quot; &quot;Divide Microwave&quot;
EYAK 60.5493 -145.7479 0.146300 &quot;2002-10-03 00:00:00.0&quot; &quot;2599-12-31 23:59:59.0&quot; &quot;Cordova Ski Area&quot;
...
</PRE>
<P CLASS="western">
Another example of using the import command with multiple tables is shown below. Members of the site,
sitechan and sensor tables are obtained from the lines in the input file. The command is:</P>
<PRE CLASS="western">
import tables=&quot;site,sitechan,sensor&quot; file=&quot;station_data&quot; \
    members=&quot;sta,chan,hang,vang,-,time,endtime,ondate,offdate,chanid,lat,lon,elev,edepth&quot;
tv.site.sort_up column=&quot;sta&quot;
tv.sitechan.sort_up column=&quot;sta,chan&quot;
tv.save_all_tables file=&quot;stations&quot; append=true
</PRE>
<P CLASS="western">
and the file "station_data" is</P>
<PRE CLASS="western">
EFG  BHZ -1.     0. 40.      1034247000. 2034247000. 1999001 2009123    20    69.5349   25.5058  0.403 0.000
EFG  BHN  0.    90. 40.      1034247000. 2034247000. 1999001 2009123    21    69.5349   25.5058  0.403 0.000
EFG  BHE 90.    90. 40.      1034247000. 2034247000. 1999001 2009123    22    69.5349   25.5058  0.403 0.000
#
HIJ  BHZ -1.     0. 40.      1034247000. 2034247000. 1999001 2009123    23    45.5349   13.5058  0.403 0.000
HIJ  BHN 45.    90. 40.      1034247000. 2034247000. 1999001 2009123    24    45.5349   13.5058  0.403 0.000
HIJ  BHE 135.   90. 40.      1034247000. 2034247000. 1999001 2009123    25    45.5349   13.5058  0.403 0.000
...
</PRE>
<P CLASS="western">
When multiple tables are saved with the &quot;save_all_tables&quot; TableViewer command, the &quot;file&quot;
argument is used as a prefix for the filenames. The script above would append to the files
&quot;stations.site&quot;, &quot;stations.sitechan&quot; and &quot;stations.sensor&quot;.
These files are created, if they do not exist.</P>

<P CLASS="western"><A NAME="Output"><B>Output</B></P>
<P CLASS="western">
The output interface can be used to write waveform segments and table objects. Waveforms can be written with the
<A HREF="#output">output</A> command. The script below writes out a 30 second waveform segment at the predicted time
of the first arrival on each selected waveform.</P>
<DL>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
foreach(sel_wave, w)          # loop over the selected waveforms

    # get the travel time for the first P arrival for this waveform
    tt = travelTime(&quot;FirstP&quot;, origin[1], w)

    t = origin[1].time + tt

    # if the first P arrival is within the limits of the waveform
    if(w.tbeg &lt; t &amp;&amp; t &lt; w.tend)
        t1 = t - 10.  # output 10 seconds before to 20 seconds after the arrival
        t2 = t + 20.
	output w tmin=t1 tmax=t2 file=&quot;save01&quot; raw=false append=true output_tables=true
    endif
endfor
</PRE>
		</TD>
	</TR>
	</TABLE>
</DL>
<P CLASS="western">
Table objects that are in the listed in the TableQuery and TableViewer windows can be written to a file with the
following commands. The saved rows are written using standard CSS table formats.</P>
<DL>
	<TABLE WIDTH=90% BORDER=2 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0 FRAME=VOID RULES=ROWS>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="tq.save_selected_rows"></A><B>[tq,tv].save_selected_rows</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>save_selected_rows</B> table=TABLE file=FILE [append=(true,false)]
			<P CLASS="western">
			Description: Write the selected rows of the TABLE tab in the TableQuery or TableViewer window to FILE. If append is
			false, the FILE will be overwritten. The default is append=true.</P>
		</TD>
	</TR>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="tq.save_all_rows"></A><B>[tq,tv].save_all_rows</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>save_all_rows</B> table=TABLE file=FILE [append=(true,false)]
			<P CLASS="western">
			Description: Write all rows of the TABLE tab in the TableViewer or TableQuery window to FILE. If append is
			false, the FILE will be overwritten. The default is append=true.</P>
		</TD>
	</TR>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="tq.save_all_tables"></A><B>[tq,tv].save_all_tables</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>save_all_tables</B> file=FILE [append=(true,false)]
			<P CLASS="western">
			Description: Save all rows of the all table tabs in the TableViewer or TableQuery window. This command
			writes to multiple files. Each different tab of table type is written to a file with the prefix FILE,
			such as FILE.arrival, FILE.origin , etc. If append is false, the files will be overwritten. The default
			is append=true.</P>
		</TD>
	</TR>
	</TABLE>
</DL>
<P CLASS="western">
The following commands can be used to save the contents of any table. The table rows or columns will be written to a file
exactly as they appear in the table.</P>
<DL>
	<TABLE WIDTH=90% BORDER=2 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0 FRAME=VOID RULES=ROWS>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="TABLE.save_selected_rows"></A><B>TABLE.save_selected_rows</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>save_selected_rows</B> file=FILE [append=(true,false)]
			<P CLASS="western">
			Description: Write the selected rows of any table in any window to FILE. If append is
			false, the FILE will be overwritten. The default is append=true.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="TABLE.save_selected_columns"></A><B>TABLE.save_selected_columns</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>save_selected_columns</B> file=FILE [append=(true,false)]
			<P CLASS="western">
			Description: Write the selected columns of any table in any window to FILE. If append is
			false, the FILE will be overwritten. The default is append=true.</P>
		</TD>
	</TR>
	</TABLE>
</DL>
<P CLASS="western">
The following commands save the contents of the Correlation table to a file.
</P>
<DL>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
correlation.table.select_all
correlation.table.save_selected_rows file=&quot;correl&quot; append=false
</PRE>
		</TD>
	</TR>
	</TABLE>
</DL>
<P CLASS="western">
The <A HREF="#print">print</A>, <A HREF="#printOpen">printOpen</A> and <A HREF="#printClose">printClose</A> commands can also
be used to write variables to a file. The print command writes formatted lines. For example, the following script prints
the polarization results from the Polarization window to a file.</P>
<DL>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
read file=&quot;../../data/tutorial/DPRK.wfdisc&quot; query=&quot;select * from wfdisc where sta='STKA'&quot;

select_all
filter 2.0 4.0

alias p = polarization
p.compute

printOpen file=&quot;polar&quot;
num = p.recti.size()
foreach(1, num, i)
    print p.time[i](%t) p.recti[i](%5.2f) p.inc[i](%5.1f) p.paz[i](%5.1f)
endfor
printClose
</PRE>
		</TD>
	</TR>
	</TABLE>
</DL>
<P CLASS="western">
The <A HREF="#writeOpen">writeOpen</A>, <A HREF="#writeArray">writeArray</A> and other write commands can be used to write
binary output files. The following example script illustrates the use of some of the write commands. The script reads
waveforms from a file, computes a multi-band FK at the P arrival, finds the frequency band with the largest signal-to-noise
ratio for the beamed waveform, prints some information to a formatted file, writes the FK matrix to a binary file, and
outputs the beamed waveform to a &quot;.w&quot; file.
</P>
<DL>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
read file=&quot;../../data/tutorial/DPRK.wfdisc&quot; query=&quot;select * from wfdisc where sta like 'AK' and chan='BHZ'&quot;

select sta=&quot;AK01&quot;  # if one waveform is selected, the FK will use the 'cb' beam stations

time_window phase='P' lead=1. lag=4.  # put a time window about the P arrival

fkm.compute        # compute the Multi-Band FK
max = 0.
imax = 0

# the Multi-Band FK computes FK's for four frequency bands
foreach(1, 4, i)
    if(max &lt; fkm.fk[i].snr)  # find the frequency band with the largest SNR
        max = fkm.fk[i].snr
        imax = i
    endif
endfor

# print some information to a formatted file
printOpen file=&quot;fk.out&quot; append=false

alias f=fkm.fk
i = imax
print f[i].net f[i].tbeg f[i].tend f[i].fmin(%.1f) f[i].fmax(%.1f)
print f[i].slowdeg(%.2f) f[i].az(%.2f) f[i].fstat(%.2f) f[i].snr(%.2f)
print f[i].taper_type f[i].taper_beg f[i].taper_end

printClose

# write the FK matrix to a binary file
writeOpen file=&quot;fk.bin&quot;

writeInt(f[i].num_slowness)
writeDouble(f[i].slowness_max)
writeArray(f[i].matrix)        # the FK matrix is an array of float values

writeClose

# output a segment of the beamed waveform and the arrival record
# creates the files beam.wfdisc, beam.w, beam.arrival and possibly some other table files
tmin = f[i].tbeg - 10.
tmax = f[i].tend + 20.
output fkm.beam_plot.wave[2*(i-1)+1] file=&quot;beam&quot; tmin=tmin tmax=tmax raw=false append=false output_tables=true
</PRE>
		</TD>
	</TR>
	</TABLE>
</DL>

<P CLASS="western"></P>

</DL>
<H1 CLASS="western"><A NAME="Creating Graphical Components"></A>12.0 Creating Graphical Components</H1>
<DL>
<P CLASS="western">
The <A HREF="#create">create</A> command adds graphical components to the interface. Buttons, Toggle and Menus can
be added to any menubar and toolbar. New windows can be created that contain a variety of components. Script callbacks
can be tied to user actions in Buttons, Toggles, Lists, Tables, etc.</P>
<P CLASS="western">
To add a button to a menubar, use the create command prefixed with the menu name. For example, the following script adds a
button named &quot;F24&quot; to the Edit/Filter sub-menu of the first waveform window. It also adds the button to the toolbar. A Button
or Toggle must be in the menubar before it can be added to the toolbar. The activateCallback script is interpreted each time
the button is selected.</P>
<DL>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
Edit.Filter.create name=&quot;F24&quot; type=&quot;button&quot;              # add a button to the Edit/Filter menu
addToToolbar name=&quot;Edit.Filter.F24&quot; toolbar_name=&quot;F24&quot;   # display the button in the toolbar

Edit.Filter.F24.activateCallback={                  # add a callback script to the F24 button
    if(sel_wave.size() == 0)  # warn if no waveforms are selected
        showWarning &quot;No waveforms are selected.&quot;
        return
    endif

    foreach(sel_wave, w)                            # loop over all selected waveforms
        filter w low=2. high=4. order=3 type=&quot;BP&quot;   # filter each waveform
    endfor
}</PRE>
		</TD>
	</TR>
	</TABLE>
</DL>
<P CLASS="western">
A list of graphical components that can be created with the create command is in
<A HREF="script_appendices.html#Appendix A">Appendix A: Graphical Components</A>.</P>
<P CLASS="western">
A list of all graphical callback types, such as the activateCallback used above, is in
<A HREF="script_appendices.html#Appendix B">Appendix B: Graphical Callbacks</A>.</P>

<P CLASS="western"><A NAME="geotool_scripts"><B>~/.geotool++/scripts/init</B></P>
<P CLASS="western">
Geotool automatically reads all script files that are in the directory ~/.geotool++/scripts/init. To make the F24 button
appear each time geotool is executed, place the script above in a file in this directory.</P>
<P CLASS="western">
The following script creates a button called &quot;FBands&quot; in the Option menu of the waveform window. The button
is sensitive only when one waveform is selected. When the FBands button is selected, the lines of the
script between the braces {} of the FBands.activateCallback are interpreted. The selected waveform is filtered
several times with different filter bands and displayed in a second <A HREF="fbands.gif">waveform window</A>.
</P>
<DL>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
Option.create name=&quot;FBands&quot; type=&quot;button&quot;  # add a button to the Option menu
Option.FBands.setInsensitive               # make the button initially insensitive

# A dataChangeCallback is called for any change to the waveforms or their
# selected state. Add this callback so that the FBands button is sensitive
# only when one and only one waveform is selected.

dataChangeCallback={                   # add a callback script to the waveform window
    if(sel_wave.size() == 1)           # if one and only one waveform is selected,
        Option.FBands.setSensitive     # make the FBands button sensitive
    else
        Option.FBands.setInsensitive   # otherwise make it insensitive
    endif
}

# Add a callback script to the FBands button. Each time the
# FBands button is selected, this script will be interpreted.

Option.FBands.activateCallback={

    copy              # copy the selected waveform to the paste buffer

    set lo=1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0  # define the frequency band limits
    set hi=2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0

    2.clear           # clear the second waveform window
    # set the waveform tags in the second window
    2.tag_contents.set tag=&quot;station,channel,filter(low high)&quot;

    foreach(1, lo.size(), i)  # loop over all frequency bands
        2.paste            # paste from the paste buffer to the second window

        filter 2.wave[i] low=lo[i] high=hi[i]  # filter the waveform just pasted
    endfor

    2.open          # display the second waveform window
}</PRE>
		</TD>
	</TR>
	</TABLE>
</DL>
<BR>
<P CLASS="western"><A NAME="General window commands"><B>General window commands</B></P>
	<P CLASS="western">
	The following commands can be used with any window prefix.</P>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0 FRAME=VOID RULES=ROWS>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="addToToobar"></A><B>addToToobar</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: [WINDOW.]<B>addToToobar</B> name=NAME [toolbar_name=TOOLBAR_NAME] [position=POSITION]</P>
			<P CLASS="western">
			Description: Add a menubar child (button, toggle, menu) to the toolbar. The WINDOW is the name of the
			window that contains the menubar and toolbar. It defaults to the first waveform window. NAME is the name-identifier of
			the menubar child. The optional TOOLBAR_NAME is the label of the new item in the toolbar. The optional
			POSITION is the integer position of the new item, with the left most position being 1. If the position is less than 1
			or greater than the number of existing toolbar items, or the position is not specified, the new item will be positioned
			as the last toolbar item on the right. Some examples are:</P>
			<PRE CLASS="western">
addToToolbar name=&quot;Edit.Clear&quot; position=3
instrument_response.addToToolbar name=&quot;Exchange&quot; toolbar_name=&quot;Exc&quot;</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="choiceQuestion"></A><B>choiceQuestion</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: [WINDOW.]<B>choiceQuestion</B> question=QUESTION [title=TILE] [button1=LABEL1]
				[button2=LABEL2] [button3=LABEL3] [answer=ANSWER]</P>
			<P CLASS="western">
			Description: Display a popup window with a question and one, two or three buttons. The window is closed
			when one of the buttons is selected and the local variable ANSWER is set to the selected button number,
			1, 2, or 3. If WINDOW is specified, the popup window is centered over WINDOW, otherwise it is centered
			over the first waveform window. QUESTION is a string or string variable. If no button arguments are specified,
			the popup window will have one button named &quot;OK&quot;. Two examples are:</P>
			<PRE CLASS="western">
choiceQuestion question=&quot;Continue Processing?&quot; button1=&quot;Continue&quot; button2=&quot;Stop&quot;
if(answer == 2)
    return
endif</PRE>
		    <P><IMG SRC="question.gif" NAME="question" ALT="Question Window" ALIGN=BOTTOM BORDER=0></P>
			<PRE CLASS="western">
choiceQuestion question=&quot;File exists. Overwrite or append?&quot; button1=&quot;Overwrite&quot; \
button2=&quot;Append&quot; button3=&quot;Cancel&quot; title=&quot;Write Data File&quot;

if(answer == 1)
    ...
else if(answer == 2)
    ...
else
    ...
endif</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="close"></A><B>close</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: [WINDOW.]<B>close</B></P>
			<P CLASS="western">
			Description: Close the WINDOW. If WINDOW is omitted, the first waveform window is closed. If
			there are no remaining windows open, the program exits.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="create"></A><B>create</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: [PARENT.]<B>create</B> name=NAME type=TYPE [args={X-resources}] ...</P>
			<P CLASS="western">Synopsis: [PARENT.]<B>create</B> name=NAME type=&quot;FormDialog&quot; [title=TITLE] [pointer_focus=(true,false)]
				[independent=(true,false)]</P>
			<P CLASS="western">
			Description: Create a graphical component such as a button, toggle, table, list, popup-window, etc.
			PARENT is the name-identifier of the graphical component that will contain the component. The parent type can
			be Menu, Form, RowColumn, FormDialog, etc. The default PARENT, when none is specified, is the first waveform
			window. NAME is a unique string identifier that can be used in other commands, such as another create command
			or an addToToolbar command, etc. It is also the default label for components such as Button, Toggle, FormDialog,
			etc. TYPE is the type of graphical component, Button, Toggle, etc. Both the NAME and TYPE must be strings or string
			variables. The optional args argument specifies Xt/Motif widget resource values. Additional arguments may be
			defined depending on the component type being created. If the type is FormDialog, the window TITLE can be specified,
			as well as the keyboard focus policy. The window title defaults to NAME. The pointer_focus defaults to true.
			Some examples of usage are:</P>
			<PRE CLASS="western">
# create a button in the Edit/Filter menu of the first waveform window
Edit.Filter.create name=&quot;Filter All&quot; type=&quot;button&quot;

# create a button in the Option menu of the Instrument Response window
instrument_response.Option.create name=&quot;Exchange&quot; type=&quot;button&quot;

# create a FormDialog popup window
create name=&quot;Example&quot; type=&quot;FormDialog&quot; title=&quot;Example Dialog&quot;

# create a RowColumn widget in the Example window created by the previous line
example.create name=&quot;controls&quot; type=&quot;RowColumn&quot; args={
        leftAttachment:ATTACH_FORM
        leftOffset:5
        rightAttachment:ATTACH_FORM
        bottomAttachment:ATTACH_FORM
        bottomOffset:5
        orientation:HORIZONTAL
}</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="hide"></A><B>hide</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: [COMPONENT.]<B>hide</B></P>
			<P CLASS="western">
			Description: Remove a component, such as a Button, Toggle, Menu, Table, etc, from the graphical interface. The component
			will still exist and can be referenced in commands, but it will not be visible until COMPONENT.show is called.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="listQuestion"></A><B>listQuestion</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: [WINDOW.]<B>listQuestion</B> items=ITEMS [title=TILE] [answer=ANSWER]</P>
			<P CLASS="western">
			Description: Display a popup window with a list of items and button labeled Apply. One or more, or none of
			the items can be selected. The Apply button closes the popup window and puts the selected items in the
			variable ANSWER (defaults to answer). For example:</P>
			<TABLE BORDER=0 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0 FRAME=VOID RULES=ROWS>
			<TR>
			<TD>
			<PRE CLASS="western">
listQuestion items=&quot;P,Pn,S,Sn&quot; title=&quot;Choose Phases&quot; answer=&quot;phases&quot;
foreach(phases)
    if(phases == 'P')
	...
    else if(phases == 'Pn')
	...
    else if(phases == 'S')
	...
    else if(phases == 'Sn')
	...
    endif
endfor</PRE>
		</TD>
		<TD>
		    <P><IMG SRC="list.gif" NAME="list" ALT="List Window" ALIGN=BOTTOM BORDER=0></P>
		</TD>
		    </TR>
		    </TABLE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="open"></A><B>open</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: [WINDOW.]<B>open</B></P>
			<P CLASS="western">
			Description: Open the WINDOW. If WINDOW is omitted, the first waveform window is opened.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="listCallbacks"></A><B>listCallbacks</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: [COMPONENT.]<B>listCallbacks</B></P>
			<P CLASS="western">
			Description: List the names of all of the callback types for COMPONENT. If COMPONENT is omitted, print
			the names of all of the callback types for the first waveform window. The name of a callback type, such as
			&quot;activateCallback&quot;, &quot;selectRowCallback&quot;, etc., is used to add a callback script to the component.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="listChildren"></A><B>listChildren</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: [COMPONENT.]<B>listChildren</B></P>
			<P CLASS="western">
			Description: List the names of all of the component children of COMPONENT. If COMPONENT is omitted, print
			the names of all of the children of the first waveform window.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="setSensitive"></A><B>setSensitive</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: [COMPONENT.]<B>setSensitive</B></P>
			<P CLASS="western">
			Description: Make a graphical component, such as a Menu, Button, Toggle, etc, sensitive to mouse and
			keyboard input.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="setInsensitive"></A><B>setInsensitive</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: [COMPONENT.]<B>setInsensitive</B></P>
			<P CLASS="western">
			Description: Make a graphical component, such as a Menu, Button, Toggle, etc, insensitive to mouse and
			keyboard input.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="show"></A><B>show</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: [COMPONENT.]<B>show</B></P>
			<P CLASS="western">
			Description: Make a graphical component, such as a Menu, Button, Toggle, etc,  visible.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="showMessage"></A><B>showMessage</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: [WINDOW.]<B>showMessage</B> message=MESSAGE [title=TILE] [button=LABEL]</P>
			<P CLASS="western">
			Description: Display a popup window with a message label and one button with the default label &quot;Close&quot;. The
			default title is &quot;Message&quot;. For example:</P>
			<PRE CLASS="western">
showMessage message=&quot;No events were found.&quot;</PRE>
		    <P><IMG SRC="message.gif" NAME="message" ALT="Message Window" ALIGN=BOTTOM BORDER=0></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="showWarning"></A><B>showWarning</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: [WINDOW.]<B>showWarning</B> WARNING_MESSAGE</P>
			<P CLASS="western">
			Description: Display the geotool's Warning window with the WARNING_MESSAGE. For example:</P>
			<PRE CLASS="western">
showWarning &quot;No waveforms selected.&quot;</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="textQuestion"></A><B>textQuestion</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: [WINDOW.]<B>textQuestion</B> question=QUESTION [title=TILE] [button1=LABEL1]
			[button2=LABEL2] [default_response=DEFAULT] [answer=ANSWER]</P>
			<P CLASS="western">
			Description: Display a popup window with a question label and a text field into which the answer can be
			typed. The text field will contain a DEFAULT response, if one is specified. Otherwise, the text field will be
			blank. Two button are always displayed. The left button label defaults to &quot;Apply&quot; and the right button label
			defaults to &quot;Cancel&quot;. If the left button is selected, the local variable ANSWER will be set to the contents
			of the text field. If the right button is selected, the local variable ANSWER will be set to an empty string.
			For example:</P>
			<PRE CLASS="western">
textQuestion question=&quot;Enter the script filename&quot; default_response=&quot;scripts/script1&quot;
if(answer != &quot;&quot;)
    parse answer
endif</PRE>
			<P><IMG SRC="input.gif" NAME="input" ALT="Input Window" ALIGN=BOTTOM BORDER=0></P>
		</TD>
	</TR>
	</TABLE>
<P CLASS="western"><A NAME="popup_window"><B>Creating a popup window</B></P>

	<TABLE WIDTH=90% BORDER=2 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0 FRAME=VOID RULES=ROWS>
	<TR VALIGN=TOP>
		<TD WIDTH=80%>
		<P CLASS="western">
The following example script demonstrates how to create a new popup window, shown at the right, that contains
a Choice component and a List component, both with callback scripts. The popup window
contains a list of phases and a choice of &quot;observed&quot; or &quot;predicted&quot;. When a phase is selected
from the list, the waveforms in the waveform window are aligned on either the observed arrival
time or the predicted arrival time of the selected phase.</P>
		<P CLASS="western">
The graphical components are Motif widgets (XmFormDialog, XmRowColumn, etc.). The &quot;args&quot; parameter is used to
specify resources for each widget.</P>
		</TD>
		<TD WIDTH=20%>
<P><IMG SRC="align.gif" NAME="align" ALT="Align on Phase Window" ALIGN=BOTTOM BORDER=0></P>
		</TD>
	</TR>
	</TABLE>
<BR>
<DL>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
View.create name=&quot;Align on Phase...&quot; type=&quot;Button&quot;       # add a button to the View menu
View.align_on_phase.activateCallback=&quot;align_popup.open&quot;  # the button will open the align_popup

# create a popup window of type FormDialog
create name=&quot;align_popup&quot; type=&quot;FormDialog&quot; title=&quot;Align On Phase&quot;

# create a contain component
align_popup.create name=&quot;controls&quot; type=&quot;RowColumn&quot; args={
        leftAttachment:ATTACH_FORM
        leftOffset:5
        rightAttachment:ATTACH_FORM
        bottomAttachment:ATTACH_FORM
        bottomOffset:5
        orientation:HORIZONTAL
}

# create a button that will close the window
align_popup.controls.create name=&quot;Close&quot; type=&quot;Button&quot;
align_popup.controls.Close.activateCallback=&quot;align_popup.close&quot;

# create a separator which is a horizontal line
align_popup.create name=&quot;sep&quot; type=&quot;Separator&quot; args={
        leftAttachment:ATTACH_FORM
        rightAttachment:ATTACH_FORM
        bottomAttachment:ATTACH_WIDGET
        bottomWidget:controls
}

# create a Choice component (optionMenu) with two choices
align_popup.create name=&quot;choice&quot; type=&quot;Choice&quot; choices=&quot;observed,predicted&quot; args={
        topAttachment:ATTACH_FORM
        topOffset:5
        leftAttachment:ATTACH_FORM
        leftOffset:5
        rightAttachment:ATTACH_FORM
}

# The callback for the Choice component. This script is interpreted
# when the choice is changed.
align_popup.choice.activateCallback={
    if(align_popup.list.num_selected &gt; 0)         # if a phase is selected
        if(align_popup.choice.value == &quot;observed&quot;)         # if the choice is &quot;observed&quot;
            align_on_phase phase=align_popup.list.get_selected
        else                                               # else the choice is predicted
            align_on_predicted_phase phase=align_popup.list.get_selected
        endif
    endif
}

align_popup.create name=&quot;list&quot; type=&quot;List&quot; args={
        topAttachment:ATTACH_WIDGET
        topWidget:choice
        topOffset:5
        bottomAttachment:ATTACH_WIDGET
        bottomWidget:sep
        leftAttachment:ATTACH_FORM
        leftOffset:5
        rightAttachment:ATTACH_FORM
        selectionPolicy:SINGLE_SELECT
        visibleItemCount:7
        itemCount:7
        items:FirstP,P,Pn,Pg,S,Sn,Lg
}

# The callback for the List component. This script is interpreted
# when a phase is selected from the List. It is the same callback
# as the Choice callback.
align_popup.list.singleSelectionCallback {
    if(align_popup.list.num_selected &gt; 0)         # if a phase is selected
        if(align_popup.choice.value == &quot;observed&quot;)         # if the choice is &quot;observed&quot;
            align_on_phase phase=align_popup.list.get_selected
        else                                               # else the choice is predicted
            align_on_predicted_phase phase=align_popup.list.get_selected
        endif
    endif
}</PRE>
		</TD>
	</TR>
	</TABLE>
</DL>

<P CLASS="western"><A NAME="exchange_responses"><B>Exchange instrument responses</B></P>
<P CLASS="western">
The next example script adds a button to the Edit menu that deconvolves the instrument response
from a waveform and convolves the waveform with a different response. The script creates a new
button called &quot;Exchange Response&quot; in the Edit menu and creates it's toolbar link called &quot;Exc&quot;.
A dataChangeCallback script makes the new &quot;Exchange Response&quot; button sensitive only when there are
waveforms selected. The sensitivity of the toolbar button is automatically updated.<P>
<P CLASS="western">
The activateCallback script for the new button loops over all selected waveforms, deconvolves the
recording instrument and convolves the deconvolved waveform with a different instrument response.
The Option/History table will display the deconvolution and convolution operations along with the
demean and data taper operations that are performed automatically.</P>
<DL>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
# Add a button that deconvolves the instrument response and
# convolves the waveform with a different response.

Edit.create name=&quot;Exchange Response&quot; type=&quot;button&quot;    # add button to the Edit menu
addToToolbar name=&quot;Edit.Exchange Response&quot; toolbar_name=&quot;Exc&quot;  # display in toolbar
edit.exchange_response.setInsensitive  # make the button initially insensitive

dataChangeCallback={             # add a callback script to the waveform window
    if(sel_wave.size() &gt; 0)                   # if waveforms are selected, make the
        edit.exchange_response.setSensitive   # Exchange Response button sensitive
    else
        edit.exchange_response.setInsensitive # otherwise make it insensitive
    endif
}

# define the callback script for the Exchange Response button
Edit.Exchange_Response.activateCallback={

  new_inid = 211455   # the inid of the new instrument response

  foreach(sel_wave, w)        # loop over all selected waveforms
    if(w.samprate &gt; 39)       # if the sample rate is &gt; 39.
	flo = .01             # set the low pass frequency to .01 Hz
    else
	flo = .1              # otherwise set it to .1 Hz     
    endif
    nyquist = .5*w.samprate
    fhi = nyquist - 1.        # set the high pass frequency to nyquist - 1

    deconvolve w low=flo high=fhi amp_cutoff=-4  # deconvolve the recording response

    convolve w inid=new_inid low=flo high=fhi    # convolve the new instrument
  endfor
}</PRE>
		</TD>
	</TR>
	</TABLE>
</DL>
<P CLASS="western"><A NAME="A Table Example"><B>A Table Example</B></P>
	<TABLE WIDTH=90% BORDER=2 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0 FRAME=VOID RULES=ROWS>
	<TR VALIGN=TOP>
		<TD WIDTH=80%>
		<P CLASS="western">
This example script demonstrates how to create a popup window with a Table component. The window is shown
at the right. The Table component is filled with the station name, channel name and the mean value of
each waveform. The script demonstrates the use of the selectRowCallback, which in this case causes the
waveform window to zoom-in on the waveform corresponding to the row that is selected.</P>
		<P CLASS="western">
The dataChangeCallback is also used to interpret a script whenever there is a change to the waveforms
in the waveform window. It is interpreted each time a waveform is added removed from the window and also
each time any waveform is modified or selected.</P>
		</TD>
		<TD WIDTH=20%>
<P><IMG SRC="table1.gif" NAME="table1" ALT="Table Example Window" ALIGN=BOTTOM BORDER=0></P>
		</TD>
	</TR>
	</TABLE>
<DL>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
<PRE CLASS="western">
create name=&quot;Table Example&quot; type=&quot;FormDialog&quot;	               # create a popup window
table_example.create name=&quot;controls&quot; type=&quot;RowColumn&quot; args={   # create a container for buttons
        leftAttachment:ATTACH_FORM
        rightAttachment:ATTACH_FORM
        bottomAttachment:ATTACH_FORM
        orientation:HORIZONTAL
        borderWidth: 1
}

table_example.controls.create name=&quot;Close&quot; type=&quot;Button&quot;	     # create a button that will
table_example.controls.Close.activateCallback=&quot;table_example.close&quot;  # close the popup window

table_example.create name=&quot;table&quot; type=&quot;Table&quot; args={    # create a Table Component
        topAttachment:ATTACH_FORM
        topOffset:5
        bottomAttachment:ATTACH_WIDGET
        bottomWidget:controls
	bottomOffset: 5
        leftAttachment:ATTACH_FORM
        leftOffset:5
        rightAttachment:ATTACH_FORM
        columns:3
        singleSelect:True
        visibleRows:10
        columnLabels:sta,chan,mean
        tableTitle:Table Example
        width:220
}

# each time a row of the table is selected, this script is interpreted
table_example.table.selectRowCallback {
    if(table_example.table.num_sel_rows &gt; 0)       # if the number of selected rows &gt; 0
        i = table_example.table.sel_row[1].index   # the row index is the same as the waveform index
        zoom_on_waveform wave[i]                   # zoom in to display the i<SUP>th</SUP> waveform
    endif
}

Option.create name=&quot;Example1&quot; type=&quot;Button&quot;  # create a button in the Option menu

# each time the Option/Example1 is selected, this script will be interpreted
Option.Example1.activateCallback={
    table_example.table.remove_all_rows   # remove all rows from the table
    foreach(wave, w)                      # loop over all waveforms
        table_example.table.add_row w.sta w.chan w.mean(%.3g)  # add a row for each waveform
    endfor
    table_example.open       # display the popup window
}

# this callback is interpreted whenever there is a change to any waveform,
# ie. when waveforms are read, or deleted, or modified.
# It updates the contents of the table in the popup window.
dataChangeCallback={
    table_example.table.remove_all_rows   # this is the same script as the previous one
    foreach(wave, w)
        table_example.table.add_row w.sta w.chan w.mean(%.3g)
    endfor
}
</PRE>
		</TD>
	</TR>
	</TABLE>
</DL>

<P CLASS="western"><A NAME="popup_menus"><B>The arrival and waveform popup menus</B></P>

	<TABLE WIDTH=90% BORDER=2 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0 FRAME=VOID RULES=ROWS>
	<TR VALIGN=TOP>
		<TD WIDTH=80%>
		<P CLASS="western">
The script below demonstrates how to add a button to the arrival popup menu that is displayed by a
right-mouse-button click on an arrival tag. The arrival popup menu with a new &quot;View&quot; button added
is shown at the right. When the View button is selected, a callback script is interpreted that finds the
arrival's detection filter band, copies the waveform to a second window, filters the waveform
and zooms-in to display 20 seconds of data centered on the arrival.</P>
		<P CLASS="western">
The arrival popup menu is called <B>arrival_menu</B>. In the callback script, the arrival object has the
name <B>edit_arrival</B> and the waveform on which the arrival tag is draw has the name <B>edit_wave</B>.
</P>
		<P CLASS="western">
Buttons can also be added the waveform popup menu that is displayed by a right-mouse-button click on
the waveform tag. The waveform popup menu is called <B>waveform_menu</B>. In a callback script, the
waveform whose popup menu is displayed is again called <B>edit_wave</B>.
</P>
		</TD>
		<TD WIDTH=20%>
<P><IMG SRC="edit_arrival.gif" NAME="Arrival Popup Menu" ALT="Arrival Popup Menu" ALIGN=BOTTOM BORDER=0></P>
		</TD>
	</TR>
	</TABLE>

<DL>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
<PRE CLASS="western">
# add a button to the arrival popup menu
arrival_menu.create type=&quot;button&quot; name=&quot;View&quot; position=0

arrival_menu.view.activateCallback={  # the button's callback script

# get the index of the detection recipe for this arrival
set indices = detection_beams.table.find_indices(&quot;net&quot;, edit_arrival.sta, &quot;name&quot;, edit_arrival.chan)

  if(indices.size() &gt; 0) # if a detection recipe index was found
    copy edit_wave       # edit_wave is the waveform that has the arrival tag
    2.clear              # that displayed the arrival menu
    2.paste		 # copy the waveform to the second waveform window
    j = indices[1]	 # set j = to the first index. normally there is only one index.

    alias r = detection_beams.table.row
    filter 2.wave[1] low=r[j].flo high=r[j].fhi  # filter with the detection recipe frequencies

    2.zoom_on_waveform 2.wave[1]      # zoom-in vertically to the waveform

    tmin = edit_arrival.time - 10.
    tmax = edit_arrival.time + 10.
    2.time_zoom tbeg=tmin tend=tmax   # zoom-in horizontally to the arrival
  endif
}
</PRE>
		</TD>
	</TR>
	</TABLE>
</DL>

<P CLASS="western"><A NAME="fk detector"><B>A Simple Arrival Detector</B></P>

<P CLASS="western">
This example illustrates how the FK Multi-Band module can be used to detect arrivals. The Auto Compute
FK option is used to compute a series of FK's for a sliding five-second time window over three minutes of data from the GERES array.
Using a three-second overlap, a total of 87 FK's are computed in each of eight frequency bands. Two FK Multi-Band windows are
needed for the eight frequency bands, since each window can compute only four frequency bands at a time.</P>
<P CLASS="western">
The FK Multi-Band module automatically computes waveform beams for the azimuth and slowness of the peak amplitude of each FK
matrix. A signal-to-noise measurement, short-term-average over long-term-average, is made using a one-second short-term-average
time window whose end time is the end time of the FK time window and a sixty-second long-term-average time window whose end time
is the start time of the short-term-average window.</P>
<P CLASS="western">
After these computations are made, there are eight 87-element signal-to-noise arrays, one for each frequency
band. For each signal-to-noise array, local maximum values are found. A local maximum is greater than the preceding two
array elements and the following two array elements. All local maximum signal-to-noise values are placed in a detection table.
The detection table is sorted by the signal-to-noise values. The waveform beams for the top ten SNR values that are greater
than 3.0 are displayed in a separate Waveform Window. An arrival record is created for each of these top ten detections and
displayed on the waveform beams.
</P>
<P CLASS="western">
The detection table displays the SNR value, the arrival index, the frequency band, the azimuth, the slowness, and the time for each detection.
A row-select callback script is created that displays the FK that corresponds to the detection time when a row of the
detection table is selected.</P>
<P CLASS="western">
The figure below shows the waveform set that was used in this example. It is included in the geotool tutorial dataset as the file
tutorial/25454488.wfdisc.

<DL>
<P><IMG SRC="detect_input.gif" NAME="Detection Input" ALT="Detection Input" ALIGN=BOTTOM BORDER=0></P>
</DL>

<P CLASS="western">
There are two script files for this example. The first one is shown below. It is included in the
geotool distribution as the file scripts/detect1. To run this example, parse the file detect1 with the geotool command
parse &quot;SOURCE_DIR/scripts/detect1&quot;, where SOURCE_DIR is the directory path to the geotool source. Alternatively, the detect1 file can be
copied to the home subdirectory ~/.geotool++/scripts/init, and it will be parsed each time geotool is started.</P>
<P CLASS="western">
Script detect1 adds the &quot;Detect&quot; button to the Option menu of geotool's waveform window. The callback script for the button
parses the second file for this example, scripts/detect2. Copy detect2 to ~/.geotool++/scripts.</P>
<P CLASS="western">
Script detect1 also creates a window with a Table component to hold the detection results. The row callback for this
table displays the FK's that correspond to each detection.</P>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
option.create name=&quot;Detect&quot; type=&quot;Button&quot; # create the &quot;Detect&quot; button
option.detect.activateCallback={          # when it is selected, the script &quot;detect2&quot; is parsed
    # this path is relative to the location of the file &quot;detect1&quot;
    parse &quot;../detect2&quot; 
}

create name=&quot;detections&quot; type=&quot;FormDialog&quot;     # create a window with a Table component
detections.create name=&quot;table&quot; type=&quot;Table&quot; args={
    columns:9
    columnLabels:no.,window,kmax,low,high,snr,azimuth,slowness,time
    topAttachment: ATTACH_FORM
    leftAttachment: ATTACH_FORM
    rightAttachment: ATTACH_FORM
    bottomAttachment: ATTACH_FORM
    visibleRows: 10
    width: 400
}

detections.table.selectRowCallback={            # the table row select callback
    if(detections.table.num_sel_rows &gt; 0)       # if there is a selected row display the FK
        k = detections.table.sel_row[1].kmax    # k is the frequency band (1-8)
        i = detections.table.sel_row[1].window  # i is the time window
        if(k &lt;= 4)                               # frequency bands 1-4 are in the first FK
            fk_multi_band.display window=i
            fk_multi_band.open
        else                                    # frequency bands 5-8 are in the second FK
            fk_multi_band.2.display window=i
            fk_multi_band.2.open
        endif
    endif
}</PRE>
		</TD>
	</TR>
	</TABLE>
<P CLASS="western">
The detection window created by scrip1 and filled by scrip2 is shown below. In this example, there were six detections with
SNR values greater that 3.0. They are ordered by detection time.</P>
<DL>
<P><IMG SRC="detect_table.gif" NAME="Detection Table" ALT="Detection Table" ALIGN=BOTTOM BORDER=0></P>
</DL>
<P CLASS="western">
The detection waveform beams are displayed in a second waveform window that is shown below. The arrivals are labeled with
integers. The waveform labels display the azimuth and the frequency band limits.
<DL>
<P><IMG SRC="detect_beams.gif" NAME="Detection Beams" ALT="Detection Beams" ALIGN=BOTTOM BORDER=0></P>
</DL>
<P CLASS="western">
The script file detect2 is shown below. It is parsed each time the &quot;Detect&quot; button is selected. The waveforms should be
selected before the Detect button is selected.
</P>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
if( sel_wave.size() == 0 )
    showWarning &quot;No waveforms selected.&quot;
    return
endif

alias fk = fk_multi_band

# assign the frequency band limits
set lo=0.5,1.5,2.0,2.5,3.0,3.5,4.0,5.0
set hi=2.0,2.5,3.0,3.5,4.0,4.5,5.0,6.0

# set the frequency band limits of the first FK window
fk.flo1=lo[1]; fk.fhi1=hi[1]
fk.flo2=lo[2]; fk.fhi2=hi[2]
fk.flo3=lo[3]; fk.fhi3=hi[3]
fk.flo4=lo[4]; fk.fhi4=hi[4]

# set the parameter values for the first FK window
fk.parameters.window_length=5.    # 5 second time window for each FK
fk.parameters.window_overlap=3.   # 3 second window overlap
fk.parameters.stav_length=1.      # 1 second short-term-average window
fk.parameters.ltav_length=60.     # 60 second long-term-average window
fk.auto_compute                   # compute the FK's for frequency bands 1-4

# set the frequency band limits of the second FK window
fk.2.flo1=lo[5]; fk.2.fhi1=hi[5]
fk.2.flo2=lo[6]; fk.2.fhi2=hi[6]
fk.2.flo3=lo[7]; fk.2.fhi3=hi[7]
fk.2.flo4=lo[8]; fk.2.fhi4=hi[8]

# set the parameter values for the second FK window
fk.2.parameters.window_length=5.
fk.2.parameters.window_overlap=3.
fk.2.parameters.stav_length=1.
fk.2.parameters.ltav_length=60.
fk.2.auto_compute                 # compute the FK's for frequency bands 5-8

detections.open
detections.table.remove_all_rows

max_detections = 10   # the maximum number of detections allowed
min_snr = 3.0         # the low SNR cutoff
num = 0
n = fk.sig[1].snr.size() - 2

foreach(3, n, i)      # loop over the SNR values
    kmax = 0
    snr_max = 0
    foreach(1, 4, k)  # loop over the frequency bands of the first FK window
        alias s=fk.sig
        m = s[k].snr[i]
        if(m &gt; min_snr &amp;&amp; m &gt; s[k].snr[i-2] &amp;&amp; m &gt; s[k].snr[i-1] \
		   &amp;&amp; m &gt; s[k].snr[i+1] &amp;&amp; m &gt; s[k].snr[i+2])
            if(m &gt; snr_max)
                snr_max = m
                kmax = k
                azimuth = s[k].azimuth[i]
                slowness = s[k].slowness[i]
		time = s[k].time[i]
            endif
        endif
    endfor

    foreach(1, 4, k)  # loop over the frequency bands of the second FK window
        alias s=fk.2.sig
        m = s[k].snr[i]
        if(m &gt; min_snr &amp;&amp; m &gt; s[k].snr[i-2] &amp;&amp; m &gt; s[k].snr[i-1] \
		   &amp;&amp; m &gt; s[k].snr[i+1] &amp;&amp; m &gt; s[k].snr[i+2])
            if(m &gt; snr_max)
                snr_max = m
                kmax = 4+k
                azimuth = s[k].azimuth[i]
                slowness = s[k].slowness[i]
		time = s[k].time[i]
            endif
        endif
    endfor

    # if a local snr maximum was found, add it to the detection table
    if(kmax &gt; 0)
	num = num + 1
	detections.table.add_row num i kmax lo[kmax] hi[kmax] snr_max(%.2f)\
		 azimuth(%.2f) slowness(%.2f) time(%t)
    endif
endfor

n = max_detections
if(n &gt; detections.table.num_rows)
    n = detections.table.num_rows
else
    # sort the detection table and take the top &quot;n&quot; SNR values
    detections.table.sort_down column=&quot;snr&quot;
endif

2.clear
2.tag_contents.set tag=&quot;text input,filter(low high)&quot;

foreach(1, n, j)
    k = detections.table.row[j].kmax
    i = detections.table.row[j].window
    s = detections.table.row[j].snr
    azimuth = detections.table.row[j].azimuth
    slowness = detections.table.row[j].slowness

    if(k &lt;= 4)
        fk.display window=i       # display the i'th FK and beam
        m = 2*(k-1) + 1           # odd traces are beams, even are ftraces
        copy fk.beam_plot.wave[m] # copy the beam to the paste buffer
	time = fk.sig[k].time[i]
    else
        fk.2.display window=i
        m = 2*(k-4-1) + 1
        copy fk.2.beam_plot.wave[m]
	time = fk.2.sig[k-4].time[i]
    endif
    2.paste  # copy the beam to the second waveform window

    # set the waveform label
    sprint label azimuth(%.1f) slowness(%.1f)
    2.tag_contents.set text=label
    2.update_tag 2.wave[j]

    # create an arrival record. it is written to disk or database
    2.add_arrival 2.wave[j] phase=j time=time
endfor

2.arrivals_on_one_channel
2.open
</PRE>
		</TD>
	</TR>
	</TABLE>

<P CLASS="western">
The FK window is shown below. It will display the FK's for the detection time window when a detection
row is selected in the Detection table.</P>
<DL>
<P><IMG SRC="detect_fks.gif" NAME="Detection FKs" ALT="Detection FKs" ALIGN=BOTTOM BORDER=0></P>
</DL>

</DL>
<H1 CLASS="western"><A NAME="Waveform Window Commands"></A>13.0 Waveform Window Commands</H1>
<DL>
<P CLASS="western">
The following commands are available in any window that displays waveforms. For windows other than the first waveform
window, prefix the commands with the window name. For example,</P>
<DL>
<PRE CLASS="western">
select wave[2]              # select the second waveform of the first waveform window
2.display_amplitude_scale   # display the amplitude scales in the second waveform window
fk_multi_band.beam_plot.print_window.print  # print beams at the bottom of the FK Multi-Band window
correlation.plot2.auto_scale_on  # turn auto scale on in the Correlation Traces plot
</PRE>
</DL>
<P CLASS="western">
The prefixes for waveform window commands are:</P>
<DL>
	<TABLE WIDTH=90% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western"><B>command prefix</B></P></TD>
		<TD WIDTH=60%> <P CLASS="western"><B>window</B></P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">2.</P></TD>
		<TD WIDTH=60%> <P CLASS="western">the second waveform window</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">3.</P></TD>
		<TD WIDTH=60%> <P CLASS="western">the third waveform window, etc.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">arrivals.amp_mag.wplot.</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Amplitude/Magnitudes waveform window</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">calibration.</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Calibration window</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">cluster.all.</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Cluster window All tab</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">cluster.cluster0.</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Cluster window Cluster 0 tab</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">cluster.cluster1.</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Cluster window Cluster 1 tab, etc.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">correlation.plot1.</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Correlation Reference Trace</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">correlation.plot2.</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Correlation Correlation Traces</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">detection_beams.beams.</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Detection beams window</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">fk.beam_plot.</P></TD>
		<TD WIDTH=60%> <P CLASS="western">FK window beams</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">fk.signal.beam_plot.</P></TD>
		<TD WIDTH=60%> <P CLASS="western">FK Signal window beams</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">fk_multi_band.beam_plot.</P></TD>
		<TD WIDTH=60%> <P CLASS="western">FK Multi-Band window beams</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">fk_multi_band.signal.beam_plot.</P></TD>
		<TD WIDTH=60%> <P CLASS="western">FK Multi-Band Signal window beams</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">multi_channel_cross_correlation.wplot.</P></TD>
		<TD WIDTH=70%> <P CLASS="western">Multi Channel Cross Correlations</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">origin_beams.</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Origin beams window</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">pmcc.wplot.</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Pmcc window waveforms</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">polarization.wplot.</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Polarization window rotated waveforms</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">real_time_display.</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Real Time Display window waveforms</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%> <P CLASS="western">spectrogram.wplot.</P></TD>
		<TD WIDTH=60%> <P CLASS="western">Spectrogram window waveform</P></TD>
	</TR>
	</TABLE>
</DL>
<P CLASS="western">
The waveform window commands are:</P>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0 FRAME=VOID RULES=ROWS>
	<TR VALIGN=TOP>
		<TD WIDTH=40%>
		<P CLASS="western"><A NAME="ww_add_arrival"></A><B>add_arrival</B> wave[i] phase=PHASE time=TIME</P> </TD>
		<TD WIDTH=60%>
		<P CLASS="western">Create an arrival. The arrival record is saved to disk or to the database.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=40%>
			<P CLASS="western"><A NAME="ww_align_on_phase"></A><B>align_on_phase</B> phase=PHASE</P>
		</TD>
		<TD WIDTH=60%>
			<P CLASS="western">Align waveforms on time - observed PHASE arrival time.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_align_on_predicted_phase"></A><B>align_on_predicted_phase</B> phase=PHASE</P>
		</TD> <TD> <P CLASS="western">Align waveforms on time - predicted PHASE arrival time.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_align_first_point"></A><B>align_first_point</B></P>
		</TD><TD><P CLASS="western">Align waveforms on their first samples.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_align_true_time"></A><B>align_true_time</B></P>
		</TD><TD><P CLASS="western">Align waveforms on time.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_align_predicted_firstP"></A><B>align_predicted_firstP</B></P>
		</TD><TD><P CLASS="western">Align waveforms on time - predicted first-P time.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_align_observed_firstP"></A><B>align_observed_firstP</B></P>
		</TD><TD><P CLASS="western">Align waveforms on time - observed first-P time.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_arrivals_off"></A><B>arrivals_off</B></P>
		</TD><TD><P CLASS="western">Do not display the arrivals tags.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_arrivals_on_one_channel"></A><B>arrivals_on_one_channel</B></P>
		</TD><TD><P CLASS="western">Display arrival tags only when the waveform station and channel match
			the arrival station and channel.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_arrivals_on_all_channels"></A><B>arrivals_on_all_channels</B></P>
		</TD><TD><P CLASS="western">Display arrival tags on all waveform channels when the waveform network matches the arrival station.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_auto_scale_on"></A><B>auto_scale_on</B></P>
		</TD><TD><P CLASS="western">Adjust the vertical scale to display all waveforms.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_auto_scale_off"></A><B>auto_scale_off</B></P>
		</TD><TD><P CLASS="western">Use current waveform height and waveform separation.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_beam"></A><B>beam</B> azimuth=DEGREES slowkm=SECS/KM or slowdeg=SECS/DEG
		[low=FREQ] [high=FREQ] [type=TYPE] [order=ORDER] [zp=(true,false)] [replace=(true,false)]</P>
		</TD><TD><P CLASS="western">Create a waveform beam from the selected waveforms. The slowness can be entered
		with slowkm or slowdeg. To specify a filter, use the low and high frequency band limits. TYPE can be
		&quot;BP&quot;, &quot;BR&quot;, &quot;LP&quot;, or HP&quot;. It defaults to &quot;BP&quot;.
		The filter order can be 0 to 10. It defaults to 3.
		The zero-phase argument zp defaults to false. If replace is false (the default), a new waveform beam is
		added to the bottom of the waveform window. If replace is true, the last waveform beam that was added to
		the window will be replaced by this beam.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><B>beam</B> arrival[i] [selected_only=(true,false)] [replace=(true,false)]</P>
		</TD><TD><P CLASS="western">Create a waveform beam using the arrival detection beam recipe. The
		arrival channel name must be a detection recipe name. If selected_only is false (the default), then
		all waveforms in the recipe group are included in the beam. If selected_only is true, then waveforms
		from the recipe group are included only if they are currently selected. If replace is false (the
		default), a new waveform beam is added to the bottom of the waveform window. If replace is true,
		the last waveform beam that was added to the window will be replaced by this beam.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_clear"></A><B>clear</B></P>
		</TD><TD><P CLASS="western">Clear all waveforms and other data from the waveform window.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_components_all"></A><B>components_all</B></P>
		</TD><TD><P CLASS="western">Display all waveform components of three-component stations.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_components_z_only"></A><B>components_z_only</B></P>
		</TD><TD><P CLASS="western">Display only the z-component of all three-component stations.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_components_n_and_e"></A><B>components_n_and_e</B></P>
		</TD><TD><P CLASS="western">Display the n-component and e-component of all three-component stations.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_components_n_only"></A><B>components_n_only</B></P>
		</TD><TD><P CLASS="western">Display only the n-component of all three-component stations.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_components_e_only"></A><B>components_e_only</B></P>
		</TD><TD><P CLASS="western">Display only the e-component of all three-component stations.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_components_e_only"></A><B>components_e_only</B></P>
		</TD><TD><P CLASS="western"></P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_convolve"></A><B>convolve</B> [ wave[i] ] [ instrument[j] ] [inid=INID] [low=LOW]
                                [high=HIGH] [data_taper=SECS] [remove_time_shift=(true,false)]</P></TD>
		<TD><P CLASS="western">
			Convolve an instrument response with the i<SUP>th</SUP> waveform. The response is specified
			with an instrument object instrument[j] or with an INID value. If neither of these parameters is specified,
			then the instrument that is currently selected in the Instrument Response All Instruments table is used.
			LOW and HIGH are the frequency limits. SECS is the length of the taper that is applied to each end of the waveform
			before the convolution (defaults to 5 seconds). If remove_time_shift is true (the default), any time shift caused
			by the response is removed. (The linear trend in the response phase is removed.) If there is no wave[i] argument, the
			convolve command operates on all selected waveforms.</P>
			<PRE CLASS="western">
convolve wave[3] inid=211455 low=0.1 high=15.</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_copy"></A><B>copy</B> [ wave[i] ] [tmin=TMIN tmax=TMAX]</P>
		</TD><TD><P CLASS="western">Copy the i<SUP>th</SUP> waveform and associated tables to the paste buffer. Copy only
		samples between TMIN and TMAX, if these limits are specified. If there is no wave[i] argument, the copy command copies all selected
		waveforms.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_copy"></A><B>cut</B> [ wave[i] ] [tmin=TMIN tmax=TMAX]</P>
		</TD><TD><P CLASS="western">Copy the i<SUP>th</SUP> waveform and associated tables to the paste buffer. If tmin and tmax are not
		specified, copy the entire waveform and remove it from the window. Otherwise, copy the waveform between tmin and tmax to the paste
		buffer and remove that part of the waveform. If there is no wave[i] argument, the cut command operates on all selected waveforms.</P>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_deconvolve"></A><B>deconvolve</B> [ wave[i] ] [ instrument[j] ] [inid=INID] [low=LOW]
                                [high=HIGH] [data_taper=SECS] [remove_time_shift=(true,false)] [amp_cutoff=CUTOFF]</P>
		</TD><TD><P CLASS="western">
			Deconvolve an instrument response from the i<SUP>th</SUP> waveform. The response is specified
			with an instrument object instrument[j] or an INID value. If neither of these parameters is specified,
			then the instrument that is associated with the station and channel of the waveform is deconvolved.
			LOW and HIGH are the frequency limits. SECS is the length of the taper that is applied to each end of the waveform
			before the convolution (defaults to 5 seconds). If remove_time_shift is true (the default), any time shift caused
			by the response is removed. (The linear trend in the response phase is removed.) If there is no wave[i] argument, the
			convolve command operates on all selected waveforms. The CUTOFF value is the minimum response amplitude, as a fraction
			of the maximum amplitude, that will be used in the inversion of the response for the deconvolution. The CUTOFF value
			is input as a negative logarithm value. For example, to limit the response amplitudes to values that are greater than
			1.e-06 times the maximum response amplitude, set amp_cutoff = -6. This is the default value.</P>
			<PRE CLASS="western">
deconvolve wave[3] low=0.1 high=15.</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_delete"></A><B>delete</B> wave[i]</P>
		</TD><TD><P CLASS="western">Remove the i<SUP>th</SUP> waveform from the program.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_delete_all_cursors"></A><B>delete_all_cursors</B></P>
		</TD><TD><P CLASS="western">Remove all cursors from the window.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_delete_crosshair"></A><B>delete_crosshair</B></P>
		</TD><TD><P CLASS="western">Remove the last crosshair cursor that was drawn.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_delete_data"></A><B>delete_data</B></P>
		</TD><TD><P CLASS="western">Remove all selected waveforms from the program.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_delete_line"></A><B>delete_line</B></P>
		</TD><TD><P CLASS="western">Remove the last line cursor that was drawn.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_delete_phase_line"></A><B>delete_phase_line</B></P>
		</TD><TD><P CLASS="western">Remove the last phase-line cursor that was drawn.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_delete_time_window"></A><B>delete_time_window</B> [label=LABEL]</P>
		</TD><TD><P CLASS="western">Remove the time-window cursor whose label is LABEL. If LABEL is not
		specified, remove the 'a' time-window cursor.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_deselect"></A><B>deselect</B> arrival[i]</P></TD>
		<TD><P CLASS="western">Deselect the i<SUP>th</SUP> arrival.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_deselect"></A><B>deselect</B> origin[i]</P></TD>
		<TD><P CLASS="western">Deselect the i<SUP>th</SUP> origin.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_deselect"></A><B>deselect</B> wave[i]</P></TD>
		<TD><P CLASS="western">Deselect the i<SUP>th</SUP> waveform.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_deselect"></A><B>deselect</B> NUM</P></TD>
		<TD><P CLASS="western">Deselect waveform by its position from the top starting at one.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_deselect"></A><B>deselect</B> [sta=STA] [chan=CHAN] [wfid=WFID] [orid=ORID]</P></TD>
		<TD><P CLASS="western">Deselect waveforms that match the specified attributes.</P>
		<PRE CLASS="western">select sta=&quot;AK04&quot; chan=&quot;BHZ&quot;</PRE></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_deselect_all"></A><B>deselect_all</B></P></TD>
		<TD><P CLASS="western">Deselect all waveforms.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_deselect_all_arrivals"></A><B>deselect_all_arrivals</B></P></TD>
		<TD><P CLASS="western">Deselect all arrivals.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_display_all_data"></A><B>display_all_data</B></P>
		</TD><TD><P CLASS="western">Display all waveforms that are hidden by &quot;display_selected_only&quot;.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_display_amplitude_scale"></A><B>display_amplitude_scale</B></P>
		</TD><TD><P CLASS="western">Display an amplitude scale on each waveform. (See <A HREF="#ww_hide_amplitude_scale">hide_amplitude_scale</A>)</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_display_calib"></A><B>display_calib</B> [ wave[i] ]</P>
		</TD><TD><P CLASS="western">
			Multiply the i<SUP>th</SUP> waveform by the calib factor. If there is no wave[i] argument, the
                        display_calib command operates on all selected waveforms.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_display_counts"></A><B>display_counts</B> [ wave[i] ]</P></TD>
		<TD><P CLASS="western">
			Display the i<SUP>th</SUP> waveform in counts. If there is no wave[i] argument, the
                        display_counts command operates on all selected waveforms.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_display_selected_only"></A><B>display_selected_only</B></P>
		</TD><TD><P CLASS="western">Display only the waveforms that are selected.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_display_tags"></A><B>display_tags</B></P>
		</TD><TD><P CLASS="western">Display waveform tags on the waveforms. (See <A HREF="#ww_hide_tags">hide_tags</A>)</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_display_waveform"></A><B>display_waveform</B> wave[i]</P></TD>
		<TD><P CLASS="western">Display the i<SUP>th</SUP> waveform, if only arrivals were original displayed.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_filter"></A><B>filter</B> [ wave[i] ] low=LOW high=HIGH [type=TYPE]
                                [order=ORDER] [zp=ZP]</P></TD>
		<TD><P CLASS="western">
			Filter the i<SUP>th</SUP> waveform. LOW and HIGH are the frequency limits. TYPE is
			"BP", "BR", "HP", "LP". It defaults to "BP". ORDER is [0-10]. It defaults to 3. ZP is true for
			zero-phase filter or false for causal. It defaults to false. If there is no wave[i] argument, the
                        filter command operates on all selected waveforms.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_hide_amplitude_scale"></A><B>hide_amplitude_scale</B></P>
		</TD><TD><P CLASS="western">Do not display the amplitude scales on the waveforms.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_hide_tags"></A><B>hide_tags</B></P>
		</TD><TD><P CLASS="western">Do not display waveform tags on the waveforms.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_independent_scale"></A><B>independent_scale</B></P>
		</TD><TD><P CLASS="western">Set the drawing height of waveforms independently.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_movement_none"></A><B>movement_none</B></P>
		</TD><TD><P CLASS="western">Do not allow waveform movement with the mouse.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_movement_x"></A><B>movement_x</B></P>
		</TD><TD><P CLASS="western">Permit waveform movement with the mouse in the x direction only.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_movement_y"></A><B>movement_y</B></P>
		</TD><TD><P CLASS="western">Permit waveform movement with the mouse in the y direction only.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_movement_xy"></A><B>movement_xy</B></P>
		</TD><TD><P CLASS="western">Permit waveform movement with the mouse in both directions.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_output"></A><B>output</B> wave[i] file=FILE [tmin=TMIN] [tmax=TMAX] [append=(true,false)]
                                [raw=(true,false)] [format=(css,sac,ascii)] [output_tables=(true,false)] [remark=REMARK]</P>
		</TD><TD><P CLASS="western">
			Write the waveform to the file FILE. TMIN and TMAX define a segment to write out. The file
			will be overwritten if append is false. If raw is true, all modifications to the waveform are removed before
			it is written, otherwise the current waveform values are written. If output_tables is true, the associated
			tables, origin, arrival, assoc, etc. are also written. The optional remark is written to as remark record.
			The defaults are append=true, raw=true, format=&quot;css&quot;, and output_tables=false.
			If there is no wave[i] argument, the output command writes out all selected waveforms.</P> </TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_page_up"></A><B>page_down</B></P></TD>
		<TD><P CLASS="western">Scroll the waveform window one scrollbar page-increment down.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_page_left"></A><B>page_left</B></P></TD>
		<TD><P CLASS="western">Scroll the waveform window one scrollbar page-increment left.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_page_right"></A><B>page_right</B></P></TD>
		<TD><P CLASS="western">Scroll the waveform window one scrollbar page-increment right.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_page_up"></A><B>page_up</B></P></TD>
		<TD><P CLASS="western">Scroll the waveform window one scrollbar page-increment up.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_partial_select"></A><B>partial_select</B></P></TD>
		<TD><P CLASS="western">Allow partial waveform selection with a left-mouse-button drag.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_paste"></A><B>paste</B></P></TD>
		<TD><P CLASS="western">Paste the contents of the paste buffer.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_position"></A><B>position</B> wave[i] x=X y=Y</P></TD>
		<TD><P CLASS="western">Position the first sample of the i<SUP>th</SUP> waveform at the plot coordinates (x,y).</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_position_crosshair"></A><B>position_crosshair</B> i=NUM x=X y=Y [notify=(true,false)]</P>
		</TD><TD><P CLASS="western">Position a crosshair cursor at X,Y. NUM is the crosshair index (1-10). If
		no NUM is specified, the first crosshair, NUM=1, is drawn. If notify is true (the default), cursor callbacks
		are made.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_position_time_window"></A><B>position_time_window</B> xmin=XMIN xmax=XMAX [label=LABEL]
			[draw_label=(true,false)] [notify=(true,false)]</P>
		</TD><TD><P CLASS="western">Position a time-window cursor at XMIN, XMAX. LABEL is a single lower case character. If
		no label is specified, the 'a' labeled time-window cursor is drawn. If notify is true (the default), cursor callbacks
		are made. If draw_label is false (the default is true), the label is not displayed.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_position_line_cursor"></A><B>position_line_cursor</B> x=X [label=LABEL]
			[notify=(true,false)]</P>
		</TD><TD><P CLASS="western">Position a vertical line-cursor at X. LABEL is a single upper case character. If
		no label is specified, the 'A' labeled line-cursor is drawn. If notify is true (the default), cursor callbacks
		are made.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_position_phase_line"></A><B>position_phase_line</B> x=X phase=PHASE [notify=(true,false)]</P>
		</TD><TD><P CLASS="western">Position a vertical phase-line-cursor at X. PHASE is the phase string.
		If notify is true (the default), cursor callbacks are made.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_print"></A><B>print</B> wave[i]</P></TD>
		<TD><P CLASS="western">
			List the member values of the i<SUP>th</SUP> waveform object in the form "member_name=value".</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_print"></A><B>print</B> TABLE[i]</P></TD>
		<TD><P CLASS="western">
			List the member values of the i<SUP>th</SUP> TABLE object in the form "member_name=value".</P>
		<PRE CLASS="western">
print arrival[3]
print origin[1]</PRE></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_print_window.print"></A><B>print_window.print</B></P></TD>
		<TD><P CLASS="western">
			Print the waveform window</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_print_window.set"></A><B>print_window.set</B> arg=ARG [arg=ARG ...]</P></TD>
		<TD><P CLASS="western">Set one or more printing parameter values. The printing parameters are:
		<DD CLASS="western">layout=(&quot;landscape&quot;, &quot;portrait&quot;)</DD>
		<DD CLASS="western">units=(&quot;inches&quot;, &quot;mm&quot;, &quot;points&quot;)</DD>
		<DD CLASS="western">paper=(&quot;Letter&quot;,&quot;Tabloid&quot;,&quot;Ledger&quot;,&quot;Executive&quot;,&quot;A3&quot;,&quot;A4&quot;,&quot;A5&quot;,&quot;B4&quot;,&quot;B5&quot;,&quot;A4&quot;)</DD>
		<DD CLASS="western">filename</DD>
		<DD CLASS="western">command</DD>
		<DD CLASS="western">left</DD>
		<DD CLASS="western">right</DD>
		<DD CLASS="western">top</DD>
		<DD CLASS="western">bottom</DD>
		<DD CLASS="western">width</DD>
		<DD CLASS="western">height</DD>
		<DD CLASS="western">axes_labels_font</DD>
		<DD CLASS="western">axes_labels_size</DD>
		<DD CLASS="western">axes_labels_type</DD>
		<DD CLASS="western">tick_labels_font</DD>
		<DD CLASS="western">tick_labels_size</DD>
		<DD CLASS="western">tick_labels_type</DD>
		<DD CLASS="western">tag_labels_font</DD>
		<DD CLASS="western">tag_labels_size</DD>
		<DD CLASS="western">tag_labels_type</DD>
		<DD CLASS="western">arrival_labels_font</DD>
		<DD CLASS="western">arrival_labels_size</DD>
		<DD CLASS="western">arrival_labels_type</DD>
		<DD CLASS="western">main_title_font</DD>
		<DD CLASS="western">main_title_size</DD>
		<DD CLASS="western">main_title_type</DD>
		<DD CLASS="western">ink=(&quot;B_&amp;_W&quot;, &quot;Color&quot;)
		<DD CLASS="western">arrival_placement=(&quot;Normal&quot;, &quot;Close&quot;)
		<DD CLASS="western">line_width=(0,1,2,3,4,5)
		<DD CLASS="western">waveform_scale=(&quot;Full&quot;, &quot;Half&quot;)
		<DD CLASS="western">tag_placement=(&quot;Standard&quot;, &quot;Left&quot;)
		<P CLASS="western">For example:</P>
<PRE CLASS="western">
print_window.set filename=&quot;geotool.ps&quot; command=&quot;&quot;   # print to a file
print_window.set layout=&quot;landscape&quot; paper=&quot;A4&quot; axes_labels_size=14 line_width=2
print_window.print
</PRE>
	</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_promote_selected_waveforms"></A><B>promote_selected_waveforms</B></P>
		</TD><TD><P CLASS="western">Move the selected waveforms to the top of the window.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_normal_polarity"></A><B>normal_polarity</B> [ wave[i] ]</P></TD>
		<TD><P CLASS="western">
			Display the i<SUP>th</SUP> waveform with the normal polarity. (Do not multiply the
			values by -1.) If there is no wave[i] argument, the normal_polarity command operates on all
			selected waveforms.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_remove_all_cursors"></A><B>remove_all_cursors</B></P>
		</TD><TD><P CLASS="western">Remove all cursors from the window.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_remove_all_methods"></A><B>remove_all_methods</B> [ wave[i] ]</P>
		</TD>
		<TD><P CLASS="western">
			Remove all processing methods that have altered the i<SUP>th</SUP> waveform. If there is no wave[i] argument, the
			remove_all_methods command operates on all selected waveforms.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_remove_con_decon"></A><B>remove_con_decon</B> [ wave[i] ]</P></TD>
		<TD><P CLASS="western">
			Remove all convolution and deconvolution operations from the i<SUP>th</SUP> waveform. If there is no wave[i] argument, the
			remove_con_decon command operates on all selected waveforms.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_remove_mean"></A><B>remove_mean</B> [ wave[i] ]</P></TD>
		<TD><P CLASS="western">
			Demean the i<SUP>th</SUP> waveform. If there is no wave[i] argument, the
			remove_mean command operates on all selected waveforms.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_restore_mean"></A><B>restore_mean</B> [ wave[i] ]</P></TD>
		<TD><P CLASS="western">
			Restore the mean to the i<SUP>th</SUP> waveform. If there is no wave[i] argument, the
			restore_mean command operates on all selected waveforms.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P CLASS="western"><A NAME="ww_reverse_polarity"></A><B>reverse_polarity</B> [ wave[i] ]</P></TD>
		<TD><P CLASS="western">
			Display the i<SUP>th</SUP> waveform with the reversed polarity. (Multiply the
			values by -1.) If there is no wave[i] argument, the reverse_polarity command operates on all selected waveforms.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_rotate"></A><B>rotate</B> wave[i] azimuth=AZIMUTH [incidence=INCIDENCE</P></TD>
		<TD><P CLASS="western">
			Rotate the i<SUP>th</SUP> waveform and it's associated component waveforms to the specified station-to-source AZIMUTH,
			and INCIDENCE. The input waveform wave[i] can be any of the three components. The INCIDENCE is measured from vertical and defaults to
			90. degrees. AZIMUTH and INCIDENCE are in degrees.  If only the horizontal components are available, then the INCIDENCE is forced to
			be 90.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_scale_down"></A><B>scale_down</B></P>
		</TD><TD><P CLASS="western">Decrease the plotting scale for all waveforms.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_scale_up"></A><B>scale_up</B></P>
		</TD><TD><P CLASS="western">Increase the plotting scale for all waveforms.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_scroll_down"></A><B>scroll_down</B></P>
		</TD><TD><P CLASS="western">Scroll the waveform window one scrollbar increment down.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_scroll_left"></A><B>scroll_left</B></P>
		</TD><TD><P CLASS="western">Scroll the waveform window one scrollbar increment to the left.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_scroll_right"></A><B>scroll_right</B></P>
		</TD><TD><P CLASS="western">Scroll the waveform window one scrollbar increment to the right.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_scroll_up"></A><B>scroll_up</B></P>
		</TD><TD><P CLASS="western">Scroll the waveform window one scrollbar increment up.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_select"></A><B>select</B> arrival[i]</P></TD>
		<TD><P CLASS="western">Select the i<SUP>th</SUP> arrival.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_select"></A><B>select</B> origin[i]</P></TD>
		<TD><P CLASS="western">Select the i<SUP>th</SUP> origin.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_select"></A><B>select</B> wave[i]</P></TD>
		<TD><P CLASS="western">Select the i<SUP>th</SUP> waveform.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_select"></A><B>select</B> NUM</P></TD>
		<TD><P CLASS="western">Select waveform by its position from the top, starting at one.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_select"></A><B>select</B> [sta=STA] [chan=CHAN] [wfid=WFID] [orid=ORID]</P></TD>
		<TD><P CLASS="western">Select waveforms that match the specified attributes.</P>
		<PRE CLASS="western">select sta=&quot;AK04&quot; chan=&quot;BHZ&quot;</PRE></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_select_all"></A><B>select_all</B></P></TD>
		<TD><P CLASS="western">Select all waveforms.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_select_all_arrivals"></A><B>select_all_arrivals</B></P></TD>
		<TD><P CLASS="western">Select all arrivals.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_select_visible"></A><B>select_visible</B></P></TD>
		<TD><P CLASS="western">Select all waveforms that are currently visible in the window.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_select_visible_z"></A><B>select_visible_z</B></P></TD>
		<TD><P CLASS="western">Select currently visible z-component waveforms.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_select_visible_horz"></A><B>select_visible_horz</B></P></TD>
		<TD><P CLASS="western">Select currently visible horizontal component waveforms.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_set_axes_labels"></A><B>set_axes_labels</B> [x_label=LABEL] [y_label=LABEL] [title=TITLE]</P></TD>
		<TD><P CLASS="western">Set the axes labels and plot title.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_set_current_scale"></A><B>set_current_scale</B> height=PIXELS [selected_only=(true,false)] [visible_only=(true,false)]</P></TD>
		<TD><P CLASS="western">Set the waveform pixel height for all waveforms, or only selected waveform if selected_only is true, or only visible waveforms
		if visible_only is true.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_set_default_order"></A><B>set_default_order</B></P></TD>
		<TD><P CLASS="western">Make the current waveform order the default sort order.
		The command sort_waveforms order=&quot;default_order&quot; will
		display the waveforms in this order.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_set_layout"></A><B>set_layout</B> height=PIXELS separation=PIXELS</P></TD>
		<TD><P CLASS="western">Set the waveform screen layout. It will also be saved to disk.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_set_working_orid"></A><B>set_working_orid</B> orid=ORID</P></TD>
		<TD><P CLASS="western">Set the working orid.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_sort_waveforms"></A><B>sort_waveforms</B> order=ORDER</P></TD>
		<TD><P CLASS="western">Sort waveforms vertically by ORDER.</P>
		<PRE CLASS="western">
sort_waveforms order=&quot;default_order&quot; # use the default order
sort_waveforms order=&quot;file_order&quot;    # sort by wfdisc file order
sort_waveforms order=&quot;distance&quot;      # sort by distance
sort_waveforms order=&quot;time/sta/chan&quot; # sort by time, sta and chan
sort_waveforms order=&quot;sta/chan&quot;      # sort by sta and chan
sort_waveforms order=&quot;chan/sta&quot;      # sort by chan and sta
sort_waveforms order=&quot;back_azimuth&quot;  # sort by back azimuth</PRE>
	</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_space_more"></A><B>space_more</B></P>
		</TD><TD><P CLASS="western">Increase the vertical space between waveforms.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_space_less"></A><B>space_less</B></P>
		</TD><TD><P CLASS="western">Decrease the vertical space between waveforms.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_tag_contents"></A><B>tag_contents.set</B> [tag=TAG] [text=TEXT] [selected_only=(true,false)]</P>
		</TD><TD><P CLASS="western">Set the tag contents. If selected_only is true (the default is false), change the tags of selected
		waveforms only. The TAG is a string list of tag components as they are listed in the Tag Contents popup window. For example:</P>
		<PRE CLASS="western">
tag_contents.set tag=&quot;station,channel,filter(low high)&quot; selected_only=true
</PRE>
	</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_time_scale_epoch"></A><B>time_scale_epoch</B></P>
		</TD><TD><P CLASS="western">Label the time axis with epochal time values.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_time_scale_hms"></A><B>time_scale_hms</B></P>
		</TD><TD><P CLASS="western">Label the time axis as hh::mm::ss.s</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_time_scale_seconds"></A><B>time_scale_seconds</B></P>
		</TD><TD><P CLASS="western">Label the time axis in seconds.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_time_scale_variable"></A><B>time_scale_variable</B></P>
		</TD><TD><P CLASS="western">Label the time axis in seconds, minutes, or hours.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_time_window"></A><B>time_window</B> [arid=NUM] [lead=SECS] [lag=SECS] [phase=PHASE]
		[tbeg=TIME] [tend=TIME] [duration=SECS] [letter=LETTER]</P>
		</TD><TD><P CLASS="western">Position a time-window cursor. If LETTER is not specified, position the 'a'
		time-window cursor. The limits of the time-window can be specified with either the arid, the phase, or tbeg and tend
		or duration. The lead defaults to 1.0 seconds and the lag defaults to 4.0 seconds. If phase is specified, the
		first arrival with that phase name is used for the time window.</P>
		<PRE CLASS="western">
time_window arid=34259 lead=5. lag=10.
time_window tbeg=1237836841.04 duration=10.
time_window tbeg=&quot;2009Mar23 19:34:01.04&quot; duration=30.
time_window tbeg=1237836841.04 tend=1237837390.
time_window phase=&quot;P&quot; lead=2 lag=5</PRE>
</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_time_zoom"></A><B>time_zoom</B> [arid=NUM] [lead=SECS] [lag=SECS] [phase=PHASE]
		[tbeg=TIME] [tend=TIME] [duration=SECS]</P>
		</TD><TD><P CLASS="western">Set the plot time limits. The plot limits can be specified with either the arid, the phase,
		or tbeg and tend or duration. The lead default to 1.0 seconds and the lag defaults to 4.0 seconds. If phase is specified, the
		first arrival with that phase name is used to set the plot limits.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_total_select"></A><B>total_select</B></P></TD>
		<TD><P CLASS="western">Allow only total waveform selection with the mouse.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_unfilter"></A><B>unfilter</B> wave[i]</P></TD>
		<TD><P CLASS="western">Remove the last filter applied to the i<SUP>th</SUP> waveform.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_unfilter_all"></A><B>unfilter_all</B></P></TD>
		<TD><P CLASS="western">Remove the last filter applied to the each waveform.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_uniform_scale"></A><B>uniform_scale</B></P>
		</TD><TD><P CLASS="western">Draw all waveforms using the same vertical scaling.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_unrotate"></A><B>unrotate</B> wave[i]</P></TD>
		<TD><P CLASS="western">Unrotate the i<SUP>th</SUP> waveform and it's associated component waveforms.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_unzoom"></A><B>unzoom</B></P></TD>
		<TD><P CLASS="western">Zoom-out to the previous plot limits.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_unzoom_all"></A><B>unzoom_all</B></P></TD>
		<TD><P CLASS="western">Display the plot with the original limits.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_unzoom_horizontal_all"></A><B>unzoom_horizontal_all</B></P></TD>
		<TD><P CLASS="western">Display the plot with the original x limits.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_unzoom_vertical_all"></A><B>unzoom_vertical_all</B></P></TD>
		<TD><P CLASS="western">Display the plot with the original y limits.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_update_tag"></A><B>update_tag</B> wave[i]</P></TD>
		<TD><P CLASS="western">Update the tag of i<SUP>th</SUP> waveform. This would
			normally be called after making changes to the tag contents with
			the tag_contents commands.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_waveform_color"></A><B>waveform_color</B> [code=CODE] [colors=COLORS]</P></TD>
		<TD><P CLASS="western">Set the waveform color code and/or the color values.
		The CODE can be &quot;uniform&quot;, &quot;unique&quot;,
		&quot;station&quot;, &quot;channel&quot;, &quot;network&quot;, or &quot;origin&quot;.
		The COLORS is a list of color names or red,green,blue values.</P>
		<PRE CLASS="western">
waveform_color code=&quot;network&quot;
waveform_color colors=&quot;sky blue,orange,189,85,214,red,173,48,99&quot;</PRE>
		<P CLASS="western">A change in the CODE value will effect the current waveforms. A change in the COLORS will not
		effect waveforms that are currently displayed. It will effect all subsequent waveforms. The color settings
		are saved to disk.</P>
	</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_zoom"></A><B>zoom</B> xmin=XMIN xmax=XMAX ymin=YMIN ymax=YMAX [remember=(true,false)]</P></TD>
		<TD><P CLASS="western">Display the plot with the specified x and y limits. If remember is true (the default is false), then this
		zoom will be saved in the zoom-stack, which means that a subsequent zoom and unzoom will return to these limits.</P></TD>
	</TR>
	<TR VALIGN=TOP>
		<TD><P CLASS="western"><A NAME="ww_zoom_on_waveform"></A><B>zoom_on_waveform</B> [ wave[i] ]</P></TD>
		<TD><P CLASS="western">Zoom-in to display only the i<SUP>th</SUP> waveform. If there is no wave[i] argument, the
                        zoom_on_waveform command zooms to display all selected waveforms</P></TD>
	</TR>
	</TABLE>

</DL>
<H1 CLASS="western"><A NAME="Waveform Window Variables"></A>14.0 Waveform Window Variables</H1>
<DL>
<P CLASS="western">
The following variables are available in any window that displays waveforms. For windows other than the first waveform
window, prefix the variable name with the window name. For example,</P>
<DL>
<PRE CLASS="western">
print time_window[1].tmin time_window[1].duration
copy fk_multi_band.beam_plot.wave[1]
print tablequery.arrival[1]
x = correlation.plot2.time_window[1].tmin
</PRE>
</DL>
<P CLASS="western">
The waveform window variables are listed below. Array indices always start at 1.</P>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0 FRAME=VOID RULES=ROWS>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
		<P CLASS="western"><A HREF="crosshair[i]"></A><B>crosshair[i]</B></P></TD>
		<TD WIDTH=75%>
		<P CLASS="western">The i<SUP>th</SUP> crosshair object. Members are crosshair[i].x and crosshair[i].y.</P></TD>
	</TR><TR VALIGN=TOP>
		<TD><P CLASS="western"><A HREF="line_cursor[i]"></A><B>line_cursor[i]</B></P></TD>
		<TD><P CLASS="western">The i<SUP>th</SUP> line cursor object. Members are line_cursor[i].x and line_cursor[i].label.</P></TD>
	</TR><TR VALIGN=TOP>
		<TD><P CLASS="western"><A HREF="num_crosshairs"></A><B>num_crosshairs</B></P></TD>
		<TD><P CLASS="western">The number of crosshair cursors that are displayed.</P></TD>
	</TR><TR VALIGN=TOP>
		<TD><P CLASS="western"><A HREF="num_line_cursors"></A><B>num_line_cursors</B></P></TD>
		<TD><P CLASS="western">The number of line cursors that are displayed.</P></TD>
	</TR><TR VALIGN=TOP>
		<TD><P CLASS="western"><A HREF="num_phase_lines"></A><B>num_phase_lines</B></P></TD>
		<TD><P CLASS="western">The number of phase-line cursors that are displayed.</P></TD>
	</TR><TR VALIGN=TOP>
		<TD><P CLASS="western"><A HREF="num_time_windows"></A><B>num_time_windows</B></P></TD>
		<TD><P CLASS="western">The number of time-window cursors that are displayed.</P></TD>
	</TR><TR VALIGN=TOP>
		<TD><P CLASS="western"><A HREF="phase_line[i]"></A><B>phase_line[i]</B></P></TD>
		<TD><P CLASS="western">The i<SUP>th</SUP> phase-line cursor object. Members are phase_line[i].x and phase_line[i].label.</P></TD>
	</TR><TR VALIGN=TOP>
		<TD><P CLASS="western"><A HREF="plot_xmax"></A><B>plot_xmax</B></P></TD>
		<TD><P CLASS="western">The maximum x value (time) of the plot.</P></TD>
	</TR><TR VALIGN=TOP>
		<TD><P CLASS="western"><A HREF="plot_xmin"></A><B>plot_xmin</B></P></TD>
		<TD><P CLASS="western">The minimum x value (time) of the plot.</P></TD>
	</TR><TR VALIGN=TOP>
		<TD><P CLASS="western"><A HREF="plot_ymax"></A><B>plot_ymax</B></P></TD>
		<TD><P CLASS="western">The maximum y value of the plot.</P></TD>
	</TR><TR VALIGN=TOP>
		<TD><P CLASS="western"><A HREF="plot_ymin"></A><B>plot_ymin</B></P></TD>
		<TD><P CLASS="western">The minimum y value of the plot.</P></TD>
	</TR><TR VALIGN=TOP>
		<TD><P CLASS="western"><A HREF="sel_TABLE[i]"></A><B>sel_TABLE[i]</B></P></TD>
		<TD><P CLASS="western">The i<SUP>th</SUP> selected table object, where TABLE is a CSS table name such as arrival, origin, etc.</P></TD>
	</TR><TR VALIGN=TOP>
		<TD><P CLASS="western"><A HREF="sel_TABLE.size"></A><B>sel_TABLE.size()</B></P></TD>
		<TD><P CLASS="western">The number of selected table objects in the array.</P></TD>
	</TR><TR VALIGN=TOP>
		<TD><P CLASS="western"><A HREF="sel_wave[i]"></A><B>sel_wave[i]</B></P></TD>
		<TD><P CLASS="western">The i<SUP>th</SUP> selected waveform.</P></TD>
	</TR><TR VALIGN=TOP>
		<TD><P CLASS="western"><A HREF="sel_wave.size"></A><B>sel_wave.size()</B></P></TD>
		<TD><P CLASS="western">The number of selected waveforms.</P></TD>
	</TR><TR VALIGN=TOP>
		<TD><P CLASS="western"><A HREF="TABLE[i]"></A><B>TABLE[i]</B></P></TD>
		<TD><P CLASS="western">The i<SUP>th</SUP> table object, where TABLE is a CSS table name such as arrival, origin, etc.</P></TD>
	</TR><TR VALIGN=TOP>
		<TD><P CLASS="western"><A HREF="TABLE.size"></A><B>TABLE.size()</B></P></TD>
		<TD><P CLASS="western">The number of selected table objects.</P></TD>
	</TR><TR VALIGN=TOP>
		<TD><P CLASS="western"><A HREF="time_window[i]"></A><B>time_window[i]</B></P></TD>
		<TD><P CLASS="western">The i<SUP>th</SUP> time-window cursor object. Members are time_window[i].tmin, time_window[i].tmax,
		and time_window[i].duration.</P></TD>
	</TR><TR VALIGN=TOP>
		<TD><P CLASS="western"><A HREF="wave[i]"></A><B>wave[i]</B></P></TD>
		<TD><P CLASS="western">The i<SUP>th</SUP> waveform.</P></TD>
	</TR><TR VALIGN=TOP>
		<TD><P CLASS="western"><A HREF="wave.size"></A><B>wave.size()</B></P></TD>
		<TD><P CLASS="western">The number of waveforms.</P></TD>
	</TR>
	</TABLE>
</DL>
<H1 CLASS="western"><A NAME="Windows that Display Tables"></A>15.0 Windows that Display Tables</H1>
<DL>
<P CLASS="western">
There are two different types of window components that display tabular data, 
the <A HREF="script_appendices.html#A_Table">Table</A> component and the
<A HREF="script_appendices.html#A_CSSTable">CSSTable</A> component. The Table component is the more general
type. The column names are specified and then rows are added with the <A HREF="add_row">add_row</A> command. The CSSTable type is a
subclass of Table that displays <A HREF="#Database Tables">database table objects</A>. The CSSTable component
automatically displays all members of a table object as table columns. Options are available to restrict the
object members that are displayed. The format can be also be specified for each table object member.
</P>
<P CLASS="western"><A NAME="Table Commands"><B>Table Commands</B></P>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0 FRAME=VOID RULES=ROWS>
	<TR VALIGN=TOP>
		<TD WIDTH=40%>
		<P CLASS="western"><A NAME="select_row"></A><B>add_row</B> col1 col2 col3 ...</P> </TD>
		<TD WIDTH=60%>
		<P CLASS="western">Add a row to the table. The arguments col1, col2, etc. can be strings or variables.
		The default format for printing real variables is %.7g for single precision and %.15g for
		double precision. Format specifications enclosed within parenthesis can follow variable names. If the
		number of add_row arguments is less that the number of table columns, the missing columns for the
		row will be blank. If there are more add_row arguments than the number of table columns, the excess
		arguments are ignored.  Examples:</P>
<PRE CLASS="western">
...
foreach(wave, w)    # loop over all waveforms
    table_example.table.add_row w.sta w.chan w.mean(%.3g)  # add a row for each waveform
endfor
...
detections.table.add_row num i kmax lo[kmax] hi[kmax] snr_max(%.2f)\
		 azimuth(%.2f) slowness(%.2f) time(%t)
</PRE>
	</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P CLASS="western"><A NAME="copy_all"></A><B>copy_all</B></P>
		</TD>
		<TD>
			<P CLASS="western">Copy all rows of the table to the paste buffer. This is the paste buffer for
			the X-Window system, so the table contents can be pasted into another Table component within
			geotool and also into another program as a text string.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P CLASS="western"><A NAME="copy_selected_columns"></A><B>copy_selected_columns</B></P>
		</TD>
		<TD>
			<P CLASS="western">Copy all selected columns to the paste buffer. Use the select_column command
			to select columns prior to this command.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P CLASS="western"><A NAME="copy_selected_rows"></A><B>copy_selected_rows</B></P>
		</TD>
		<TD>
			<P CLASS="western">Copy all selected rows to the paste buffer. Use the select_row command
			to select rows prior to this command.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P CLASS="western"><A NAME="paste"></A><B>paste</B></P>
		</TD>
		<TD>
			<P CLASS="western">Paste the contents of the paste buffer into this table.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P CLASS="western"><A NAME="print_all"></A><B>print_all</B></P>
		</TD>
		<TD>
			<P CLASS="western">Print the all rows to the terminal or to a print file, if one
			has been specified with the printOpen command.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P CLASS="western"><A NAME="print_selected_rows"></A><B>print_selected_rows</B></P>
		</TD>
		<TD>
			<P CLASS="western">Print the selected rows to the terminal or to a print file, if one
			has been specified with the printOpen command.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P CLASS="western"><A NAME="print_selected_columns"></A><B>print_selected_columns</B></P>
		</TD>
		<TD>
			<P CLASS="western">Print the selected columns to the terminal or to a print file, if one
			has been specified with the printOpen command.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P CLASS="western"><A NAME="promote_selected_columns"></A><B>promote_selected_columns</B></P>
		</TD>
		<TD>
			<P CLASS="western">Move selected columns to the left side of the table.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P CLASS="western"><A NAME="promote_selected_rows"></A><B>promote_selected_rows</B></P>
		</TD>
		<TD>
			<P CLASS="western">Move selected rows to the top of the table.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P CLASS="western"><A NAME="remove_all_rows"></A><B>remove_all_rows</B></P>
		</TD>
		<TD>
			<P CLASS="western">Remove all rows from the table.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P CLASS="western"><A NAME="reverse_order"></A><B>reverse_order</B></P>
		</TD>
		<TD>
			<P CLASS="western">Reverse the order of the rows.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P CLASS="western"><A NAME="select_all"></A><B>select_all</B></P>
		</TD>
		<TD>
			<P CLASS="western">Select all rows.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P CLASS="western"><A NAME="save_all_rows"></A><B>save_all_rows</B> file=FILE [append=(true,false)]</P>
		</TD>
		<TD>
			<P CLASS="western">Print all rows to a file. The default for append is false.<P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P CLASS="western"><A NAME="save_selected_rows"></A><B>save_selected_rows</B> file=FILE [append=(true,false)]</P>
		</TD>
		<TD>
			<P CLASS="western">Print the selected rows to a file. The default for append is false.<P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P CLASS="western"><A NAME="save_selected_columns"></A><B>save_selected_columns</B> file=FILE [append=(true,false)]</P>
		</TD>
		<TD>
			<P CLASS="western">Print the selected columns to a file. The default for append is false.<P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P CLASS="western"><A NAME="select_row"></A><B>select_row</B> or <B>deselect_row</B> NUM</P>
		</TD>
		<TD>
			<P CLASS="western">Select or deselect row number NUM. The top row is number 1.<P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P CLASS="western"><A NAME="select_row2"></A><B>select_row</B> or <B>deselect_row</B> COLUMN_LABEL=VALUE COLUMN_LABEL=VALUE...</P>
		</TD>
		<TD>
			<P CLASS="western">Select or deselect rows by one or more columns values. For example:</P>
<PRE CLASS="western">select_row sta=&quot;VRAC&quot; chan=&quot;BHZ&quot;</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P CLASS="western"><A NAME="select_row3"></A><B>select_row</B> or <B>deselect_row</B> COLUMN_LABEL=[MIN_VALUE,MAX_VALUE]...</P>
		</TD>
		<TD>
			<P CLASS="western">Select or deselect rows by one or more column values within limits, or equals to limits. For example:</P>
<PRE CLASS="western">select_row sta=&quot;fines&quot; amp=[100.,1000] per=[0.3,0.7]</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P CLASS="western"><A NAME="select_row4"></A><B>select_row</B> or <B>deselect_row</B> COLUMN_LABEL=(MIN_VALUE,MAX_VALUE)...</P>
		</TD>
		<TD>
			<P CLASS="western">Select or deselect rows by one or more column values within limits, but not equal to limits. For example:</P>
<PRE CLASS="western">select_row sta=&quot;fines&quot; amp=(0., 100.]</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P CLASS="western"><A NAME="select_column"></A><B>select_column</B> or <B>deselect_column</B> COLUMN_LABEL COLUMN_LABEL...</P>
		</TD>
		<TD>
			<P CLASS="western">Select or deselect one or more columns.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P CLASS="western"><A NAME="set_cell"></A><B>set_cell</B> row=ROW column=COL value=VALUE</P>
		</TD>
		<TD>
			<P CLASS="western">Set the contents of the cell ar row ROW and column COL. Rows and columns are numbered from 1.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P CLASS="western"><A NAME="sort"></A><B>sort</B> or <B>sort_up</B> [column=COLUMNS]</P>
		</TD>
		<TD>
			<P CLASS="western">Sort rows by the specified column(s), increasing from top to bottom. The
			COLUMNS can be one or more column names, separated by a comma. For example:</P>
<PRE CLASS="western">sort column=&quot;sta,chan,time&quot;</PRE>
			<P CLASS="western">If the column argument is not input, then sort by the selected columns, from left to
			right.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P CLASS="western"><A NAME="sort_down"></A><B>sort_down</B> [column=COLUMNS]</P>
		</TD>
		<TD>
			<P CLASS="western">Sort rows by the specified column(s), decreasing from top to bottom. The
                        COLUMNS can be one or more column names, separated by a comma. If the column argument is not input,
			then sort by the selected columns, from left to right.</P>
		</TD>
	</TR>
	</TABLE>

<P><BR></P>
<P CLASS="western"><A NAME="CSSTable Commands"><B>Table Variables</B></P>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0 FRAME=VOID RULES=ROWS>
	<TR VALIGN=TOP>
		<TD WIDTH=30%>
		<P CLASS="western"><A NAME="num_rows"></A><B>num_rows</B></P>
		</TD>
		<TD WIDTH=70%>
		<P CLASS="western">The number of rows in the table.</P>
		</TD>
	</TR>
	<TR>
		<TD>
		<P CLASS="western"><A NAME="num_columns"></A><B>num_columns</B></P>
		</TD>
		<TD>
		<P CLASS="western">The number of columns in the table.</P>
		</TD>
	</TR>
	<TR>
		<TD>
		<P CLASS="western"><A NAME="num_sel_rows"></A><B>num_sel_rows</B></P>
		</TD>
		<TD>
		<P CLASS="western">The number of selected rows.</P>
		</TD>
	</TR>
	<TR>
		<TD>
		<P CLASS="western"><A NAME="num_sel_columns"></A><B>num_sel_columns</B></P>
		</TD>
		<TD>
		<P CLASS="western">The number of selected columns.</P>
		</TD>
	</TR>
	<TR>
		<TD>
		<P CLASS="western"><A NAME="row[i]"></A><B>row[i]</B></P>
		</TD>
		<TD>
		<P CLASS="western">The i<SUP>th</SUP> row as a comma-delimited string.</P>
		<P CLASS="western">The two-argument foreach command will operate on the rows of a table. For example:</P>
<PRE CLASS="western">
foreach(plugins.table.row, r)
    print r.name
endfor</PRE>
		</TD>
	</TR>
	<TR>
		<TD>
		<P CLASS="western"><A NAME="column[i]"></A><B>column[i]</B></P>
		</TD>
		<TD>
		<P CLASS="western">The i<SUP>th</SUP> column as a comma-delimited string. For example:</P>
<PRE CLASS="western">set s = table_name.column[i]
foreach(s)
...
endfor</PRE>
		</TD>
	</TR>
	<TR>
		<TD>
		<P CLASS="western"><A NAME="cell[i][j]"></A><B>cell[i][j]</B></P>
		</TD>
		<TD>
		<P CLASS="western">The cell value for the i<SUP>th</SUP> row and j<SUP>th</SUP> column.</P>
		</TD>
	</TR>
	<TR>
		<TD>
		<P CLASS="western"><A NAME="row[i]2"></A><B>row[i].COLUMN_NAME</B></P>
		</TD>
		<TD>
		<P CLASS="western">A cell value from the i<SUP>th</SUP> row.</P>
		</TD>
	</TR>
	<TR>
		<TD>
		<P CLASS="western"><A NAME="sel_row[i]"></A><B>sel_row[i]</B></P>
		</TD>
		<TD>
		<P CLASS="western">The i<SUP>th</SUP> selected row as a comma-delimited string.</P>
		<P CLASS="western">The two-argument foreach command will operate on the selected rows of a table.</P>
<PRE CLASS="western">
foreach(origin_beams.table.sel_row, r)
    print r.net
endfor
</PRE>
		</TD>
	</TR>
	<TR>
		<TD>
		<P CLASS="western"><A NAME="sel_row[i]2"></A><B>sel_row[i].COLUMN_NAME</B></P>
		</TD>
		<TD>
		<P CLASS="western">A column value from the i<SUP>th</SUP> selected row.</P>
		</TD>
	</TR>
	</TABLE>

<P><BR></P>
<P CLASS="western"><A NAME="CSSTable Commands"><B>CSSTable Commands</B></P>
<P CLASS="western">
The CSSTable component is a subclass of the Table component, so all of the commands and variables
listed above for the Table component are also valid for the CSSTable component. In addition, the
following commands and variables are used with the CSSTable component.</P>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0 FRAME=VOID RULES=ROWS>
	<TR VALIGN=TOP>
		<TD WIDTH=30%>
		<P CLASS="western"><A NAME="add_record"></A><B>add_record</B> TABLE_OBJECT</P>
		</TD>
		<TD WIDTH=70%>
		<P CLASS="western">Add a row to the table.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH>
		<P CLASS="western"><A NAME="clear"></A><B>clear</B></P>
		</TD>
		<TD WIDTH>
		<P CLASS="western">Remove all records from the table. Remove the column labels.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH>
		<P CLASS="western"><A NAME="list"></A><B>list</B></P>
		</TD>
		<TD WIDTH>
		<P CLASS="western">Redisplay the table.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH>
		<P CLASS="western"><A NAME="remove_all_records"></A><B>remove_all_records</B></P>
		</TD>
		<TD WIDTH>
		<P CLASS="western">Remove all records from the table. Keep the column labels.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH>
		<P CLASS="western"><A NAME="select_record"></A><B>select_record</B> NUM</P>
		</TD>
		<TD WIDTH>
		<P CLASS="western">Select a row.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH>
		<P CLASS="western"><A NAME="set_type"></A><B>set_type</B> table=TABLE_TYPE [extra="NAME1,FORMAT1,NAME2,FORMAT2,..."]
			[display_list=&quot;MEMBER1,MEMBER2,...&quot;]</P>
		</TD>
		<TD WIDTH>
		<P CLASS="western">Set the type of a new CSSTable. TABLE_TYPE is one of the <A HREF="#Database Tables">database table object</A>
		names. The extra argument can be used to add additional columns to the table. The display_list argument can be used to specify
		a subset of the table members to be displayed. If it is not used, all of the members of the table object will be displayed as
		columns.</P>
		</TD>
	</TR>
	</TABLE>
<P CLASS="western"><A NAME="CSSTable Variables"><B>CSSTable Variables</B></P>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0 FRAME=VOID RULES=ROWS>
	<TR VALIGN=TOP>
		<TD WIDTH=30%>
		<P CLASS="western"><A NAME="getType"></A><B>getType</B></P>
		</TD>
		<TD WIDTH=70%>
		<P CLASS="western">Return the table type.</P>
		</TD>
	</TR>
	</TABLE>
<P><BR></P>
</DL>
<H1 CLASS="western"><A NAME="Command Line Arguments"></A>16.0 Command Line Arguments</H1>
<DL>
<P CLASS="western">There are several command line arguments that add to the versatility of
the program. The '-i' argument runs the program without graphics. The 'parse=' argument
inputs initial scripting commands. The 'window=' argument causes a window other than the
waveform window to be displayed first. The initialization script INSTALLATION_DIR/scripts/init/cmdline
provides a means of defining and processing any number of additional command line arguments.</P>

<P CLASS="western"><A NAME="geotool -i"><B>geotool -i</B></P>
<P CLASS="western">
The command line argument -i causes the program to run without displaying the graphical interface.
All scripting commands are processed as if the interface were visible. This mode of execution can
be used to generate output when no user interaction with the interface is needed. For example,
the following script reads some waveforms, filters the waveforms, and writes a PostScript file of
the waveform window.
</P>
<DL>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
geotool -i &lt;&lt;$
read &quot;data/tutorial/25454488.wfdisc&quot;
select_all
filter low=0.5 high=3.0
print_window.set command=&quot;&quot; filename=&quot;geotool.ps&quot;
print_window.print
quit
$
</PRE></TD></TR></TABLE>
</DL>
<P CLASS="western">
A second example reads a file that can be in CSS, SAC, GSE or ASCII format and converts the data to
the requested format.</P>
<DL>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
geotool -i &lt;&lt;$
read &quot;DBIC.BHE.2.sac&quot;
select_all
output file=&quot;DBIC.wfdisc&quot; append=false output_tables=true format=&quot;css&quot;
quit
$
</PRE></TD></TR></TABLE>
</DL>
<P CLASS="western">
All command line arguments can be referenced as variables in the geotool scripting language. For example,
the script above could be rewritten to obtain the input file, the output file, and other arguments from the command line as:</P>
<DL>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
geotool -i in=&quot;DBIC.BHE.2.sac&quot; out=&quot;DBIC.wfdisc&quot; append=false tables=true format=&quot;css&quot; &lt;&lt;$
read in
select_all
output file=out append=append output_tables=tables format=format
quit
$
</PRE></TD></TR></TABLE>
</DL>
<P CLASS="western">
Taking this one step further, the script could be encapsulated within a shell sh script. If a file named "gconvert"
is created with the lines shown below, then the format conversion task can be achieved with the single line
<DL>
<PRE CLASS="western">
sh gconvert in=&quot;DBIC.BHE.2.sac&quot; out=&quot;DBIC.wfdisc&quot; tables=true
</PRE>
</DL>

<P CLASS="western">The file &quot;gconvert&quot; is:</P>
<DL>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
#!/bin/sh

# usage: gconvert in= out= [append=(true,false)] [tables=(true,false)] [format=(css,sac,ascii)]
# execute geotool with the no-graphics '-i' option
# pass geotool the arguments from this sh script: '$*'
# redirect the standard input to read the geotool script commands

geotool -i $* &lt;&lt;%

if( !defined(in) )
    print &quot;missing argument 'in='&quot;
    quit
endif

if( !defined(out) )
    print &quot;missing argument 'out='&quot;
    quit
endif

if( !defined(append) )
    setb append=false
endif

if( !defined(format) )
    set format=&quot;css&quot;  # this is the output format
endif

if( !defined(tables) )
    set tables=false
endif

read in
select_all
output file=out append=append output_tables=tables format=format
quit
</PRE></TD></TR></TABLE>
</DL>
<P CLASS="western"><A NAME="geotool parse="><B>geotool parse=</B></P>
<P CLASS="western">
The 'parse=' command line argument can be used to instruct the program to parse a file or to parse a
command string. This command line argument can be used with or without the '-i' argument. The 'parse='
argument can also be used repeatedly, in which case the arguments are processed from left to right. Other
arguments will be available to the geotool script within the 'parse=' file. For
example, if the file 'ex1' contains the lines</P>
<DL>
<PRE CLASS="western">
read in
select_all
sort_waveforms order=&quot;distance&quot;
filter low=low high=high
deselect_all
</PRE>
</DL>
<P CLASS="western">
then the following command will read the waveforms, apply the sort and the filter, and then wait for user
interaction as usual:
<DL>
<PRE CLASS="western">
geotool in=25454488.wfdisc low=2.0 high=4.0 parse=ex1
</PRE>
</DL>

<P CLASS="western"><A NAME="geotool window="><B>geotool window=</B></P>
<P CLASS="western">
The 'window=' command line argument causes the program to begin by opening the specified window instead of
the waveform window. To allow the user to access other parts of the geotool interface after the initial window is
displayed, two buttons are added to the initial window's File menu. The button &quot;Waveform Window...&quot; will
display the waveform window that is normally the first window. The button &quot;Open Database...&quot; will display the
TableQuery window. For example, the command</P>
<DL>
<PRE CLASS="western">
geotool window=ft
</PRE>
</DL>
<P CLASS="western">
displays the FT window first. The two buttons are added to the FT/File menu as shown below:
</P>
<P><IMG SRC="ft.gif" NAME="FT" ALT="FT Window" ALIGN=BOTTOM BORDER=0></P>
<P CLASS="western">
An example usage the 'window=' argument, would be to view and edit table files, in which case the waveform
display is not needed. For example, the following command reads all table files with the prefix &quot;DPRK_reduced&quot;
into the TableViewer window.</P>
<DL>
<PRE CLASS="western">
geotool window=tableviewer parse=&quot;tv.open_file='data/tutorial/DPRK_reduced'&quot;
</PRE>
</DL>
<P CLASS="western">
Similarly, the results of a database query to get all tables associated with an orid can be displayed in the TableQuery window
with a command like</P>
<DL>
<PRE CLASS="western">
geotool window=tablequery parse=&quot;connect data_source='ORACLE' user='reb' password='reb'&quot; \
parse=&quot;query 'origin' 'select * from origin where orid=2316236'&quot; parse=&quot;get_aaow tq.origin[1]&quot;
</PRE>
</DL>
<P CLASS="western">
The 'window=' command line argument can also be used to display a specific analysis window. For example, the following
command reads waveforms from a file, selects a 5-second segment of the first waveform at an arrival time for a reference trace,
enlarges the time window, and performs a cross-correlation of the reference trace with all of the waveforms.
<DL>
<PRE CLASS="western">
geotool window=correlation parse=&quot;read 'data/tutorial/25454488.wfdisc'; select_all; filter low=.5 high=3.&quot; \
parse=&quot;position_time_window xmin=arrival[1].time-1. xmax=arrival[1].time+4.; deselect_all; select 1&quot; \
parse=&quot;correlation.set_reference; select_all&quot; \
parse=&quot;position_time_window xmin=arrival[1].time-10. xmax=arrival[1].time+10.; correlation.correlate&quot;
</PRE>
</DL>
<P CLASS="western">
The window created by this command is shown below.</P>
<P><IMG SRC="correlation.gif" NAME="Correlation" ALT="Correlation Window" ALIGN=BOTTOM BORDER=0></P>

<P CLASS="western">
The following windows can be displayed first with the 'window=' command line argument:</P>
<DL>
<PRE CLASS="western">
geotool window=open_file
geotool window=tablequery
geotool window=tablequery.connection
geotool window=preferences
geotool window=arrival_parameters
geotool window=amplitude_parameters
geotool window=output_window
geotool window=print_window
geotool window=print_window.print_options
geotool window=plugins
geotool window=table_files
geotool window=tableviewer
geotool window=waveform_setup
geotool window=data_qc
geotool window=filter
geotool window=polarization_filter
geotool window=rotation
geotool window=data_values
geotool window=amplitude_scale
geotool window=tag_contents
geotool window=waveform_color
geotool window=arrivals
geotool window=arrivals.amplitudes_magnitudes
geotool window=arrivals.measure_amp_per
geotool window=create_beam
geotool window=detection_beams
geotool window=origin_beams
geotool window=detection_beams.beam_groups
geotool window=origin_beams.beam_groups
geotool window=origins
geotool window=calibration
geotool window=cepstrum
geotool window=cluster
geotool window=correlation
geotool window=fk
geotool window=fk.signal
geotool window=fk_multi_band
geotool window=fk_multi_band.signal
geotool window=ft
geotool window=hilbert_transform
geotool window=method_history
geotool window=locate_event
geotool window=map
geotool window=multi_channel_cross_correlation
geotool window=origins
geotool window=particle_motion
geotool window=pmcc
geotool window=polarization
geotool window=real_time_display
geotool window=instrument_response
geotool window=spectrogram
geotool window=stalta
geotool window=travel_times
geotool window=waveform_tables
</PRE>
</DL>
<P CLASS="western"><A NAME="scripts/init/cmdline"><B>scripts/init/cmdline</B></P>
<P CLASS="western">The script file INSTALLATION_DIR/scripts/init/cmdline is automatically read
when geotool begins. This script provides some additional command line arguments for specifying
the initial data to be read and processed.</P>
<P CLASS="western">Command line arguments for reading prefixed files are:</P>
<DL>
<TABLE>
    <TR><TD WIDTH=15% VALIGN=TOP><P CLASS="western">prefix=</P></TD>
	<TD WIDTH=85% VALIGN=TOP><P CLASS="western"> a file path and prefix. For example: "data/tutorial/DPRK_reduced". A
		complete filename, such as "data/tutorial/DPRK_reduced.wfdisc" or "data/tutorial/DPRK_reduced.origin"
		can also be used. Any suffix (.wfdisc, .origin, etc) is ignored.</P></TD>
    </TR><TD VALIGN=TOP><P CLASS="western">sta=</P></TD>
	<TD><P CLASS="western">one or more station names, separated by commas</P></TD>
    </TR><TD VALIGN=TOP><P CLASS="western">chan=</P></TD>
	<TD><P CLASS="western">one or more channel names, separated by commas</P></TD>
    </TR>
</TABLE>
</DL>

<P CLASS="western">Command line arguments for reading from a database are:</P>
<DL>
<TABLE>
    <TR><TD WIDTH=15% VALIGN=TOP><P CLASS="western">odbc_source=</P></TD>
	<TD WIDTH=85% VALIGN=TOP><P CLASS="western">an ODBC data source</P></TD>
    </TR><TD VALIGN=TOP><P CLASS="western">odbc_user=</P></TD>
	<TD><P CLASS="western">the database login user name</P></TD>
    </TR><TD VALIGN=TOP><P CLASS="western">odbc_password=</P></TD>
	<TD><P CLASS="western">the database login password</P></TD>
    </TR><TD VALIGN=TOP><P CLASS="western">sta=</P></TD>
	<TD><P CLASS="western">one or more station names, separated by commas</P></TD>
    </TR><TD VALIGN=TOP><P CLASS="western">chan=</P></TD>
	<TD><P CLASS="western">one or more channel names, separated by commas</P></TD>
    </TR><TD VALIGN=TOP><P CLASS="western">net=</P></TD>
	<TD><P CLASS="western">the network name</P></TD>
    </TR><TD VALIGN=TOP><P CLASS="western">lead=</P></TD>
	<TD><P CLASS="western">a lead time in seconds before the arrival time or the input time (default=5.0)</P></TD>
    </TR><TD VALIGN=TOP><P CLASS="western">lag=</P></TD>
	<TD><P CLASS="western">a lag time in seconds after the arrival time or the input time (default=10.0)</P></TD>
    </TR><TD VALIGN=TOP><P CLASS="western">arid=</P></TD>
	<TD><P CLASS="western">an arrival arid</P></TD>
    </TR><TD VALIGN=TOP><P CLASS="western">exclude=</P></TD>
	<TD><P CLASS="western">one or more station names to exclude</P></TD>
    </TR><TD VALIGN=TOP><P CLASS="western">time=</P></TD>
	<TD><P CLASS="western">a time string or epochal time value</P></TD>
    </TR>
</TABLE>
</DL>

<P CLASS="western">
The data source is specified with either the 'prefix' argument or the three ODBC arguments
'odbc_source', 'odbc_user', and 'odbc_password'. For prefixed files, the entire waveform is read for each
sta/chan specification. For ODBC data, a segment of the waveform is read. The time limits of the segment
are determined from the arid argument or the time argument.
<P CLASS="western">
If the 'window=' command line argument is used, the window's compute method will be called, if it has one.
Some examples that read data from prefixed files are:</P>
<DL>
<PRE CLASS="western">
geotool prefix=data/tutorial/DPRK_reduced  # read all waveforms in the file

geotool prefix=data/tutorial/DPRK_reduced chan=sz  # read all &quot;sz&quot; waveforms

geotool prefix=data/tutorial/DPRK_reduced sta=FIA0,NV07,PD01 chan=sz  # read three stations

geotool window=spectrogram prefix=data/tutorial/TURKEY sta=MLR chan=SHZ  # read and compute a spectrogram

geotool window=ft prefix=data/tutorial/TURKEY sta=MLR chan=SHZ  # read and compute an FT
</PRE>
</DL>
<P CLASS="western">When the arid is used to get data from the database, all the stations in the network
are read, unless restricted with the sta and chan arguments. If the arid is not known, then the time
and net arguments can be used. Some examples are:</P>
<DL>
<PRE CLASS="western">
# read array data using an arid and compute an FK
geotool window=fk_multi_band odbc_source=ORACLE odbc_user=reb odbc_password=reb arid=15833631 chan=sz

# read array data using a time value and compute an FK
geotool window=fk_multi_band odbc_source=ORACLE odbc_user=reb odbc_password=reb time=1076162144.9 net=FINES chan=sz

# use the exclude argument to exclude some stations
geotool window=fk_multi_band odbc_source=ORACLE odbc_user=reb odbc_password=reb arid=15833631 chan=sz exclude=FIA0,FIA3,FIB1
</PRE>
</DL>
<P CLASS="western">
The script file INSTALLATION_DIR/scripts/init/cmdline that processes these command line arguments is shown below.
It can be edited to change the behavior.
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
# file scripts/init/cmdline
# process command line arguments

alias tq = tablequery

if( defined(prefix) )                   # if the prefix argument is used
    connect prefix=prefix
    get_all_tables                      # read all of the prefix.table files
    tq.select_tab=&quot;wfdisc&quot;
    if( defined(sta) &amp;&amp; defined(chan) ) # if both sta and chan are used
	foreach(tq.wfdisc.row, r) # loop over wfdiscs and select for sta and chan
	    i = for_index
	    foreach(sta)
		foreach(chan)
		    if(r.sta ~= sta &amp;&amp; r.chan ~= chan)
			tq.select_row i   # select this wfdisc is sta and chan match
		    endif
		endfor
	    endfor
	endfor
    else if( defined(sta) )        # if only sta is specified
	foreach(tq.wfdisc.row, r)  # loop over wfdiscs
	    i = for_index
	    foreach(sta)
		if(r.sta ~= sta)
		    tq.select_row i  # select this wfdisc is sta matches
		endif
	    endfor
	endfor
    else if( defined(chan) )       # if only chan is specified
	foreach(tq.wfdisc.row, r)  # loop over wfdiscs
	    i = for_index
	    foreach(chan)
		if(r.chan ~= chan)
		    tq.select_row i  # select this wfdisc is chan matches
		endif
	    endfor
	endfor
    else
	tq.select_all  # neither sta nor chan are specified, select all wfdiscs
    endif
    tq.display_waveforms  # read the waveforms into the waveform window

    if( defined(window) &amp;&amp; wave.size() &gt; 0)
	select_all        # if the 'window=' argument is used, select all waveforms
	set cmd = window &quot;.compute&quot;  # if window=ft, this will be 'ft.compute'
	parse_string cmd  # and compute
    endif 

    return  # all done if prefix argument was used

# if the odbc arguments are specified
else if( defined(odbc_source) || defined(odbc_user) || defined(odbc_password) )

    # check for missing arguments
    if( !defined(odbc_source) )
	showWarning &quot;missing command line argument 'odbc_source'&quot;
	return
    else if( !defined(odbc_user) )
	showWarning &quot;missing command line argument 'odbc_user'&quot;
	return
    else if( !defined(odbc_password) )
	showWarning &quot;missing command line argument 'odbc_password'&quot;
	return
    endif

    # make the odbc connection
    connect data_source=odbc_source user=odbc_user password=odbc_password
else
    return  # no 'prefix' nor odbc arguments
endif


alias tqcon = tablequery.connection

if( !defined(lead) )
    lead = 5         # default lead
endif
if( !defined(lag) )
    lag = 10         # default lag
endif

if( defined(arid) )  # if the 'arid=' argument is used

    # use the Database Connection arrival tab interface which
    # will automatically form the queries based on an arid
    tqcon.arrival.arrival_id=arid

    if( lead &lt; 60. )
	tqcon.arrival.time_before=60.
    else
	tqcon.arrival.time_before=lead
    endif

    if( lag &lt; 120. )
	tqcon.arrival.time_after=120.
    else
	tqcon.arrival.time_after=lag
    endif

    tqcon.arrival.stations=&quot;&quot;
    tqcon.arrival.channels=&quot;&quot;

    if( defined(sta) )
	tqcon.arrival.stations=sta
    endif
    if( defined(chan) )
	tqcon.arrival.channels=chan
    endif

    tqcon.arrival.return_origins=true
    tqcon.arrival.return_wfdiscs=true
    tqcon.arrival.run_query
    tq.select_tab=&quot;wfdisc&quot;
    tq.select_all

    if( defined(exclude) )
	set s = '{' exclude '}'
	tablequery.deselect_row sta=s
    endif

    tq.display_waveforms

    foreach(arrival, a)  # loop over arrival to find the arid
	if(a.arid == arid)
	    # position the time-window cursor in the waveform window
	    position_time_window xmin=a.time-lead xmax=a.time+lag
	    break
	endif
    endfor

else if( defined(time) )  # if 'time=' argument is used
    time = epoch(time)

    # use the Database Connection time tab interface which
    # will automatically form the queries based on time
    if( lead &lt; 60. )
	tqcon.time.start_time=time-60.
    else
	tqcon.time.start_time=time-lead
    endif
    if( lag &lt; 120. )
	tqcon.time.end_time=time+120.
    else
	tqcon.time.end_time=time+lag
    endif

    tqcon.time.stations=&quot;&quot;
    tqcon.time.channels=&quot;&quot;
    tqcon.time.network=&quot;&quot;

    if( defined(sta) )
	tqcon.time.stations=sta
    endif
    if( defined(chan) )
	tqcon.time.channels=chan
    endif
    if( defined(net) )
	tqcon.time.network=net
    endif

    tqcon.time.return_origins=true
    tqcon.time.return_arrivals=true
    tqcon.time.return_wfdiscs=true

    tqcon.time.run_query

    tq.select_tab=&quot;wfdisc&quot;
    tq.select_all

    if( defined(exclude) )
	set s = '{' exclude '}'
	tq.deselect_row sta=s
    endif

    tq.display_waveforms

    # position the time-window cursor in the waveform window
    position_time_window xmin=time-lead xmax=time+lag

else
    return
endif

if( defined(window) &amp;&amp; wave.size() &gt; 0)
    select_all
    set cmd = window &quot;.compute&quot;
    parse_string cmd
endif 
</PRE>
		</TD>
	</TR>
	</TABLE>
</DL>
<H1 CLASS="western"><A NAME="Interprocess Messages"></A>17.0 Interprocess Messages</H1>
<DL>
<P CLASS="Western">
Interprocess messages can be handled by scripts. The command add_message_handler
specifies a callback script that is interpreted whenever a message of a
particular type is received. The parameters that are contained in the message
line as name=value assignments are available as global variables in the
callback script. The command send_message will send a message to another
process.</P>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0 FRAME=VOID RULES=ROWS>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="add_messages_handler"></A><B>add_message_handler</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>add_message_handler</B> msg_id=MSG_ID callback=SCRIPT_COMMAND.</P>
			<P CLASS="western">
			Description: Specify a script command that will be
interpreted whenever a message of type MSG_ID is received. The SCRIPT_COMMAND
is typically a parse command. For example:</P>
<PRE CLASS="western">
add_message_handler msg_id="ARSspectro" callback="parse ../spectro"
</PRE>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10%>
			<P CLASS="western"><A NAME="send_message"></A><B>send_message</B></P>
		</TD>
		<TD WIDTH=90%>
			<P CLASS="western">Synopsis: <B>send_message</B> dest=DESTINATION msg_id=MSG_ID msg=MESSAGE class=CLASS.</P>
			<P CLASS="western">
			Description: Send a message to the specified destination. For example:</P>
<PRE CLASS="western">
send_message dest="ARS" msg_id="CallScheme" msg='(update-arrival-par-list "arid=183571 phase=P")' class="geotool"
</PRE>
		</TD>
	</TR>
	</TABLE>
<P CLASS="Western">
The initialization file "INSTALLATION_DIR/scripts/init/messages" contains
add_message_handler commands. All files in this directory are ready once when
the program begins. The "messages" file is shown below.
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
# file scripts/init/messages
# process IPC messages

add_message_handler msg_id="ARSspectro" callback="parse ../spectro"
add_message_handler msg_id="ARSft" callback="parse ../spectro"
add_message_handler msg_id="ARSfk" callback="parse ../fk"

# send rename and retime arrival messages
modified_table_cb={
  if(modified_table.tableName == 'assoc')
    if(phase_modified)
        sprintf s '(update-arrival-par-list "arid=' modified_table.arid \
         ' phase=' modified_table.phase '")'
        send_message dest="ARS" msg_id="CallScheme" msg=s class="geotool"
    endif
  else if(modified_table.tableName == 'arrival')
    if(iphase_modified)
        sprintf s '(update-arrival-par-list "arid=' modified_table.arid \
         ' phase=' modified_table.iphase '")'
        send_message dest="ARS" msg_id="CallScheme" msg=s class="geotool"
    endif
    if(time_modified)
        sprintf s '(update-arrival-par-list "arid=' modified_table.arid \
         ' time=' modified_table.time(%.3f) '")'
        send_message dest="ARS" msg_id="CallScheme" msg=s class="geotool"
    endif
  endif
}

# send delete arrival message
deleted_table_cb={
  if(modified_table.tableName == 'arrival')
    sprintf s '(delete-arrival (car (string-&gt;arrivals "' \
	modified_table.arid '")))'
    send_message dest="ipcc_test" msg_id="CallScheme" msg=s class="geotool"
  endif
}

# send add table messages
add_table_cb={
  if(modified_table.tableName == 'arrival')
    sprintf s '(add-arrival arid="' modified_table.arid '")'
    send_message dest="ARS" msg_id="CallScheme" msg=s class="geotool"
  else if(modified_table.tableName == 'assoc')
    sprintf s '(add-assoc arid="' modified_table.arid \
      ' orid=' modified_table.orid '")'
    send_message dest="ARS" msg_id="CallScheme" msg=s class="geotool"
  else if(modified_table.tableName == 'origin')
    sprintf s '(add-origin orid="' modified_table.orid '")'
    send_message dest="ARS" msg_id="CallScheme" msg=s class="geotool"
  endif
  #  etc.
}
</PRE>
		</TD>
	</TR>
	</TABLE>
</DL>
<H1 CLASS="western"><A NAME="Shared Library Interface"></A>18.0 Adding Commands Using a Shared Library Interface</H1>
<DL>
<P CLASS="western">
It is possible to add commands and predefined variables to the geotool scripting language through a shared library
plug-in interface. Geotool loads shared libraries that are in the installation subdirectory lib/plugins and also libraries
that are in the home subdirectory ~/.geotool++/plugins. The geotool distribution comes with an example plug-in library called
libgscript that can be used as a template for adding new commands and variables to the scripting language. This library is
compiled and installed with the other geotool plug-in libraries.</P>
<P CLASS="western">
All commands that start with &quot;gsc.&quot; are processed by libgscript. The library only recognizes two commands, &quot;cmd1&quot; and &quot;cmd2&quot;.
The following script</P>
<DL>
<PRE CLASS="western">
read file=&quot;../../data/tutorial/TURKEY.wfdisc&quot;
gsc.cmd1 wave[4] low=0. high=3. length=250
</PRE>
</DL>
<P CLASS="western">produces the output</P>
<DL>
<PRE CLASS="western">
wave = MLR/SHZ 1051748945.90 low=0  high=3  length=250
</PRE>
</DL>
<P CLASS="western">The second command</P>
<DL>
<PRE CLASS="western">
gsc.cmd2
</PRE>
</DL>
<P CLASS="western">produces the output</P>
<DL>
<PRE CLASS="western">
INK/BHZ 68.31 -133.53 CMG-3E
INK/BHN 68.31 -133.53 CMG-3E
INK/BHE 68.31 -133.53 CMG-3E
MLR/SHZ 45.49 25.94 S-13
MLR/SHN 45.49 25.94 S-13
MLR/SHE 45.49 25.94 S-13
VRAC/BHZ 49.31 16.59 STS-2
VRAC/BHN 49.31 16.59 STS-2
VRAC/BHE 49.31 16.59 STS-2
HFC2/HHE 60.13 13.69 STS-2
HFC2/HHN 60.13 13.69 STS-2
HFC2/HHZ 60.13 13.69 STS-2
GED1/SHE 48.85 13.71 GS-13
GED1/SHN 48.85 13.71 GS-13
GED1/SHZ 48.85 13.71 GS-13
FIA0/se 61.44 26.08 S-13
FIA0/sn 61.44 26.08 S-13
FIA0/sz 61.44 26.08 S-13
</PRE>
</DL>
<P CLASS="western">
The gsc.cmd2 also computes the average amplitude of the waveforms which is accessible as a variable array &quot;a&quot;.
The print command
<DL>
<PRE CLASS="western">
print gsc.n gsc.b gsc.c gsc.a[1](%.2f) gsc.a[2](%.2f) 
</PRE>
</DL>
<P CLASS="western">produces the output</P>
<DL>
<PRE CLASS="western">
45 3.67 89.1 62.35 28.23
</PRE>
</DL>
<P CLASS="western">
The library is composed of two files, plugins/libgscript/script.h
and plugins/libgscript/script.cpp. These two files are show below.
</P>
    <TABLE WIDTH=100% BORDER=2 BORDERCOLOR="#ffffff" CELLPADDING=3 CELLSPACING=0 FRAME=VOID RULES=ROWS>
    <TR>
	<TD WIDTH=35% VALIGN=TOP>
	    <P CLASS="western"><BR><BR></P>
	    <P CLASS="western">
	    The include file script.h is shown at the right. It contains the declaration of the gscriptPlugin class.
	    The constructor method initializes some example variables, the double array a[20], the double variable
	    b, the float variable c, and the int variable n.</P>
	    <P CLASS="western">
	    The virtual methods parseCmd() and parseVar() are the interface to the geotool
	    command parsing module. They are called to process commands that are directed to this library.</P>
	    <P CLASS="western">
	    The method parseCmd() is called to process commands and the method parseVar() is called to
	    get variable values.</P>
	</TD>
	<TD WIDTH=65% VALIGN=TOP>
	    <P CLASS="western" ALIGN=CENTER><B>plugins/libgscript/script.h</B></P>
	    <TABLE WIDTH=100% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	    <TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
<PRE CLASS="western">
#include &quot;motif++/MotifClasses.h&quot;

/** The Script PlugIn subclass.
 */
class <B>gscriptPlugin</B> : public PlugIn
{
    public :

    double a[20], b;
    float c;
    int n;

    gscriptPlugin(TopWindow *tw_parent, DataSource *ds, DataReceiver *dr)
                        : PlugIn(tw_parent, ds, dr)
    {
	// initialize some example variables
        memset(a, 0, sizeof(a));
        b = 3.67;
        c = 89.1;
        n = 45;
    }
    ~gscriptPlugin(void) { }

    virtual ParseCmd <B>parseCmd</B>(const char *cmd, char *msg, int msg_len);
    virtual ParseVar <B>parseVar</B>(const char *name, char *value, int value_len);

    ParseCmd <B>parseCmd1</B>(const char *cmd, char *msg, int msg_len);
    ParseCmd <B>parseCmd2</B>(const char *cmd, char *msg, int msg_len);
};</PRE>
		</TD>
	    <TR>
	    </TABLE>
	</TD>
    </TR>
    </TABLE>

<BR>
    <TABLE WIDTH=100% BORDER=2 BORDERCOLOR="#ffffff" CELLPADDING=3 CELLSPACING=0 FRAME=VOID RULES=ROWS>
    <TR>
	<TD WIDTH=35% VALIGN=TOP>
	    <P CLASS="western">
	    <BR>
	    The source file script.cpp is shown at the right. The first part of the file contains the
	    code that identifies the library as a geotool plug-in. The &quot;C&quot; routine plugInIndex() is
	    called by geotool to get the PlugInStruct structure which contains a pointer to the createPlugin() method.
	    This method is called to create the PlugIn subclass as a child of the WaveformWindow. The
	    PlugInStruct specifies the name of the plug-in as &quot;gsc&quot;. All script commands and variables that
	    start with &quot;gsc.&quot; will be directed to this library via the parseCmd() and parseVar() methods.
	    </P>
	</TD>
	<TD WIDTH=65% VALIGN=TOP>
	    <P CLASS="western" ALIGN=CENTER><B>plugins/libgscript/script.cpp</B></P>
	    <TABLE WIDTH=100% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	    <TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
#include &lt;math.h&gt;
#include &quot;script.h&quot;
#include &quot;motif++/MotifClasses.h&quot;
#include &quot;CPlotDataClass.h&quot;

static PlugIn *createPlugin(Application *app, Component *parent,
                TopWindow *tw_parent, DataSource *ds, DataReceiver *dr)
{
    return new <B>gscriptPlugin</B>(tw_parent, ds, dr);
}

static PlugInStruct plugins[] =
{
    // app_name, parent_class, parent_name, name, description, createFunction
    {NULL,  &quot;WaveformWindow&quot;, NULL, &quot;gsc&quot;, &quot;Script Library&quot;, createPlugin},
};

extern &quot;C&quot; int plugInIndex(PlugInStruct **p)
{
    *p = plugins;
    return sizeof(plugins)/sizeof(PlugInStruct);
}</PRE>
		</TD>
	    </TR>
	    </TABLE>
	</TD>
    </TR>
    <TR>
	<TD WIDTH=35% VALIGN=TOP>
	    <P CLASS="western">
	    <BR><BR>
	    This example parseCmd() method recognizes the commands &quot;cmd1&quot; and &quot;cmd2&quot; and
	    calls either parseCmd1() or parseCmd2() to process the command.
	    </P>
	</TD>
	<TD WIDTH=65% VALIGN=TOP>
	    <TABLE WIDTH=100% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	    <TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
/** Parse gsc script commands. This method is called for all script commands
 *  that begin with &quot;gsc.&quot;.
 *  @param[in] cmd The command line.
 *  @param[out] msg Returned message.
 *  @param[in] the length of msg.
 */
ParseCmd gscriptPlugin::<B>parseCmd</B>(const char *cmd, char *msg, int msg_len)
{
    if(!strncasecmp(cmd, &quot;cmd1&quot;, 4)) {
        return <B>parseCmd1</B>(cmd, msg, msg_len);
    }
    else if(!strncasecmp(cmd, &quot;cmd2&quot;, 4)) {
        return <B>parseCmd2</B>(cmd, msg, msg_len);
    }
    return COMMAND_NOT_FOUND;
}
</PRE>
		</TD>
	    </TR>
	    </TABLE>
	</TD>
    </TR>
    <TR>
	<TD WIDTH=35% VALIGN=TOP>
	    <P CLASS="western">
	    <BR>
	    The &quot;cmd1&quot; command takes a wave object as an argument. It also requires two double
	    arguments &quot;low&quot; and &quot;high&quot; and the integer argument &quot;length&quot;. The getWaveform() method
	    is called to get the CPlotDataClass object that contains the waveform.</P>
	    <P CLASS="western">
	    When a waveform is an argument, as in &quot;gsc.cmd2 wave[4] ...&quot;, the cmd string passed to
	    this method has the argument &quot;_wave_=ID&quot;, where ID is a unique id number.</P>
	    <P CLASS="western">
	    This example method does not actually use the command arguments, but simply prints
	    them along with the waveform sta, chan, and time.
	</TD>
	<TD WIDTH=65% VALIGN=TOP>
	    <TABLE WIDTH=100% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	    <TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
/** Parse the command gsc.cmd1 wave[1] low= high= length=
 */
ParseCmd gscriptPlugin::<B>parseCmd1</B>(const char *cmd, char *msg, int msg_len)
{
    int id, length;
    double low, high;
    CPlotDataClass *cd=NULL;

    // get all arguments
    if( !<B>parseGetArg</B>(cmd, &quot;cmd1&quot;, msg, msg_len, &quot;_wave_&quot;, &amp;id) ) {
        snprintf(msg, msg_len, &quot;cmd1: missing wave object&quot;);
        return ARGUMENT_ERROR;
    }
    if( !(cd = ds-&gt;<B>getWaveform</B>(id)) ) {
        snprintf(msg, msg_len, &quot;cmd1: wave object not found&quot;);
        return ARGUMENT_ERROR;
    }
    if( !<B>parseGetArg</B>(cmd, &quot;cmd1&quot;, msg, msg_len, &quot;low&quot;, &amp;low) ) {
        snprintf(msg, msg_len, &quot;cmd1: missing low argument&quot;);
        return ARGUMENT_ERROR;
    }
    if( !<B>parseGetArg</B>(cmd, &quot;cmd1&quot;, msg, msg_len, &quot;high&quot;, &amp;high) ) {
        snprintf(msg, msg_len, &quot;cmd1: missing high argument&quot;);
        return ARGUMENT_ERROR;
    }
    if( !<B>parseGetArg</B>(cmd, &quot;cmd1&quot;, msg, msg_len, &quot;length&quot;, &amp;length) ) {
        snprintf(msg, msg_len, &quot;cmd1: missing length argument&quot;);
        return ARGUMENT_ERROR;
    }

    // do something with cd and arguments
    printf(&quot;wave = %s/%s %.2f low=%.4g  high=%.4g  length=%d\n&quot;,
                cd-&gt;sta, cd-&gt;chan, cd-&gt;ts-&gt;tbeg(), low, high, length);

    return COMMAND_PARSED;
}
</PRE>
		</TD>
	    </TR>
	    </TABLE>
	</TD>
    </TR>
    <TR>
	<TD WIDTH=35% VALIGN=TOP>
	    <P CLASS="western">
	    <BR><BR>
	    The &quot;gsc.cmd2&quot; command does not have any arguments. The parseCmd2() method get all of the waveforms,
	    prints some information about each waveform and computes the average amplitude of the
	    first segment of each waveform. The parseVar method makes the results of this computation,
	    array a[], accessible as script variables.</P>
	</TD>
	<TD WIDTH=65% VALIGN=TOP>
	    <TABLE WIDTH=100% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	    <TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
/** Parse the command gsc.cmd2
 */
ParseCmd gscriptPlugin::<B>parseCmd2</B>(const char *cmd, char *msg, int msg_len)
{
    int num, n;
    double amp;
    CPlotDataClass **cd_list=NULL;

    if((num = ds-&gt;<B>getWaveforms</B>(&amp;cd_list)) == 0) {
        snprintf(msg, msg_len, &quot;cmd2: no waveforms found&quot;);
        return ARGUMENT_ERROR;
    }

    // do something with all waveforms
    for(int i = 0; i &gt; num; i++) {
        printf(&quot;%s/%s %.2f %.2f %s\n&quot;, cd_list[i]-&gt;sta, cd_list[i]-&gt;chan,
		cd_list[i]-&gt;ts-&gt;lat(), cd_list[i]-&gt;ts-&gt;lon(),
                cd_list[i]-&gt;ts-&gt;instype());

        // compute the average amplitude of the first segment
        amp = 0.;
        n = cd_list[i]-&gt;ts-&gt;segment(0)-&gt;length();
        for(int j = 0; j &lt; n; j++) {
            amp += fabs(cd_list[i]-&gt;ts-&gt;segment(0)-&gt;data[j]);
        }
        if(n &gt; 0) amp /= n;
        if(i &lt; 20) a[i] = amp;
    }

    Free(cd_list);
    return COMMAND_PARSED;
}</PRE>
		</TD>
	    </TR>
	    </TABLE>
	</TD>
    </TR>
    <TR>
	<TD WIDTH=35% VALIGN=TOP>
	    <BR><BR>
	    <P CLASS="western">
	    The parseVar method is called to evaluate variables whose name begins with &quot;gsc.&quot;. This
	    parseVar method evaluates the variables gsc.b, gsc.c, gsc.n and the array gsc.a[].</P>
	    <P CLASS="western">
	    The parseArray() method returns true if the input name is the array a[]. It parses the
	    array index and returns the requested value.</P>
	    <P CLASS="western">
	    All double variables are converted to strings using the &quot;.15g&quot; format.
	    All float variables are converted to strings using the &quot;.7g&quot; format.</P>
	</TD>
	<TD WIDTH=65% VALIGN=TOP>
	    <TABLE WIDTH=100% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	    <TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
/** Parse gsc script variables. This method is called for all script variables
 *  that begin with &quot;gsc.&quot;.
 *  @param[in] name The variable name.
 *  @param[out] value Returned variable value.
 *  @param[in] the length of value.
 */
ParseVar gscriptPlugin::<B>parseVar</B>(const char *name, char *value, int value_len)
{
    ParseVar ret;

    if(<B>parseArray</B>(name, &quot;a&quot;, 20, a, value, value_len, &amp;ret)) {
        // parseArray takes care of it
        return ret;
    }
    else if(!strcasecmp(name, &quot;b&quot;)) {
        snprintf(value, value_len, &quot;%.15g&quot;, b);
    }
    else if(!strcasecmp(name, &quot;c&quot;)) {
        snprintf(value, value_len, &quot;%.7g&quot;, c);
    }
    else if(!strcasecmp(name, &quot;n&quot;)) {
        snprintf(value, value_len, &quot;%d&quot;, n);
    }
    else {
        return VARIABLE_NOT_FOUND;
    }
    return STRING_RETURNED;
}
</PRE>
		</TD>
	    </TR>
	    </TABLE>
	</TD>
    </TR>
    </TABLE>

<P CLASS="western">The functions listed below are useful for parsing arguments and array indices from
the input strings to the parseCmd and parseVar method.</P>
<DL>
<TABLE WIDTH=90% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
<TR><TD BGCOLOR="#e6e6ff"><PRE CLASS="western">
bool <B>parseArray</B>(const char *name, const char *array_name, int max_ndex,
		(int,float,double) *array, char *value, int value_len, ParseVar *ret)
	(in)  name        the requested array name
	(in)  array_name  this array name
	(in)  max_index   the maximum allowed index (starting at 1)
	(in)  array       the float array
	(out) value       the returned value (an int, float or double pointer)
	(in)  value_len   the size of value
	(out) ret         the return code
	Returns true if array_name matches name
</PRE></TD></TR>
<TR><TD BGCOLOR="#e6e6ff"><PRE CLASS="western">
bool <B>parseArrayIndex</B>(const char *name, const char *array_name, int max_ndex, int *ndex,
			char **next_char, char *value, int value_len, ParseVar *ret)
	(in)  name	  the requested array name
	(in)  array_name  this array name
	(in)  max_index   the maximum allowed index (starting at 1)
	(out) ndex        the index found
        (out) next_char   the character after the bracket ']'
        (out) value       for error messages
        (in)  value_len   the size of value
	(out) ret         the return code
	Returns true if array_name matches name
</PRE></TD></TR>
<TR><TD BGCOLOR="#e6e6ff"><PRE CLASS="western">
char * <B>parseGetArg</B>(const char *cmd, const char *argname)
	(in)  cmd         the command string
        (in)  arg_name    the argument name
	Returns the argument value or NULL if it is not found
</PRE></TD></TR>
<TR><TD BGCOLOR="#e6e6ff"><PRE CLASS="western">
bool <B>parseGetArg</B>(const char *cmd, const char *cmd_name, char *msg, int msg_len,
		const char *argname, (int,long,double,bool) *value)
        (in)  cmd         the command string
        (in)  arg_name    the argument name
        (out) value       the argument value (an int,long,double or bool pointer)
	Returns true if argname was found and the value parse successfully read
</PRE></TD></TR>
</TABLE>
</DL>
<P CLASS="western">Some of the DataSource class functions for accessing waveforms and tables are listed below.
Prefix each function call with &quot;ds-&gt;&quot; inside the parseCmd and parseVar methods.</P>

<DL>
<TABLE WIDTH=90% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
<TR><TD BGCOLOR="#e6e6ff"><PRE CLASS="western">
int <B>getWaveforms</B>(CPlotDataClass ***cd_list)
	(out) cd_list       an allocated array of CPlotDataClass objects
	Returns the number of objects in cd_list[]
	Get the CPlotDataClass objects for waveforms that are displayed
</PRE></TD></TR>
<TR><TD BGCOLOR="#e6e6ff"><PRE CLASS="western">
CPlotDataClass *<B>getWaveform</B>(int id)
	(in) id            the id of the waveform
	Returns a CPlotDataClass object or NULL
	Get the CPlotDataClass object for the specified id
</PRE></TD></TR>
<TR><TD BGCOLOR="#e6e6ff"><PRE CLASS="western">
int <B>getSelectedWaveforms</B>(CPlotDataClass ***cd_list)
	(out) cd_list      an allocated array of CPlotDataClass objects
	Returns the number of objects in cd_list[]
	Get CPlotDataClass objects for all selected waveforms
</PRE></TD></TR>
<TR><TD BGCOLOR="#e6e6ff"><PRE CLASS="western">
int <B>copySelectedWaveforms</B>(GTimeSeries ***ts_list)
	(out) ts_list      an allocated array of GTimeSeries objects
	Returns the number of objects in ts_list[]
	Get cloned GTimeSeries objects for selected waveforms
	Free space with ts_list[i]-&gt;deleteObject and free(ts_list)
</PRE></TD></TR>
<TR><TD BGCOLOR="#e6e6ff"><PRE CLASS="western">
int <B>getSelectedWaveforms</B>(const char *cursor_label, CPlotDataClass ***cd_list)
	(in)  cursor_label the character label of the time window
	(out) cd_list      an allocated array of CPlotDataClass objects
	Returns the number of objects in cd_list[]
	Get CPlotDataClass objects for selected waveforms within a window
</PRE></TD></TR>
<TR><TD BGCOLOR="#e6e6ff"><PRE CLASS="western">
int <B>getSelectedComponents</B>(int **num_cmpts, CPlotDataClass ***cd_list)
	(out) num_cmpts    the number of components (2 or 3) in each group
	(out) cd_list      an allocated array of CPlotDataClass objects
	Returns the number of groups (elements in num_cmpts)
	Get CPlotDataClass objects for selected components
</PRE></TD></TR>
<TR><TD BGCOLOR="#e6e6ff"><PRE CLASS="western">
long <B>getWorkingOrid</B>(void)
	Returns the working orid or -1 if none is set
</PRE></TD></TR>
<TR><TD BGCOLOR="#e6e6ff"><PRE CLASS="western">
void <B>setWorkingOrid</B>(long orid, bool do_callback=true)
	(in) orid          the new working orid
	(in) do_callback   if true, do a DataChange callback
	Set the working orid
</PRE></TD></TR>
<TR><TD BGCOLOR="#e6e6ff"><PRE CLASS="western">
int <B>getArrivalsOnWaveform</B>(CPlotDataClass *cd, CssArrival **arrivals)
	(in) cd            the CPlotDataClass object for the waveform
	(out) arrivals     an allocated array of CssArrival objects
	Returns the number of objects in arrivals[]
	Get the arrivals that are associated with the waveform
</PRE></TD></TR>
<TR><TD BGCOLOR="#e6e6ff"><PRE CLASS="western">
Vector <B>getVTable</B>(const char *cssTableName, bool copy=true)
	(in) cssTableName  the table name
	(in) copy          if true, allocate a new Vector for return.
			   if false, return an internal Vector
	Returns a Vector or NULL
	Get a Vector of CssTable objects
</PRE></TD></TR>
<TR><TD BGCOLOR="#e6e6ff"><PRE CLASS="western">
int <B>getTable</B>(const char *cssTableName, CssTable **table)
	(in) cssTableName  the table name
	(out) table        an allocated array of objects
	Returns the number of elements in the table array
	Get an array of CssTable objects
</PRE></TD></TR>
<TR><TD BGCOLOR="#e6e6ff"><PRE CLASS="western">
Vector <B>getSelectedVTable</B>(const char *cssTableName)
	(in) cssTableName  the table name
	Returns a Vector or NULL
	Get a Vector of selected CssTable objects
</PRE></TD></TR>
<TR><TD BGCOLOR="#e6e6ff"><PRE CLASS="western">
int <B>getSelectedTable</B>(const char *cssTableName, CssTable **table)
	(in) cssTableName  the table name
	(out) table        an allocated array of objects
	Get an array of selected CssTable objects
	Returns the number of elements in the table array
</PRE></TD></TR>
</TABLE>
</DL>
</DL>
<H1 CLASS="western"><A NAME="Testing and Validation"></A>19.0 Testing and Validation</H1>
<DL>
<P CLASS="western">
The scripting language can be used to confirm that geotool's data analysis options work and give the same results.
The &quot;bin&quot; subdirectory of the geotool installation directory contains a shell script called &quot;test_geotool&quot;. This
script executes geotool for each geotool script in the directory test/test_scripts. Each test script reads waveform
data from the test/test_data directory and compares processing results to &quot;reference&quot; numerical values.
The test_geotool script looks like:</P>
<DL>
<PRE CLASS="western">
#!/bin/sh
# this script executes geotool from the test/test_scripts directory for each
# test script in that directory

cd /home/user/geotool/install/test/test_scripts

for script in `ls`
do
/home/user/geotool/install/bin/geotool -i data_dir=../test_data parse=$script parse=&quot;quit&quot;
if [ $? -ne 0 ]
then
    echo parse $script failed
fi
done
</PRE>
</DL>
<P CLASS="western">
The script prints the results of each test, for example:</P>
<DL>
<PRE CLASS="western">
filter test 1 OK
filter test 2 OK
filter test 3 OK
filter test 4 OK
filter test 5 OK
filter test 6 OK
filter test 7 OK
filter test 8 OK
fkm test 1 OK
fkm test 2 OK
fkm test 3 OK
fkm test 4 OK
...
</PRE>
</DL>
<P CLASS="western">
The &quot;-i&quot; geotool command line argument instructs the program to run without displaying the graphical interface. The &quot;parse=&quot;
command line arguments are processed by the command interpreter. Other command line arguments that are assignments, such
as &quot;data_dir=../test_data&quot; become global variables within the geotool scripts.</P>
<P CLASS="western">
The geotool test scripts in the subdirectory &quot;test/test_scripts&quot; perform operations such as filtering, creating beams,
creating an FK or an FT, etc., and compare the results to &quot;reference&quot; values.  The technique used in the geotool test
scripts is to compare only a few &quot;randomly&quot; selected values. For example the script &quot;test_scripts/beam&quot;, that tests the
operation of the beam command, compares the beam waveform sample values to reference values:
</P>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
if( defined(data_dir) )
    set data_file=data_dir+&quot;/ASAR.wfdisc&quot;
else
    print &quot;data_dir is not defined&quot;
    return
endif

clear
read file=data_file query=&quot;select * from wfdisc where sta like 'AS' and chan='SHZ'&quot;
select_all

# create a beam using the following parameters
create_beam.slowness_units=&quot;s/deg&quot;
create_beam.slowness=23.3
create_beam.azimuth=185.8
create_beam.beam_filter=&quot;on&quot;
create_beam.low=1.5
create_beam.high=4.5
create_beam.order=3
create_beam.type=&quot;BP&quot;
create_beam.constraint=&quot;causal&quot;
create_beam.replace=true
create_beam.beam 

n = wave.size()    # the index of the beam

set i=45,135,859,994,1124,1525,1623,1835

set d=0.01661496,0.0007423827,-0.1012674,-0.1551854,-0.05387467,-0.003696998,0.2082569,0.08003435
setb ok=true
foreach(i)
    if(wave[n].seg[1].data[i] != d[for_index]); setb ok=false; endif
endfor
if( ok ); print &quot;create_beam test 1 OK&quot;
else; print &quot;create_beam test 1 failed&quot;; endif

beam azimuth=173.2 slowdeg=6.3 low=1.0 high=4.0 order=3 type=&quot;BP&quot; zp=false replace=true

set d=-0.001097006,0.164435,-0.1144192,-0.1414144,0.1020931,-0.02389313,0.001157728,0.06933046
setb ok=true
foreach(i)
    if(wave[n].seg[1].data[i] != d[for_index]); setb ok=false; endif
endfor
if( ok ); print &quot;create_beam test 2 OK&quot;
else; print &quot;create_beam test 2 failed&quot;; endif

# create a beam using a detection beam recipe (the arrival chan name)
beam arrival[1]
n = wave.size()    # the index of the beam

set d=0.0004404376,0.009503013,-0.04740897,-0.1230098,-0.001075833,-0.06694256,-0.0841963,-0.05477715
setb ok=true
foreach(i)
    if(wave[n].seg[1].data[i] != d[for_index]); setb ok=false; endif
endfor
if( ok ); print &quot;create_beam test 3 OK&quot;
else; print &quot;create_beam test 3 failed&quot;; endif
</PRE>
		</TD>
	</TR>
	</TABLE>
<P CLASS="western">
Similarly, the script &quot;test_scripts/fkmulti&quot;, that tests the operation of the FK Multi-Band window, compares
several values of the FK matrix to reference values and compares values from the snr, fstat, appvel, slowness, and
azimuth arrays to references values.
</P>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
if( defined(data_dir) )
    set data_file=data_dir+&quot;/ASAR.wfdisc&quot;
else
    print &quot;data_dir is not defined&quot;
    return
endif

clear
read file=data_file query=&quot;select * from wfdisc where sta like 'AS' and chan='SHZ'&quot;
time_window phase=&quot;P&quot; lead=5 lag=10
select_all
alias fkm=fk_multi_band

fkm.flo1=0.5; fkm.fhi1=2.0
fkm.flo2=1.0; fkm.fhi2=3.0
fkm.flo3=2.0; fkm.fhi3=4.0
fkm.flo4=3.0; fkm.fhi4=5.0
fkm.compute

set i=35,629,925,1592,2597,3052
set d=4.491562,7.425816,2.750253,2.00795,-0.4443082,0.1626
setb ok=true
foreach(i)
    if(fkm.fk[1].matrix[i] != d[for_index]); setb ok=false; endif
endfor
if( ok ); print &quot;fkm test 1 OK&quot;
else; print &quot;fkm test 1 failed&quot;; endif

set d=-0.3521085,2.301743,0.3811328,1.265903,1.492815,-1.004292
setb ok=true
foreach(i)
    if(fkm.fk[2].matrix[i] != d[for_index]); setb ok=false; endif
endfor
if( ok ); print &quot;fkm test 2 OK&quot;
else; print &quot;fkm test 2 failed&quot;; endif

set d=3.38638,1.897725,6.156598,4.291383,6.694542,5.112195
setb ok=true
foreach(i)
    if(fkm.fk[3].matrix[i] != d[for_index]); setb ok=false; endif
endfor
if( ok ); print &quot;fkm test 3 OK&quot;
else; print &quot;fkm test 3 failed&quot;; endif

set d=5.941749,5.927873,4.657875,3.155243,6.661675,6.678609
setb ok=true
foreach(i)
    if(fkm.fk[4].matrix[i] != d[for_index]); setb ok=false; endif
endfor
if( ok ); print &quot;fkm test 4 OK&quot;
else; print &quot;fkm test 4 failed&quot;; endif

remove_all_cursors
fkm.parameters.signal_window=5.
fkm.parameters.signal_overlap=3.
fkm.parameters.stav_length=1.0
fkm.parameters.ltav_length=60.0
fkm.parameters.azimuth_min=0.
fkm.parameters.azimuth_max=360.
km.auto_compute

set i=2,6,13,27,31,29,44

set d=6.132403,1.252414,0.8941448,0.2372706,1.04725,0.8813089,1.31138
setb ok=true
foreach(i)
    if(fkm.sig[1].snr[i] != d[for_index]); setb ok=false; endif
endfor
if( ok ); print &quot;fkm test 5 OK&quot;
else; print &quot;fkm test 5 failed&quot;; endif

set d=8.069169,4.113804,10.94561,7.558168,7.475073,5.191255,9.810118
setb ok=true
foreach(i)
    if(fkm.sig[1].fstat[i] != d[for_index]); setb ok=false; endif
endfor
if( ok ); print &quot;fkm test 6 OK&quot;
else; print &quot;fkm test 6 failed&quot;; endif

set d=10.73954,5.99781,5.800088,7.10604,5.507839,9.290447,4.179029
setb ok=true
foreach(i)
    if(fkm.sig[1].appvel[i] != d[for_index]); setb ok=false; endif
endfor
if( ok ); print &quot;fkm test 7 OK&quot;
else; print &quot;fkm test 7 failed&quot;; endif

set d=10.35379,18.53925,19.17125,15.64794,20.18848,11.96874,26.60784
setb ok=true
foreach(i)
    if(fkm.sig[1].slowness[i] != d[for_index]); setb ok=false; endif
endfor
if( ok ); print &quot;fkm test 8 OK&quot;
else; print &quot;fkm test 8 failed&quot;; endif

set d=143.9099,182.2951,187.4334,211.6373,210.155,152.8438,190.6845
setb ok=true
foreach(i)
    if(fkm.sig[1].azimuth[i] != d[for_index]); setb ok=false; endif
endfor
if( ok ); print &quot;fkm test 9 OK&quot;
else; print &quot;fkm test 9 failed&quot;; endif

set d=5.554864,1.649634,1.001311,0.9260368,1.310956,0.8357889,0.6238396
setb ok=true
foreach(i)
    if(fkm.sig[2].snr[i] != d[for_index]); setb ok=false; endif
endfor
if( ok ); print &quot;fkm test 10 OK&quot;
else; print &quot;fkm test 10 failed&quot;; endif
...
</PRE>
		</TD>
	</TR>
	</TABLE>
</DL>
<H1 CLASS="western"><A NAME="Example Scripts"></A>20.0 Example Scripts</H1>
<DL>
<P CLASS="western">
The following scripts demonstrate how to control some of the analysis options with scripts.</P>
<P CLASS="western"><A NAME="Creating a Waveform Beam"><B>Creating a Waveform Beam</B></P>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
if( defined(data_dir) )
    set data_file=data_dir+&quot;/DPRK.wfdisc&quot;
else
    print &quot;data_dir is not defined&quot;
    return
endif

# read some array waveforms
read file=data_file query=&quot;select * from wfdisc where sta like 'AS' and chan='SHZ'&quot;

# select all waveforms
select_all

# set the slowness and azimuth values for the beam
create_beam.slowness_units=&quot;s/deg&quot;
create_beam.slowness=23.3
create_beam.azimuth=185.8

# set the filter parameters
create_beam.beam_filter=&quot;on&quot;
create_beam.low=1.5
create_beam.high=4.5
create_beam.order=3
create_beam.type=&quot;BP&quot;
create_beam.constraint=&quot;causal&quot;

# append the beam to the waveform display
create_beam.replace=true
create_beam.beam

n = wave.size()    # the index of the beam

# write the beam to a file
output wave[n] file=&quot;beam01&quot; raw=false append=true output_tables=false
</PRE>
		</TD>
	</TR>
	</TABLE>
<P CLASS="western"><A NAME="Cepstral Analysis"><B>Cepstral Analysis</B></P>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
if( defined(data_dir) )
    set data_file=data_dir+&quot;/DPRK.wfdisc&quot;
else
    print &quot;data_dir is not defined&quot;
    return
endif

# read one waveform
read file=data_file query=&quot;select * from wfdisc where sta='AK01' and chan='BHZ'&quot;

# select the waveform
select 1

# set the cepstrum parameters
cepstrum.smoothing_npass=1
cepstrum.smoothing_width=0.2
cepstrum.low_frequency=2.0
cepstrum.high_frequency=20.
cepstrum.guard1=0.1
cepstrum.average_bandwidth1=4.0
cepstrum.tpass=1.0
cepstrum.detrend=0
cepstrum.pulse_delay_min=0.04
cepstrum.pulse_delay_max=3.0
cepstrum.guard2=0.1
cepstrum.average_bandwidth2=0.1

# compute the cepstrum
cepstrum.compute

# write the spectrum amplitude values to a binary file
writeOpen file=&quot;cepstrum1.bin&quot;
writeInt(cepstrum.spectrum.size()) # write the number of values
writeArray(cepstrum.frequency)     # write the frequency values
writeArray(cepstrum.spectrum)      # write the spectral amplitude
writeClose

# write the cepstrum values to an ascii file
printOpen file=&quot;cepstrum1.ascii&quot;
num = cepstrum.cepstrum.size()
print &quot;num =&quot; num
foreach(1, num, i)
    # write the delay time and the cepstrum value
    print cepstrum.delay[i](%7.3f) cepstrum.cepstrum[i](%8.5f)
endfor
printClose

# the following cepstral analysis arrays that are also accessible:
# cepstrum.smoothed[i]
# cepstrum.minus_noise[i]
# cepstrum.detrended[i]
# cepstrum.inverse[i]
</PRE>
		</TD>
	</TR>
	</TABLE>
<P CLASS="western"><A NAME="Correlation Analysis"><B>Correlation Analysis</B></P>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
if( defined(data_dir) )
    set data_file=data_dir+&quot;/DPRK.wfdisc&quot;
else
    print &quot;data_dir is not defined&quot;
    return
endif

# read some array waveforms
read file=data_file query=&quot;select * from wfdisc where sta like 'AS' and chan='SHZ'&quot;

# filter all waveforms
select_all
filter low=2.0 high=5.0

# position a time-window cursor at the first arrival
time_window tbeg=arrival[1].time tend=arrival[1].time+10

# set the correlation reference trace to be 10 seconds at the arrival time
deselect_all
select 1
correlation.set_reference

# position a 100-second time-window about the first arrival
time_window tbeg=arrival[1].time-50 tend=arrival[1].time+50

# compute the cross-correlation of the reference with all waveforms
# within the 100-second window
select_all
correlation.correlate

# print the sta, coef and lag columns to a file

printOpen file=&quot;correlation.output&quot;

set sta=correlation.table.column[1]
set coef=correlation.table.column[3]
set lag=correlation.table.column[5]

n = sta.size()
foreach(1, n, i)
    print sta[i] coef[i] lag[i]
endfor

printClose
</PRE>
		</TD>
	</TR>
	</TABLE>
<P CLASS="western"><A NAME="Filtering"><B>Filtering</B></P>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
if( defined(data_dir) )
    set data_file=data_dir+&quot;/DPRK.wfdisc&quot;
else
    print &quot;data_dir is not defined&quot;
    return
endif

# read a waveform
read file=data_file query=&quot;select * from wfdisc where sta='MK32' and chan='SHZ'&quot;

select 1

copy    # copy the selected waveform to the paste buffer

set lo=1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0  # define the frequency band limits
set hi=2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0

2.clear  # clear the second waveform window
# set the waveform tags in the second window
2.tag_contents.set tag=&quot;station,channel,filter(low high)&quot;

foreach(1, lo.size(), i)  # loop over all frequency bands
    2.paste               # paste from the paste buffer to the second window

    filter 2.wave[i] low=lo[i] high=hi[i]  # filter the waveform just pasted
endfor

# print the second window to a PostScript file

2.print_window.set command=&quot;&quot; filename=&quot;filter.ps&quot;
2.print_window.print
</PRE>
		</TD>
	</TR>
	</TABLE>
<P CLASS="western"><A NAME="Fourier Transform"><B>Fourier Transform</B></P>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
if( defined(data_dir) )
    set data_file=data_dir+&quot;/DPRK.wfdisc&quot;
else
    print &quot;data_dir is not defined&quot;
    return
endif

# read a waveform
read file=data_file query=&quot;select * from wfdisc where sta='AS01' and chan='SHZ'&quot;

select 1

# position a 20-second time window cursor at the first arrival

time_window tbeg=arrival[1].time tend=arrival[1].time+20

ft.x_axis=&quot;freq&quot;
ft.y_axis=&quot;Power_Displacement_dB_rel_nm&quot;
ft.display_data=&quot;input_traces&quot;
ft.demean=true
ft.instrument=false
ft.windows.number=1
ft.windows.overlap=0
ft.windows.apply
ft.smooth.width=0
ft.smooth.apply
ft.taper=&quot;Hanning&quot;
ft.draw_dc=false
ft.compute

# save the spectrum to a file

printOpen file=&quot;ft1&quot;
print ft.entry[1].sta ft.entry[1].chan ft.entry[1].time ft.entry[1].npts
print ft.entry[1].nfft ft.entry[1].df
df = ft.entry[1].df
n = ft.entry[1].pow.size()
foreach(1, n, i)
    freq = i*df
    print freq(%7.4f) ft.entry[1].pow[i](%15.6e) ft.entry[1].phase[i](%15.6e)
endfor
printClose
</PRE>
		</TD>
	</TR>
	</TABLE>
<P CLASS="western"><A NAME="FK Analysis"><B>FK Analysis</B></P>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
if( defined(data_dir) )
    set data_file=data_dir+&quot;/DPRK.wfdisc&quot;
else
    print &quot;data_dir is not defined&quot;
    return
endif

# read some array waveforms
read file=data_file query=&quot;select * from wfdisc where sta like 'AS' and chan='SHZ'&quot;

time_window tbeg=arrival[1].time-5. tend=arrival[1].time+5.
select_all

alias fkm=fk_multi_band

# set frequency band limits
fkm.flo1=0.5; fkm.fhi1=2.0
fkm.flo2=1.0; fkm.fhi2=3.0
fkm.flo3=2.0; fkm.fhi3=4.0
fkm.flo4=3.0; fkm.fhi4=5.0

# set grid size
fkm.slowness_max=40.0
fkm.num_slowness=61

# compute an FK
fkm.compute

# save the table that displays the slowness, azimuth, fstat,
# and SNR for the maximum FK values
fkm.table.save_all_rows file=&quot;fk.results&quot;

remove_all_cursors

# set the parameters for the FK signal computation
fkm.signal_slowness_min=1.
fkm.signal_slowness_max=40.
fkm.azimuth_min=1.
fkm.azimuth_max=350
fkm.window_length=5
fkm.window_overlap=3
fkm.stav_length=5
fkm.ltav_length=60

# compute the FK signal
fkm.auto_compute

# save the signal results

printOpen file=&quot;fk.results&quot; append=true
n = fkm.sig[1].snr.size()

print n &quot;snr&quot;
foreach(1, n, i)
    print fkm.sig[1].snr[i] fkm.sig[2].snr[i] fkm.sig[3].snr[i] fkm.sig[4].snr[i]
endfor

print n &quot;fstat&quot;
foreach(1, n, i)
    print fkm.sig[1].fstat[i] fkm.sig[2].fstat[i] fkm.sig[3].fstat[i] fkm.sig[4].fstat[i]
endfor

print n &quot;slowness&quot;
foreach(1, n, i)
    print fkm.sig[1].slowness[i] fkm.sig[2].slowness[i] fkm.sig[3].slowness[i] fkm.sig[4].slowness[i]
endfor

print n &quot;azimuth&quot;
foreach(1, n, i)
    print fkm.sig[1].azimuth[i] fkm.sig[2].azimuth[i] fkm.sig[3].azimuth[i] fkm.sig[4].azimuth[i]
endfor

printClose
</PRE>
		</TD>
	</TR>
	</TABLE>
<P CLASS="western"><A NAME="Event Location"><B>Event Location</B></P>
<P CLASS="western">
There are two Locate Event windows. One is connected to the waveform window and the other is connected to
the TableQuery (DB or Database) window. The first is accessed with commands that start with &quot;locate_event&quot;, such as
&quot;locate_event.reload&quot; and &quot;locate_event.locate&quot;. The Locate Event window that is connected to the
TableQuery window is accessed with commands that start with &quot;tablequery.locate_event&quot;, such as
&quot;tablequery.locate_event.reload&quot; and tablequery.locate_event.locate&quot;. These two window have the same functionality,
except in the way that they load origins and arrivals.</P>
<P CLASS="western">
The command &quot;locate_event.reload&quot; loads the Locate Event window with the origins and arrivals that have been read into
the waveform window along with the waveforms. These are the arrivals that are displayed on the waveforms. For
example:</P>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
if( defined(data_dir) )
    set data_file=data_dir+&quot;/DPRK_tutorial.wfdisc&quot;
else
    print &quot;data_dir is not defined&quot;
    return
endif

read file=data_file query=&quot;select * from wfdisc&quot;

# load the Locate Event window with arrivals that are displayed on the waveforms
locate_event.reload

# select an origin as the initial location
locate_event.origins.select_row orid=3875968

# compute the location and check the return status
locate_event.locate
if(locate_event.status != 0)
    print &quot;locate_event failed&quot;
    return
endif

# save the computed origin, origerr and assoc records to DPRK_tutorial
locate_event.save
</PRE>
		</TD>
	</TR>
	</TABLE>
<P CLASS="western">
The command &quot;tablequery.locate_event.reload&quot; loads the Locate Event window with all of the arrivals and possible and
origin from the tableQuery window. If the origin tab of the TableQuery window is on top and an origin record is
selected, then the &quot;tablequery.locate_event.reload&quot; command loads the selected origin and all associated arrivals,
regardless of the selected state of the arrivals in the arrival tab. On the other hand, if the arrival tab of the
TableQuery window is on top, then the &quot;tablequery.locate_event.reload&quot; command loads only the selected arrival
records and does not load any origins.
</P>

	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
if( defined(data_dir) )
    set data_file=data_dir+&quot;/DPRK_tutorial.wfdisc&quot;
else
    print &quot;data_dir is not defined&quot;
    return
endif

connect prefix=data_file
alias tl=tablequery.locate_event

# read all DPRK_tutorial records in to the TableQuery window
tablequery.get_all_tables
tablequery.origin.select_row orid=3875968

# load the Locate Event window with the selected origin and all arrivals
tl.reload
tl.origins.select_row 1

# compute the location and check the return status
tl.locate

locate_event.locate
if(locate_event.status != 0)
    print &quot;locate_event failed&quot;
    return
endif

# save the computed origin, origerr and assoc records to DPRK_tutorial
locate_event.save
</PRE>
		</TD>
	</TR>
	</TABLE>
<P CLASS="western">
The origin, arrival, assoc, and site  objects in the locate window are accessed as &quot;locate_event.origin&quot;,
&quot;locate_event.arrival&quot;, &quot;locate_event.assoc&quot;, &quot;locate_event.site&quot;, respectively. For example:
<DL>
<PRE CLASS="western">
print locate_event.origin.size()
print locate_event.origin[2]
print locate_event.origin[2].lat

print locate_event.arrival.size()
print locate_event.arrival[2]
print locate_event.arrival[2].time
etc.
</PRE>
</DL>
<P CLASS="western">
The arrival input data can be read with the "locate_event.arrival_data" array variable. For example:</P>
<DL>
<PRE CLASS="western">
print locate_event.arrival_data.size()
print locate_event.sel_arrival_data.size()
print locate_event.arrival_data[1].phase locate_event.arrival_data[1].timedef
print locate_event.arrival_data[1].sta locate_event.arrival_data[1].chan
print locate_event.arrival_data[1].lat locate_event.arrival_data[1].lon
</PRE>
</DL>
<P CLASS="western">
The arrival input data can be accessed to set the timedef, azdef, and slodef fields and to select or deselect
the arrival row. Only selected arrival rows are included in the location. The arrival input data is set
with <A HREF="#Table Commands">table commands</A> using the prefix &quot;locate_event.arrivals&quot; (note the 's').
For example:</P>
<DL>
<PRE CLASS="western">
n = locate_event.arrivals.num_rows
alias a = locate_event.arrivals
foreach(1, n, i)
    if(a.row[i].P == 'P')
	a.set_cell row=i column='T' value='d'
	a.set_cell row=i column='A' value='n'
	a.set_cell row=i column='S' value='n'
    else if(a.row[i].P == 'Pn')
        a.deselect_row i
    endif
endfor
</PRE>
</DL>
<P CLASS="western">
The location method parameters (the table at the bottom of the Locate Event window) are accessed with
<A HREF="#Table Commands">table commands</A> using the prefix &quot;locate_event.parameters&quot;. For example:
<DL>
<PRE CLASS="western">
locate_event.parameters.set_cell row=1 column='fix_ot' value=true
locate_event.parameters.set_cell row=1 column='fix_latlon' value=false
locate_event.parameters.set_cell row=1 column='fix_depth' value=true
locate_event.parameters.set_cell row=1 column='lat_init' value=40.20
locate_event.parameters.set_cell row=1 column='lon_init' value=128.01
locate_event.parameters.set_cell row=1 column='use_srst' value=true
# etc
</PRE>
</DL>
<P CLASS="western"><A NAME="Polarization Filter"><B>Polarization Filter</B></P>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
if( defined(data_dir) )
    set data_file=data_dir+&quot;/DPRK_tutorial.wfdisc&quot;
else
    print &quot;data_dir is not defined&quot;
    return
endif

clear
read file=data_file query=&quot;select * from wfdisc where sta='MK32'&quot;

select_all
polarization_filter.order=4
polarization_filter.low_cut=2.
polarization_filter.high_cut=5.
polarization_filter.frequency_cycles=4
polarization_filter.time_cycles=4
polarization_filter.azimuth=90.
polarization_filter.incidence=20.
polarization_filter.aperture=2
polarization_filter.scaling=2
polarization_filter.apply

# save the polar-filter waveform
output wave[4] file=&quot;polar&quot;
</PRE>
		</TD>
	</TR>
	</TABLE>
<P CLASS="western"><A NAME="Polarization Analysis"><B>Polarization Analysis</B></P>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
if( defined(data_dir) )
    set data_file=data_dir+&quot;/DPRK_tutorial.wfdisc&quot;
else
    print &quot;data_dir is not defined&quot;
    return
endif

clear
read file=data_file query=&quot;select * from wfdisc where sta='MK32'&quot;

select_all
filter low=2. high=4.
polarization.window_length=2.
polarization.window_overlap=1.5
polarization.compute

# save the results
printOpen file=&quot;polar.results&quot;

alias p=polarization
n = p.recti.size()
print n
foreach(1, n, i) 
    print p.recti[i] p.inc[i] p.paz[i] p.saz[i]
endfor
printClose
</PRE>
		</TD>
	</TR>
	</TABLE>
<P CLASS="western"><A NAME="Component Rotation"><B>Component Rotation</B></P>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
if( defined(data_dir) )
    set data_file=data_dir+&quot;/DPRK_tutorial.wfdisc&quot;
else
    print &quot;data_dir is not defined&quot;
    return
endif

clear
read file=data_file query=&quot;select * from wfdisc where sta='MK32'&quot;

select sta='MK32'
rotation.rotate azimuth=48.5 incidence=67.

time_window tbeg=arrival[1].time tend=arrival[1].time+1.
rotation.maximum
</PRE>
		</TD>
	</TR>
	</TABLE>
<P CLASS="western"><A NAME="Spectrogram"><B>Spectrogram</B></P>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
if( defined(data_dir) )
    set data_file=data_dir+&quot;/DPRK_tutorial.wfdisc&quot;
else
    print &quot;data_dir is not defined&quot;
    return
endif

clear
read file=data_file query=&quot;select * from wfdisc where sta='MK32'&quot; and chan='SHZ'&quot;

select 1

alias sp = spectrogram

sp.auto_window_parameters=false
sp.lo_freq=0.
sp.hi_freq=10.
sp.window_length=10
sp.window_overlap=9
sp.normalize=false
sp.bin_average=false
sp.instrument_corr=false
sp.log=true

sp.compute

printOpen file=&quot;spectro.out&quot;
n = sp.pow.size()
foreach(1, n, i)
    print sp.pow[i]
endfor
printClose
</PRE>
		</TD>
	</TR>
	</TABLE>
<P CLASS="western"><A NAME="Amplitudes and Magnitudes"><B>Amplitudes and Magnitudes</B></P>
<P CLASS="western">
The following script demonstrates how to add arrivals, compute a location,
measure amplitudes and compute magnitudes. Assuming that arrival times and
phases have been determined from a detector, this script adds arrivals to
two arrays stations and two three component stations. After a location is
computed, the "locate_event.save" writes an origin record, origerr record,
and assoc records to disk. An amplitude measure is made for each arrival and
these measurements are used to determine the event magnitude. The
&quot;compute_magnitudes&quot; command writes stamag and netmag records to disk.</P>
<P CLASS="western">
This script works with the test data file test/test.wfdisc.</P>
	<TABLE WIDTH=95% BORDER=2 BORDERCOLOR="#0066cc" CELLPADDING=5 CELLSPACING=0> <COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP BGCOLOR="#e6e6ff">
		<PRE CLASS="western">
if( defined(data_dir) )
    set data_file=data_dir+&quot;/test.wfdisc&quot;
else
    print &quot;data_dir is not defined&quot;
    return
endif

clear
read file=data_file 

# remove any existing origins and origerrs
if(origin.size() &gt; 0)
    origins.select_all
    origins.delete
endif

# remove any existing arrivals,assocs,amplitudes,stamags,netmags,picks
if(arrival.size() &gt; 0)
    arrivals.select_all
    arrivals.delete
endif

select sta='GEA1' chan='SHZ'
# add an arrival to the GERES array data
add_arrival time=1160358423.24 phase='P' sel_wave[1]

deselect_all
select sta='PD01' chan='sz'
# this is a another equivalent way to add an arrival
# add an arrival to the PDAR array data
position_phase_line x=1160358464.45 phase='P'
arrivals.add

deselect_all
select sta='FITZ' chan='BHZ'
# add an arrival to the FITZ 3-component data
add_arrival time=1160358330.01 phase='P' sel_wave[1]

deselect_all
select sta='VRAC' chan='BHZ'
# add an arrival to the VRAC 3-component data
add_arrival time=1160358412.11 phase='P' sel_wave[1]

locate_event.reload
locate_event.locate

if(locate_event.status != 0)
    print &quot;locate_event failed&quot;
    return
endif

locate_event.save

arrivals.select_all

arrivals.measure_mb

arrivals.compute_magnitudes
</PRE>
		</TD>
	</TR>
	</TABLE>
</BODY>
</HTML>
